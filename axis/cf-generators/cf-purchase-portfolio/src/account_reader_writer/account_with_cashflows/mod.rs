// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `purchase_portfolio.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct Cashflow {
    // message fields
    pub interest_amount: f64,
    pub principal_amount: f64,
    pub date: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cashflow {
    fn default() -> &'a Cashflow {
        <Cashflow as ::protobuf::Message>::default_instance()
    }
}

impl Cashflow {
    pub fn new() -> Cashflow {
        ::std::default::Default::default()
    }

    // double interest_amount = 1;


    pub fn get_interest_amount(&self) -> f64 {
        self.interest_amount
    }
    pub fn clear_interest_amount(&mut self) {
        self.interest_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_interest_amount(&mut self, v: f64) {
        self.interest_amount = v;
    }

    // double principal_amount = 2;


    pub fn get_principal_amount(&self) -> f64 {
        self.principal_amount
    }
    pub fn clear_principal_amount(&mut self) {
        self.principal_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_principal_amount(&mut self, v: f64) {
        self.principal_amount = v;
    }

    // int64 date = 3;


    pub fn get_date(&self) -> i64 {
        self.date
    }
    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }
}

impl ::protobuf::Message for Cashflow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.interest_amount = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.principal_amount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.interest_amount != 0. {
            my_size += 9;
        }
        if self.principal_amount != 0. {
            my_size += 9;
        }
        if self.date != 0 {
            my_size += ::protobuf::rt::value_size(3, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.interest_amount != 0. {
            os.write_double(1, self.interest_amount)?;
        }
        if self.principal_amount != 0. {
            os.write_double(2, self.principal_amount)?;
        }
        if self.date != 0 {
            os.write_int64(3, self.date)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cashflow {
        Cashflow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "interest_amount",
                |m: &Cashflow| { &m.interest_amount },
                |m: &mut Cashflow| { &mut m.interest_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "principal_amount",
                |m: &Cashflow| { &m.principal_amount },
                |m: &mut Cashflow| { &mut m.principal_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "date",
                |m: &Cashflow| { &m.date },
                |m: &mut Cashflow| { &mut m.date },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cashflow>(
                "Cashflow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cashflow {
        static instance: ::protobuf::rt::LazyV2<Cashflow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cashflow::new)
    }
}

impl ::protobuf::Clear for Cashflow {
    fn clear(&mut self) {
        self.interest_amount = 0.;
        self.principal_amount = 0.;
        self.date = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cashflow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cashflow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Account {
    // message fields
    pub id: ::std::string::String,
    pub account_number: ::std::string::String,
    pub cust_id: ::std::string::String,
    pub deal_name: ::std::string::String,
    pub principal_os: f64,
    pub deal_start_date: i64,
    pub cf_start_date: i64,
    pub cf_end_date: i64,
    pub accrued_interest: f64,
    pub deal_value: f64,
    pub gl_code: ::std::string::String,
    pub system_value: ::std::string::String,
    pub current_nominal_interest_rate: f64,
    pub product_type: ::std::string::String,
    pub originator_name: ::std::string::String,
    pub contract_yield: f64,
    pub payment_frequency: i64,
    pub loan_reset_frequency: ::std::string::String,
    pub interest_rate_type: ::std::string::String,
    pub next_reset_date: i64,
    pub borrower_constitution: ::std::string::String,
    pub pan: ::std::string::String,
    pub voter_id: ::std::string::String,
    pub external_benchmark: ::std::string::String,
    pub dpd_in_days: ::std::string::String,
    pub daily_dpd_reported_date: i64,
    pub due_from_customer: f64,
    pub cmonth_emi_due: f64,
    pub actual_amount_paid: f64,
    pub principal_due_cmonth: f64,
    pub principal_rcvd_cmonth: f64,
    pub interest_method_code: ::std::string::String,
    pub bank_share: f64,
    pub originator_share: f64,
    pub customer_od_bank_share: f64,
    pub customer_od_originator_share: f64,
    pub od_interest_bank_share: f64,
    pub od_interest_originator_share: f64,
    pub maturity_date: i64,
    pub exposure_unique_id: ::std::string::String,
    pub fic_mis_date: i64,
    pub system_date: i64,
    pub balm_control_status_id: ::std::string::String,
    pub derived_principal: f64,
    pub derived_cmonth_emi_due: f64,
    pub npa_classification: ::std::string::String,
    pub cust_hlth_code: ::std::string::String,
    pub cust_npa_class: ::std::string::String,
    pub final_npa_class: ::std::string::String,
    pub currency: ::std::string::String,
    pub cashflows: ::protobuf::RepeatedField<Cashflow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Account {
    fn default() -> &'a Account {
        <Account as ::protobuf::Message>::default_instance()
    }
}

impl Account {
    pub fn new() -> Account {
        ::std::default::Default::default()
    }

    // string id = 1;


    pub fn get_id(&self) -> &str {
        &self.id
    }
    pub fn clear_id(&mut self) {
        self.id.clear();
    }

    // Param is passed by value, moved
    pub fn set_id(&mut self, v: ::std::string::String) {
        self.id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_id(&mut self) -> &mut ::std::string::String {
        &mut self.id
    }

    // Take field
    pub fn take_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.id, ::std::string::String::new())
    }

    // string account_number = 2;


    pub fn get_account_number(&self) -> &str {
        &self.account_number
    }
    pub fn clear_account_number(&mut self) {
        self.account_number.clear();
    }

    // Param is passed by value, moved
    pub fn set_account_number(&mut self, v: ::std::string::String) {
        self.account_number = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account_number(&mut self) -> &mut ::std::string::String {
        &mut self.account_number
    }

    // Take field
    pub fn take_account_number(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account_number, ::std::string::String::new())
    }

    // string cust_id = 3;


    pub fn get_cust_id(&self) -> &str {
        &self.cust_id
    }
    pub fn clear_cust_id(&mut self) {
        self.cust_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cust_id(&mut self, v: ::std::string::String) {
        self.cust_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cust_id(&mut self) -> &mut ::std::string::String {
        &mut self.cust_id
    }

    // Take field
    pub fn take_cust_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cust_id, ::std::string::String::new())
    }

    // string deal_name = 4;


    pub fn get_deal_name(&self) -> &str {
        &self.deal_name
    }
    pub fn clear_deal_name(&mut self) {
        self.deal_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_deal_name(&mut self, v: ::std::string::String) {
        self.deal_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deal_name(&mut self) -> &mut ::std::string::String {
        &mut self.deal_name
    }

    // Take field
    pub fn take_deal_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.deal_name, ::std::string::String::new())
    }

    // double principal_os = 5;


    pub fn get_principal_os(&self) -> f64 {
        self.principal_os
    }
    pub fn clear_principal_os(&mut self) {
        self.principal_os = 0.;
    }

    // Param is passed by value, moved
    pub fn set_principal_os(&mut self, v: f64) {
        self.principal_os = v;
    }

    // int64 deal_start_date = 6;


    pub fn get_deal_start_date(&self) -> i64 {
        self.deal_start_date
    }
    pub fn clear_deal_start_date(&mut self) {
        self.deal_start_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_deal_start_date(&mut self, v: i64) {
        self.deal_start_date = v;
    }

    // int64 cf_start_date = 7;


    pub fn get_cf_start_date(&self) -> i64 {
        self.cf_start_date
    }
    pub fn clear_cf_start_date(&mut self) {
        self.cf_start_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_cf_start_date(&mut self, v: i64) {
        self.cf_start_date = v;
    }

    // int64 cf_end_date = 8;


    pub fn get_cf_end_date(&self) -> i64 {
        self.cf_end_date
    }
    pub fn clear_cf_end_date(&mut self) {
        self.cf_end_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_cf_end_date(&mut self, v: i64) {
        self.cf_end_date = v;
    }

    // double accrued_interest = 9;


    pub fn get_accrued_interest(&self) -> f64 {
        self.accrued_interest
    }
    pub fn clear_accrued_interest(&mut self) {
        self.accrued_interest = 0.;
    }

    // Param is passed by value, moved
    pub fn set_accrued_interest(&mut self, v: f64) {
        self.accrued_interest = v;
    }

    // double deal_value = 10;


    pub fn get_deal_value(&self) -> f64 {
        self.deal_value
    }
    pub fn clear_deal_value(&mut self) {
        self.deal_value = 0.;
    }

    // Param is passed by value, moved
    pub fn set_deal_value(&mut self, v: f64) {
        self.deal_value = v;
    }

    // string gl_code = 11;


    pub fn get_gl_code(&self) -> &str {
        &self.gl_code
    }
    pub fn clear_gl_code(&mut self) {
        self.gl_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_gl_code(&mut self, v: ::std::string::String) {
        self.gl_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gl_code(&mut self) -> &mut ::std::string::String {
        &mut self.gl_code
    }

    // Take field
    pub fn take_gl_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gl_code, ::std::string::String::new())
    }

    // string system_value = 12;


    pub fn get_system_value(&self) -> &str {
        &self.system_value
    }
    pub fn clear_system_value(&mut self) {
        self.system_value.clear();
    }

    // Param is passed by value, moved
    pub fn set_system_value(&mut self, v: ::std::string::String) {
        self.system_value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system_value(&mut self) -> &mut ::std::string::String {
        &mut self.system_value
    }

    // Take field
    pub fn take_system_value(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.system_value, ::std::string::String::new())
    }

    // double current_nominal_interest_rate = 13;


    pub fn get_current_nominal_interest_rate(&self) -> f64 {
        self.current_nominal_interest_rate
    }
    pub fn clear_current_nominal_interest_rate(&mut self) {
        self.current_nominal_interest_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_current_nominal_interest_rate(&mut self, v: f64) {
        self.current_nominal_interest_rate = v;
    }

    // string product_type = 14;


    pub fn get_product_type(&self) -> &str {
        &self.product_type
    }
    pub fn clear_product_type(&mut self) {
        self.product_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_product_type(&mut self, v: ::std::string::String) {
        self.product_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_product_type(&mut self) -> &mut ::std::string::String {
        &mut self.product_type
    }

    // Take field
    pub fn take_product_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.product_type, ::std::string::String::new())
    }

    // string originator_name = 15;


    pub fn get_originator_name(&self) -> &str {
        &self.originator_name
    }
    pub fn clear_originator_name(&mut self) {
        self.originator_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_originator_name(&mut self, v: ::std::string::String) {
        self.originator_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_originator_name(&mut self) -> &mut ::std::string::String {
        &mut self.originator_name
    }

    // Take field
    pub fn take_originator_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.originator_name, ::std::string::String::new())
    }

    // double contract_yield = 16;


    pub fn get_contract_yield(&self) -> f64 {
        self.contract_yield
    }
    pub fn clear_contract_yield(&mut self) {
        self.contract_yield = 0.;
    }

    // Param is passed by value, moved
    pub fn set_contract_yield(&mut self, v: f64) {
        self.contract_yield = v;
    }

    // int64 payment_frequency = 17;


    pub fn get_payment_frequency(&self) -> i64 {
        self.payment_frequency
    }
    pub fn clear_payment_frequency(&mut self) {
        self.payment_frequency = 0;
    }

    // Param is passed by value, moved
    pub fn set_payment_frequency(&mut self, v: i64) {
        self.payment_frequency = v;
    }

    // string loan_reset_frequency = 18;


    pub fn get_loan_reset_frequency(&self) -> &str {
        &self.loan_reset_frequency
    }
    pub fn clear_loan_reset_frequency(&mut self) {
        self.loan_reset_frequency.clear();
    }

    // Param is passed by value, moved
    pub fn set_loan_reset_frequency(&mut self, v: ::std::string::String) {
        self.loan_reset_frequency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loan_reset_frequency(&mut self) -> &mut ::std::string::String {
        &mut self.loan_reset_frequency
    }

    // Take field
    pub fn take_loan_reset_frequency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.loan_reset_frequency, ::std::string::String::new())
    }

    // string interest_rate_type = 19;


    pub fn get_interest_rate_type(&self) -> &str {
        &self.interest_rate_type
    }
    pub fn clear_interest_rate_type(&mut self) {
        self.interest_rate_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_interest_rate_type(&mut self, v: ::std::string::String) {
        self.interest_rate_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interest_rate_type(&mut self) -> &mut ::std::string::String {
        &mut self.interest_rate_type
    }

    // Take field
    pub fn take_interest_rate_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.interest_rate_type, ::std::string::String::new())
    }

    // int64 next_reset_date = 20;


    pub fn get_next_reset_date(&self) -> i64 {
        self.next_reset_date
    }
    pub fn clear_next_reset_date(&mut self) {
        self.next_reset_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_reset_date(&mut self, v: i64) {
        self.next_reset_date = v;
    }

    // string borrower_constitution = 21;


    pub fn get_borrower_constitution(&self) -> &str {
        &self.borrower_constitution
    }
    pub fn clear_borrower_constitution(&mut self) {
        self.borrower_constitution.clear();
    }

    // Param is passed by value, moved
    pub fn set_borrower_constitution(&mut self, v: ::std::string::String) {
        self.borrower_constitution = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_borrower_constitution(&mut self) -> &mut ::std::string::String {
        &mut self.borrower_constitution
    }

    // Take field
    pub fn take_borrower_constitution(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.borrower_constitution, ::std::string::String::new())
    }

    // string pan = 22;


    pub fn get_pan(&self) -> &str {
        &self.pan
    }
    pub fn clear_pan(&mut self) {
        self.pan.clear();
    }

    // Param is passed by value, moved
    pub fn set_pan(&mut self, v: ::std::string::String) {
        self.pan = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pan(&mut self) -> &mut ::std::string::String {
        &mut self.pan
    }

    // Take field
    pub fn take_pan(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.pan, ::std::string::String::new())
    }

    // string voter_id = 23;


    pub fn get_voter_id(&self) -> &str {
        &self.voter_id
    }
    pub fn clear_voter_id(&mut self) {
        self.voter_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_voter_id(&mut self, v: ::std::string::String) {
        self.voter_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voter_id(&mut self) -> &mut ::std::string::String {
        &mut self.voter_id
    }

    // Take field
    pub fn take_voter_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.voter_id, ::std::string::String::new())
    }

    // string external_benchmark = 24;


    pub fn get_external_benchmark(&self) -> &str {
        &self.external_benchmark
    }
    pub fn clear_external_benchmark(&mut self) {
        self.external_benchmark.clear();
    }

    // Param is passed by value, moved
    pub fn set_external_benchmark(&mut self, v: ::std::string::String) {
        self.external_benchmark = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_external_benchmark(&mut self) -> &mut ::std::string::String {
        &mut self.external_benchmark
    }

    // Take field
    pub fn take_external_benchmark(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.external_benchmark, ::std::string::String::new())
    }

    // string dpd_in_days = 25;


    pub fn get_dpd_in_days(&self) -> &str {
        &self.dpd_in_days
    }
    pub fn clear_dpd_in_days(&mut self) {
        self.dpd_in_days.clear();
    }

    // Param is passed by value, moved
    pub fn set_dpd_in_days(&mut self, v: ::std::string::String) {
        self.dpd_in_days = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dpd_in_days(&mut self) -> &mut ::std::string::String {
        &mut self.dpd_in_days
    }

    // Take field
    pub fn take_dpd_in_days(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.dpd_in_days, ::std::string::String::new())
    }

    // int64 daily_dpd_reported_date = 26;


    pub fn get_daily_dpd_reported_date(&self) -> i64 {
        self.daily_dpd_reported_date
    }
    pub fn clear_daily_dpd_reported_date(&mut self) {
        self.daily_dpd_reported_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_daily_dpd_reported_date(&mut self, v: i64) {
        self.daily_dpd_reported_date = v;
    }

    // double due_from_customer = 27;


    pub fn get_due_from_customer(&self) -> f64 {
        self.due_from_customer
    }
    pub fn clear_due_from_customer(&mut self) {
        self.due_from_customer = 0.;
    }

    // Param is passed by value, moved
    pub fn set_due_from_customer(&mut self, v: f64) {
        self.due_from_customer = v;
    }

    // double cmonth_emi_due = 28;


    pub fn get_cmonth_emi_due(&self) -> f64 {
        self.cmonth_emi_due
    }
    pub fn clear_cmonth_emi_due(&mut self) {
        self.cmonth_emi_due = 0.;
    }

    // Param is passed by value, moved
    pub fn set_cmonth_emi_due(&mut self, v: f64) {
        self.cmonth_emi_due = v;
    }

    // double actual_amount_paid = 29;


    pub fn get_actual_amount_paid(&self) -> f64 {
        self.actual_amount_paid
    }
    pub fn clear_actual_amount_paid(&mut self) {
        self.actual_amount_paid = 0.;
    }

    // Param is passed by value, moved
    pub fn set_actual_amount_paid(&mut self, v: f64) {
        self.actual_amount_paid = v;
    }

    // double principal_due_cmonth = 30;


    pub fn get_principal_due_cmonth(&self) -> f64 {
        self.principal_due_cmonth
    }
    pub fn clear_principal_due_cmonth(&mut self) {
        self.principal_due_cmonth = 0.;
    }

    // Param is passed by value, moved
    pub fn set_principal_due_cmonth(&mut self, v: f64) {
        self.principal_due_cmonth = v;
    }

    // double principal_rcvd_cmonth = 31;


    pub fn get_principal_rcvd_cmonth(&self) -> f64 {
        self.principal_rcvd_cmonth
    }
    pub fn clear_principal_rcvd_cmonth(&mut self) {
        self.principal_rcvd_cmonth = 0.;
    }

    // Param is passed by value, moved
    pub fn set_principal_rcvd_cmonth(&mut self, v: f64) {
        self.principal_rcvd_cmonth = v;
    }

    // string interest_method_code = 32;


    pub fn get_interest_method_code(&self) -> &str {
        &self.interest_method_code
    }
    pub fn clear_interest_method_code(&mut self) {
        self.interest_method_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_interest_method_code(&mut self, v: ::std::string::String) {
        self.interest_method_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_interest_method_code(&mut self) -> &mut ::std::string::String {
        &mut self.interest_method_code
    }

    // Take field
    pub fn take_interest_method_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.interest_method_code, ::std::string::String::new())
    }

    // double bank_share = 33;


    pub fn get_bank_share(&self) -> f64 {
        self.bank_share
    }
    pub fn clear_bank_share(&mut self) {
        self.bank_share = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bank_share(&mut self, v: f64) {
        self.bank_share = v;
    }

    // double originator_share = 34;


    pub fn get_originator_share(&self) -> f64 {
        self.originator_share
    }
    pub fn clear_originator_share(&mut self) {
        self.originator_share = 0.;
    }

    // Param is passed by value, moved
    pub fn set_originator_share(&mut self, v: f64) {
        self.originator_share = v;
    }

    // double customer_od_bank_share = 35;


    pub fn get_customer_od_bank_share(&self) -> f64 {
        self.customer_od_bank_share
    }
    pub fn clear_customer_od_bank_share(&mut self) {
        self.customer_od_bank_share = 0.;
    }

    // Param is passed by value, moved
    pub fn set_customer_od_bank_share(&mut self, v: f64) {
        self.customer_od_bank_share = v;
    }

    // double customer_od_originator_share = 36;


    pub fn get_customer_od_originator_share(&self) -> f64 {
        self.customer_od_originator_share
    }
    pub fn clear_customer_od_originator_share(&mut self) {
        self.customer_od_originator_share = 0.;
    }

    // Param is passed by value, moved
    pub fn set_customer_od_originator_share(&mut self, v: f64) {
        self.customer_od_originator_share = v;
    }

    // double od_interest_bank_share = 37;


    pub fn get_od_interest_bank_share(&self) -> f64 {
        self.od_interest_bank_share
    }
    pub fn clear_od_interest_bank_share(&mut self) {
        self.od_interest_bank_share = 0.;
    }

    // Param is passed by value, moved
    pub fn set_od_interest_bank_share(&mut self, v: f64) {
        self.od_interest_bank_share = v;
    }

    // double od_interest_originator_share = 38;


    pub fn get_od_interest_originator_share(&self) -> f64 {
        self.od_interest_originator_share
    }
    pub fn clear_od_interest_originator_share(&mut self) {
        self.od_interest_originator_share = 0.;
    }

    // Param is passed by value, moved
    pub fn set_od_interest_originator_share(&mut self, v: f64) {
        self.od_interest_originator_share = v;
    }

    // int64 maturity_date = 39;


    pub fn get_maturity_date(&self) -> i64 {
        self.maturity_date
    }
    pub fn clear_maturity_date(&mut self) {
        self.maturity_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_maturity_date(&mut self, v: i64) {
        self.maturity_date = v;
    }

    // string exposure_unique_id = 40;


    pub fn get_exposure_unique_id(&self) -> &str {
        &self.exposure_unique_id
    }
    pub fn clear_exposure_unique_id(&mut self) {
        self.exposure_unique_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_exposure_unique_id(&mut self, v: ::std::string::String) {
        self.exposure_unique_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exposure_unique_id(&mut self) -> &mut ::std::string::String {
        &mut self.exposure_unique_id
    }

    // Take field
    pub fn take_exposure_unique_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.exposure_unique_id, ::std::string::String::new())
    }

    // int64 fic_mis_date = 41;


    pub fn get_fic_mis_date(&self) -> i64 {
        self.fic_mis_date
    }
    pub fn clear_fic_mis_date(&mut self) {
        self.fic_mis_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_fic_mis_date(&mut self, v: i64) {
        self.fic_mis_date = v;
    }

    // int64 system_date = 42;


    pub fn get_system_date(&self) -> i64 {
        self.system_date
    }
    pub fn clear_system_date(&mut self) {
        self.system_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_system_date(&mut self, v: i64) {
        self.system_date = v;
    }

    // string balm_control_status_id = 43;


    pub fn get_balm_control_status_id(&self) -> &str {
        &self.balm_control_status_id
    }
    pub fn clear_balm_control_status_id(&mut self) {
        self.balm_control_status_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_balm_control_status_id(&mut self, v: ::std::string::String) {
        self.balm_control_status_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balm_control_status_id(&mut self) -> &mut ::std::string::String {
        &mut self.balm_control_status_id
    }

    // Take field
    pub fn take_balm_control_status_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.balm_control_status_id, ::std::string::String::new())
    }

    // double derived_principal = 44;


    pub fn get_derived_principal(&self) -> f64 {
        self.derived_principal
    }
    pub fn clear_derived_principal(&mut self) {
        self.derived_principal = 0.;
    }

    // Param is passed by value, moved
    pub fn set_derived_principal(&mut self, v: f64) {
        self.derived_principal = v;
    }

    // double derived_cmonth_emi_due = 45;


    pub fn get_derived_cmonth_emi_due(&self) -> f64 {
        self.derived_cmonth_emi_due
    }
    pub fn clear_derived_cmonth_emi_due(&mut self) {
        self.derived_cmonth_emi_due = 0.;
    }

    // Param is passed by value, moved
    pub fn set_derived_cmonth_emi_due(&mut self, v: f64) {
        self.derived_cmonth_emi_due = v;
    }

    // string npa_classification = 46;


    pub fn get_npa_classification(&self) -> &str {
        &self.npa_classification
    }
    pub fn clear_npa_classification(&mut self) {
        self.npa_classification.clear();
    }

    // Param is passed by value, moved
    pub fn set_npa_classification(&mut self, v: ::std::string::String) {
        self.npa_classification = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npa_classification(&mut self) -> &mut ::std::string::String {
        &mut self.npa_classification
    }

    // Take field
    pub fn take_npa_classification(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.npa_classification, ::std::string::String::new())
    }

    // string cust_hlth_code = 47;


    pub fn get_cust_hlth_code(&self) -> &str {
        &self.cust_hlth_code
    }
    pub fn clear_cust_hlth_code(&mut self) {
        self.cust_hlth_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_cust_hlth_code(&mut self, v: ::std::string::String) {
        self.cust_hlth_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cust_hlth_code(&mut self) -> &mut ::std::string::String {
        &mut self.cust_hlth_code
    }

    // Take field
    pub fn take_cust_hlth_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cust_hlth_code, ::std::string::String::new())
    }

    // string cust_npa_class = 48;


    pub fn get_cust_npa_class(&self) -> &str {
        &self.cust_npa_class
    }
    pub fn clear_cust_npa_class(&mut self) {
        self.cust_npa_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_cust_npa_class(&mut self, v: ::std::string::String) {
        self.cust_npa_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cust_npa_class(&mut self) -> &mut ::std::string::String {
        &mut self.cust_npa_class
    }

    // Take field
    pub fn take_cust_npa_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cust_npa_class, ::std::string::String::new())
    }

    // string final_npa_class = 49;


    pub fn get_final_npa_class(&self) -> &str {
        &self.final_npa_class
    }
    pub fn clear_final_npa_class(&mut self) {
        self.final_npa_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_final_npa_class(&mut self, v: ::std::string::String) {
        self.final_npa_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_final_npa_class(&mut self) -> &mut ::std::string::String {
        &mut self.final_npa_class
    }

    // Take field
    pub fn take_final_npa_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.final_npa_class, ::std::string::String::new())
    }

    // string currency = 50;


    pub fn get_currency(&self) -> &str {
        &self.currency
    }
    pub fn clear_currency(&mut self) {
        self.currency.clear();
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: ::std::string::String) {
        self.currency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currency(&mut self) -> &mut ::std::string::String {
        &mut self.currency
    }

    // Take field
    pub fn take_currency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.currency, ::std::string::String::new())
    }

    // repeated .Cashflow cashflows = 51;


    pub fn get_cashflows(&self) -> &[Cashflow] {
        &self.cashflows
    }
    pub fn clear_cashflows(&mut self) {
        self.cashflows.clear();
    }

    // Param is passed by value, moved
    pub fn set_cashflows(&mut self, v: ::protobuf::RepeatedField<Cashflow>) {
        self.cashflows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cashflows(&mut self) -> &mut ::protobuf::RepeatedField<Cashflow> {
        &mut self.cashflows
    }

    // Take field
    pub fn take_cashflows(&mut self) -> ::protobuf::RepeatedField<Cashflow> {
        ::std::mem::replace(&mut self.cashflows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Account {
    fn is_initialized(&self) -> bool {
        for v in &self.cashflows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.id)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account_number)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cust_id)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.deal_name)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.principal_os = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deal_start_date = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cf_start_date = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cf_end_date = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.accrued_interest = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.deal_value = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gl_code)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.system_value)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.current_nominal_interest_rate = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.product_type)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.originator_name)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.contract_yield = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.payment_frequency = tmp;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.loan_reset_frequency)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.interest_rate_type)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.next_reset_date = tmp;
                },
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.borrower_constitution)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.pan)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.voter_id)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.external_benchmark)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.dpd_in_days)?;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.daily_dpd_reported_date = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.due_from_customer = tmp;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.cmonth_emi_due = tmp;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.actual_amount_paid = tmp;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.principal_due_cmonth = tmp;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.principal_rcvd_cmonth = tmp;
                },
                32 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.interest_method_code)?;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.bank_share = tmp;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.originator_share = tmp;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.customer_od_bank_share = tmp;
                },
                36 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.customer_od_originator_share = tmp;
                },
                37 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.od_interest_bank_share = tmp;
                },
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.od_interest_originator_share = tmp;
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.maturity_date = tmp;
                },
                40 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.exposure_unique_id)?;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fic_mis_date = tmp;
                },
                42 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.system_date = tmp;
                },
                43 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.balm_control_status_id)?;
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.derived_principal = tmp;
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.derived_cmonth_emi_due = tmp;
                },
                46 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.npa_classification)?;
                },
                47 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cust_hlth_code)?;
                },
                48 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cust_npa_class)?;
                },
                49 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.final_npa_class)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.currency)?;
                },
                51 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cashflows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.account_number.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.account_number);
        }
        if !self.cust_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cust_id);
        }
        if !self.deal_name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.deal_name);
        }
        if self.principal_os != 0. {
            my_size += 9;
        }
        if self.deal_start_date != 0 {
            my_size += ::protobuf::rt::value_size(6, self.deal_start_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cf_start_date != 0 {
            my_size += ::protobuf::rt::value_size(7, self.cf_start_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cf_end_date != 0 {
            my_size += ::protobuf::rt::value_size(8, self.cf_end_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.accrued_interest != 0. {
            my_size += 9;
        }
        if self.deal_value != 0. {
            my_size += 9;
        }
        if !self.gl_code.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.gl_code);
        }
        if !self.system_value.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.system_value);
        }
        if self.current_nominal_interest_rate != 0. {
            my_size += 9;
        }
        if !self.product_type.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.product_type);
        }
        if !self.originator_name.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.originator_name);
        }
        if self.contract_yield != 0. {
            my_size += 10;
        }
        if self.payment_frequency != 0 {
            my_size += ::protobuf::rt::value_size(17, self.payment_frequency, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.loan_reset_frequency.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.loan_reset_frequency);
        }
        if !self.interest_rate_type.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.interest_rate_type);
        }
        if self.next_reset_date != 0 {
            my_size += ::protobuf::rt::value_size(20, self.next_reset_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.borrower_constitution.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.borrower_constitution);
        }
        if !self.pan.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.pan);
        }
        if !self.voter_id.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.voter_id);
        }
        if !self.external_benchmark.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.external_benchmark);
        }
        if !self.dpd_in_days.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.dpd_in_days);
        }
        if self.daily_dpd_reported_date != 0 {
            my_size += ::protobuf::rt::value_size(26, self.daily_dpd_reported_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.due_from_customer != 0. {
            my_size += 10;
        }
        if self.cmonth_emi_due != 0. {
            my_size += 10;
        }
        if self.actual_amount_paid != 0. {
            my_size += 10;
        }
        if self.principal_due_cmonth != 0. {
            my_size += 10;
        }
        if self.principal_rcvd_cmonth != 0. {
            my_size += 10;
        }
        if !self.interest_method_code.is_empty() {
            my_size += ::protobuf::rt::string_size(32, &self.interest_method_code);
        }
        if self.bank_share != 0. {
            my_size += 10;
        }
        if self.originator_share != 0. {
            my_size += 10;
        }
        if self.customer_od_bank_share != 0. {
            my_size += 10;
        }
        if self.customer_od_originator_share != 0. {
            my_size += 10;
        }
        if self.od_interest_bank_share != 0. {
            my_size += 10;
        }
        if self.od_interest_originator_share != 0. {
            my_size += 10;
        }
        if self.maturity_date != 0 {
            my_size += ::protobuf::rt::value_size(39, self.maturity_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.exposure_unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(40, &self.exposure_unique_id);
        }
        if self.fic_mis_date != 0 {
            my_size += ::protobuf::rt::value_size(41, self.fic_mis_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.system_date != 0 {
            my_size += ::protobuf::rt::value_size(42, self.system_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.balm_control_status_id.is_empty() {
            my_size += ::protobuf::rt::string_size(43, &self.balm_control_status_id);
        }
        if self.derived_principal != 0. {
            my_size += 10;
        }
        if self.derived_cmonth_emi_due != 0. {
            my_size += 10;
        }
        if !self.npa_classification.is_empty() {
            my_size += ::protobuf::rt::string_size(46, &self.npa_classification);
        }
        if !self.cust_hlth_code.is_empty() {
            my_size += ::protobuf::rt::string_size(47, &self.cust_hlth_code);
        }
        if !self.cust_npa_class.is_empty() {
            my_size += ::protobuf::rt::string_size(48, &self.cust_npa_class);
        }
        if !self.final_npa_class.is_empty() {
            my_size += ::protobuf::rt::string_size(49, &self.final_npa_class);
        }
        if !self.currency.is_empty() {
            my_size += ::protobuf::rt::string_size(50, &self.currency);
        }
        for value in &self.cashflows {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.account_number.is_empty() {
            os.write_string(2, &self.account_number)?;
        }
        if !self.cust_id.is_empty() {
            os.write_string(3, &self.cust_id)?;
        }
        if !self.deal_name.is_empty() {
            os.write_string(4, &self.deal_name)?;
        }
        if self.principal_os != 0. {
            os.write_double(5, self.principal_os)?;
        }
        if self.deal_start_date != 0 {
            os.write_int64(6, self.deal_start_date)?;
        }
        if self.cf_start_date != 0 {
            os.write_int64(7, self.cf_start_date)?;
        }
        if self.cf_end_date != 0 {
            os.write_int64(8, self.cf_end_date)?;
        }
        if self.accrued_interest != 0. {
            os.write_double(9, self.accrued_interest)?;
        }
        if self.deal_value != 0. {
            os.write_double(10, self.deal_value)?;
        }
        if !self.gl_code.is_empty() {
            os.write_string(11, &self.gl_code)?;
        }
        if !self.system_value.is_empty() {
            os.write_string(12, &self.system_value)?;
        }
        if self.current_nominal_interest_rate != 0. {
            os.write_double(13, self.current_nominal_interest_rate)?;
        }
        if !self.product_type.is_empty() {
            os.write_string(14, &self.product_type)?;
        }
        if !self.originator_name.is_empty() {
            os.write_string(15, &self.originator_name)?;
        }
        if self.contract_yield != 0. {
            os.write_double(16, self.contract_yield)?;
        }
        if self.payment_frequency != 0 {
            os.write_int64(17, self.payment_frequency)?;
        }
        if !self.loan_reset_frequency.is_empty() {
            os.write_string(18, &self.loan_reset_frequency)?;
        }
        if !self.interest_rate_type.is_empty() {
            os.write_string(19, &self.interest_rate_type)?;
        }
        if self.next_reset_date != 0 {
            os.write_int64(20, self.next_reset_date)?;
        }
        if !self.borrower_constitution.is_empty() {
            os.write_string(21, &self.borrower_constitution)?;
        }
        if !self.pan.is_empty() {
            os.write_string(22, &self.pan)?;
        }
        if !self.voter_id.is_empty() {
            os.write_string(23, &self.voter_id)?;
        }
        if !self.external_benchmark.is_empty() {
            os.write_string(24, &self.external_benchmark)?;
        }
        if !self.dpd_in_days.is_empty() {
            os.write_string(25, &self.dpd_in_days)?;
        }
        if self.daily_dpd_reported_date != 0 {
            os.write_int64(26, self.daily_dpd_reported_date)?;
        }
        if self.due_from_customer != 0. {
            os.write_double(27, self.due_from_customer)?;
        }
        if self.cmonth_emi_due != 0. {
            os.write_double(28, self.cmonth_emi_due)?;
        }
        if self.actual_amount_paid != 0. {
            os.write_double(29, self.actual_amount_paid)?;
        }
        if self.principal_due_cmonth != 0. {
            os.write_double(30, self.principal_due_cmonth)?;
        }
        if self.principal_rcvd_cmonth != 0. {
            os.write_double(31, self.principal_rcvd_cmonth)?;
        }
        if !self.interest_method_code.is_empty() {
            os.write_string(32, &self.interest_method_code)?;
        }
        if self.bank_share != 0. {
            os.write_double(33, self.bank_share)?;
        }
        if self.originator_share != 0. {
            os.write_double(34, self.originator_share)?;
        }
        if self.customer_od_bank_share != 0. {
            os.write_double(35, self.customer_od_bank_share)?;
        }
        if self.customer_od_originator_share != 0. {
            os.write_double(36, self.customer_od_originator_share)?;
        }
        if self.od_interest_bank_share != 0. {
            os.write_double(37, self.od_interest_bank_share)?;
        }
        if self.od_interest_originator_share != 0. {
            os.write_double(38, self.od_interest_originator_share)?;
        }
        if self.maturity_date != 0 {
            os.write_int64(39, self.maturity_date)?;
        }
        if !self.exposure_unique_id.is_empty() {
            os.write_string(40, &self.exposure_unique_id)?;
        }
        if self.fic_mis_date != 0 {
            os.write_int64(41, self.fic_mis_date)?;
        }
        if self.system_date != 0 {
            os.write_int64(42, self.system_date)?;
        }
        if !self.balm_control_status_id.is_empty() {
            os.write_string(43, &self.balm_control_status_id)?;
        }
        if self.derived_principal != 0. {
            os.write_double(44, self.derived_principal)?;
        }
        if self.derived_cmonth_emi_due != 0. {
            os.write_double(45, self.derived_cmonth_emi_due)?;
        }
        if !self.npa_classification.is_empty() {
            os.write_string(46, &self.npa_classification)?;
        }
        if !self.cust_hlth_code.is_empty() {
            os.write_string(47, &self.cust_hlth_code)?;
        }
        if !self.cust_npa_class.is_empty() {
            os.write_string(48, &self.cust_npa_class)?;
        }
        if !self.final_npa_class.is_empty() {
            os.write_string(49, &self.final_npa_class)?;
        }
        if !self.currency.is_empty() {
            os.write_string(50, &self.currency)?;
        }
        for v in &self.cashflows {
            os.write_tag(51, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Account {
        Account::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "id",
                |m: &Account| { &m.id },
                |m: &mut Account| { &mut m.id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "account_number",
                |m: &Account| { &m.account_number },
                |m: &mut Account| { &mut m.account_number },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cust_id",
                |m: &Account| { &m.cust_id },
                |m: &mut Account| { &mut m.cust_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "deal_name",
                |m: &Account| { &m.deal_name },
                |m: &mut Account| { &mut m.deal_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "principal_os",
                |m: &Account| { &m.principal_os },
                |m: &mut Account| { &mut m.principal_os },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "deal_start_date",
                |m: &Account| { &m.deal_start_date },
                |m: &mut Account| { &mut m.deal_start_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cf_start_date",
                |m: &Account| { &m.cf_start_date },
                |m: &mut Account| { &mut m.cf_start_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cf_end_date",
                |m: &Account| { &m.cf_end_date },
                |m: &mut Account| { &mut m.cf_end_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "accrued_interest",
                |m: &Account| { &m.accrued_interest },
                |m: &mut Account| { &mut m.accrued_interest },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "deal_value",
                |m: &Account| { &m.deal_value },
                |m: &mut Account| { &mut m.deal_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gl_code",
                |m: &Account| { &m.gl_code },
                |m: &mut Account| { &mut m.gl_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "system_value",
                |m: &Account| { &m.system_value },
                |m: &mut Account| { &mut m.system_value },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "current_nominal_interest_rate",
                |m: &Account| { &m.current_nominal_interest_rate },
                |m: &mut Account| { &mut m.current_nominal_interest_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "product_type",
                |m: &Account| { &m.product_type },
                |m: &mut Account| { &mut m.product_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "originator_name",
                |m: &Account| { &m.originator_name },
                |m: &mut Account| { &mut m.originator_name },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "contract_yield",
                |m: &Account| { &m.contract_yield },
                |m: &mut Account| { &mut m.contract_yield },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "payment_frequency",
                |m: &Account| { &m.payment_frequency },
                |m: &mut Account| { &mut m.payment_frequency },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loan_reset_frequency",
                |m: &Account| { &m.loan_reset_frequency },
                |m: &mut Account| { &mut m.loan_reset_frequency },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "interest_rate_type",
                |m: &Account| { &m.interest_rate_type },
                |m: &mut Account| { &mut m.interest_rate_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "next_reset_date",
                |m: &Account| { &m.next_reset_date },
                |m: &mut Account| { &mut m.next_reset_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "borrower_constitution",
                |m: &Account| { &m.borrower_constitution },
                |m: &mut Account| { &mut m.borrower_constitution },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pan",
                |m: &Account| { &m.pan },
                |m: &mut Account| { &mut m.pan },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "voter_id",
                |m: &Account| { &m.voter_id },
                |m: &mut Account| { &mut m.voter_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "external_benchmark",
                |m: &Account| { &m.external_benchmark },
                |m: &mut Account| { &mut m.external_benchmark },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dpd_in_days",
                |m: &Account| { &m.dpd_in_days },
                |m: &mut Account| { &mut m.dpd_in_days },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "daily_dpd_reported_date",
                |m: &Account| { &m.daily_dpd_reported_date },
                |m: &mut Account| { &mut m.daily_dpd_reported_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "due_from_customer",
                |m: &Account| { &m.due_from_customer },
                |m: &mut Account| { &mut m.due_from_customer },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "cmonth_emi_due",
                |m: &Account| { &m.cmonth_emi_due },
                |m: &mut Account| { &mut m.cmonth_emi_due },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "actual_amount_paid",
                |m: &Account| { &m.actual_amount_paid },
                |m: &mut Account| { &mut m.actual_amount_paid },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "principal_due_cmonth",
                |m: &Account| { &m.principal_due_cmonth },
                |m: &mut Account| { &mut m.principal_due_cmonth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "principal_rcvd_cmonth",
                |m: &Account| { &m.principal_rcvd_cmonth },
                |m: &mut Account| { &mut m.principal_rcvd_cmonth },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "interest_method_code",
                |m: &Account| { &m.interest_method_code },
                |m: &mut Account| { &mut m.interest_method_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bank_share",
                |m: &Account| { &m.bank_share },
                |m: &mut Account| { &mut m.bank_share },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "originator_share",
                |m: &Account| { &m.originator_share },
                |m: &mut Account| { &mut m.originator_share },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "customer_od_bank_share",
                |m: &Account| { &m.customer_od_bank_share },
                |m: &mut Account| { &mut m.customer_od_bank_share },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "customer_od_originator_share",
                |m: &Account| { &m.customer_od_originator_share },
                |m: &mut Account| { &mut m.customer_od_originator_share },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "od_interest_bank_share",
                |m: &Account| { &m.od_interest_bank_share },
                |m: &mut Account| { &mut m.od_interest_bank_share },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "od_interest_originator_share",
                |m: &Account| { &m.od_interest_originator_share },
                |m: &mut Account| { &mut m.od_interest_originator_share },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "maturity_date",
                |m: &Account| { &m.maturity_date },
                |m: &mut Account| { &mut m.maturity_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exposure_unique_id",
                |m: &Account| { &m.exposure_unique_id },
                |m: &mut Account| { &mut m.exposure_unique_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fic_mis_date",
                |m: &Account| { &m.fic_mis_date },
                |m: &mut Account| { &mut m.fic_mis_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "system_date",
                |m: &Account| { &m.system_date },
                |m: &mut Account| { &mut m.system_date },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "balm_control_status_id",
                |m: &Account| { &m.balm_control_status_id },
                |m: &mut Account| { &mut m.balm_control_status_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "derived_principal",
                |m: &Account| { &m.derived_principal },
                |m: &mut Account| { &mut m.derived_principal },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "derived_cmonth_emi_due",
                |m: &Account| { &m.derived_cmonth_emi_due },
                |m: &mut Account| { &mut m.derived_cmonth_emi_due },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "npa_classification",
                |m: &Account| { &m.npa_classification },
                |m: &mut Account| { &mut m.npa_classification },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cust_hlth_code",
                |m: &Account| { &m.cust_hlth_code },
                |m: &mut Account| { &mut m.cust_hlth_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cust_npa_class",
                |m: &Account| { &m.cust_npa_class },
                |m: &mut Account| { &mut m.cust_npa_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "final_npa_class",
                |m: &Account| { &m.final_npa_class },
                |m: &mut Account| { &mut m.final_npa_class },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "currency",
                |m: &Account| { &m.currency },
                |m: &mut Account| { &mut m.currency },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cashflow>>(
                "cashflows",
                |m: &Account| { &m.cashflows },
                |m: &mut Account| { &mut m.cashflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Account>(
                "Account",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Account {
        static instance: ::protobuf::rt::LazyV2<Account> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Account::new)
    }
}

impl ::protobuf::Clear for Account {
    fn clear(&mut self) {
        self.id.clear();
        self.account_number.clear();
        self.cust_id.clear();
        self.deal_name.clear();
        self.principal_os = 0.;
        self.deal_start_date = 0;
        self.cf_start_date = 0;
        self.cf_end_date = 0;
        self.accrued_interest = 0.;
        self.deal_value = 0.;
        self.gl_code.clear();
        self.system_value.clear();
        self.current_nominal_interest_rate = 0.;
        self.product_type.clear();
        self.originator_name.clear();
        self.contract_yield = 0.;
        self.payment_frequency = 0;
        self.loan_reset_frequency.clear();
        self.interest_rate_type.clear();
        self.next_reset_date = 0;
        self.borrower_constitution.clear();
        self.pan.clear();
        self.voter_id.clear();
        self.external_benchmark.clear();
        self.dpd_in_days.clear();
        self.daily_dpd_reported_date = 0;
        self.due_from_customer = 0.;
        self.cmonth_emi_due = 0.;
        self.actual_amount_paid = 0.;
        self.principal_due_cmonth = 0.;
        self.principal_rcvd_cmonth = 0.;
        self.interest_method_code.clear();
        self.bank_share = 0.;
        self.originator_share = 0.;
        self.customer_od_bank_share = 0.;
        self.customer_od_originator_share = 0.;
        self.od_interest_bank_share = 0.;
        self.od_interest_originator_share = 0.;
        self.maturity_date = 0;
        self.exposure_unique_id.clear();
        self.fic_mis_date = 0;
        self.system_date = 0;
        self.balm_control_status_id.clear();
        self.derived_principal = 0.;
        self.derived_cmonth_emi_due = 0.;
        self.npa_classification.clear();
        self.cust_hlth_code.clear();
        self.cust_npa_class.clear();
        self.final_npa_class.clear();
        self.currency.clear();
        self.cashflows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Account {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Account {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x18purchase_portfolio.proto\"r\n\x08Cashflow\x12'\n\x0finterest_amoun\
    t\x18\x01\x20\x01(\x01R\x0einterestAmount\x12)\n\x10principal_amount\x18\
    \x02\x20\x01(\x01R\x0fprincipalAmount\x12\x12\n\x04date\x18\x03\x20\x01(\
    \x03R\x04date\"\xc1\x10\n\x07Account\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\
    \x02id\x12%\n\x0eaccount_number\x18\x02\x20\x01(\tR\raccountNumber\x12\
    \x17\n\x07cust_id\x18\x03\x20\x01(\tR\x06custId\x12\x1b\n\tdeal_name\x18\
    \x04\x20\x01(\tR\x08dealName\x12!\n\x0cprincipal_os\x18\x05\x20\x01(\x01\
    R\x0bprincipalOs\x12&\n\x0fdeal_start_date\x18\x06\x20\x01(\x03R\rdealSt\
    artDate\x12\"\n\rcf_start_date\x18\x07\x20\x01(\x03R\x0bcfStartDate\x12\
    \x1e\n\x0bcf_end_date\x18\x08\x20\x01(\x03R\tcfEndDate\x12)\n\x10accrued\
    _interest\x18\t\x20\x01(\x01R\x0faccruedInterest\x12\x1d\n\ndeal_value\
    \x18\n\x20\x01(\x01R\tdealValue\x12\x17\n\x07gl_code\x18\x0b\x20\x01(\tR\
    \x06glCode\x12!\n\x0csystem_value\x18\x0c\x20\x01(\tR\x0bsystemValue\x12\
    A\n\x1dcurrent_nominal_interest_rate\x18\r\x20\x01(\x01R\x1acurrentNomin\
    alInterestRate\x12!\n\x0cproduct_type\x18\x0e\x20\x01(\tR\x0bproductType\
    \x12'\n\x0foriginator_name\x18\x0f\x20\x01(\tR\x0eoriginatorName\x12%\n\
    \x0econtract_yield\x18\x10\x20\x01(\x01R\rcontractYield\x12+\n\x11paymen\
    t_frequency\x18\x11\x20\x01(\x03R\x10paymentFrequency\x120\n\x14loan_res\
    et_frequency\x18\x12\x20\x01(\tR\x12loanResetFrequency\x12,\n\x12interes\
    t_rate_type\x18\x13\x20\x01(\tR\x10interestRateType\x12&\n\x0fnext_reset\
    _date\x18\x14\x20\x01(\x03R\rnextResetDate\x123\n\x15borrower_constituti\
    on\x18\x15\x20\x01(\tR\x14borrowerConstitution\x12\x10\n\x03pan\x18\x16\
    \x20\x01(\tR\x03pan\x12\x19\n\x08voter_id\x18\x17\x20\x01(\tR\x07voterId\
    \x12-\n\x12external_benchmark\x18\x18\x20\x01(\tR\x11externalBenchmark\
    \x12\x1e\n\x0bdpd_in_days\x18\x19\x20\x01(\tR\tdpdInDays\x125\n\x17daily\
    _dpd_reported_date\x18\x1a\x20\x01(\x03R\x14dailyDpdReportedDate\x12*\n\
    \x11due_from_customer\x18\x1b\x20\x01(\x01R\x0fdueFromCustomer\x12$\n\
    \x0ecmonth_emi_due\x18\x1c\x20\x01(\x01R\x0ccmonthEmiDue\x12,\n\x12actua\
    l_amount_paid\x18\x1d\x20\x01(\x01R\x10actualAmountPaid\x120\n\x14princi\
    pal_due_cmonth\x18\x1e\x20\x01(\x01R\x12principalDueCmonth\x122\n\x15pri\
    ncipal_rcvd_cmonth\x18\x1f\x20\x01(\x01R\x13principalRcvdCmonth\x120\n\
    \x14interest_method_code\x18\x20\x20\x01(\tR\x12interestMethodCode\x12\
    \x1d\n\nbank_share\x18!\x20\x01(\x01R\tbankShare\x12)\n\x10originator_sh\
    are\x18\"\x20\x01(\x01R\x0foriginatorShare\x123\n\x16customer_od_bank_sh\
    are\x18#\x20\x01(\x01R\x13customerOdBankShare\x12?\n\x1ccustomer_od_orig\
    inator_share\x18$\x20\x01(\x01R\x19customerOdOriginatorShare\x123\n\x16o\
    d_interest_bank_share\x18%\x20\x01(\x01R\x13odInterestBankShare\x12?\n\
    \x1cod_interest_originator_share\x18&\x20\x01(\x01R\x19odInterestOrigina\
    torShare\x12#\n\rmaturity_date\x18'\x20\x01(\x03R\x0cmaturityDate\x12,\n\
    \x12exposure_unique_id\x18(\x20\x01(\tR\x10exposureUniqueId\x12\x20\n\
    \x0cfic_mis_date\x18)\x20\x01(\x03R\nficMisDate\x12\x1f\n\x0bsystem_date\
    \x18*\x20\x01(\x03R\nsystemDate\x123\n\x16balm_control_status_id\x18+\
    \x20\x01(\tR\x13balmControlStatusId\x12+\n\x11derived_principal\x18,\x20\
    \x01(\x01R\x10derivedPrincipal\x123\n\x16derived_cmonth_emi_due\x18-\x20\
    \x01(\x01R\x13derivedCmonthEmiDue\x12-\n\x12npa_classification\x18.\x20\
    \x01(\tR\x11npaClassification\x12$\n\x0ecust_hlth_code\x18/\x20\x01(\tR\
    \x0ccustHlthCode\x12$\n\x0ecust_npa_class\x180\x20\x01(\tR\x0ccustNpaCla\
    ss\x12&\n\x0ffinal_npa_class\x181\x20\x01(\tR\rfinalNpaClass\x12\x1a\n\
    \x08currency\x182\x20\x01(\tR\x08currency\x12'\n\tcashflows\x183\x20\x03\
    (\x0b2\t.CashflowR\tcashflowsb\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}