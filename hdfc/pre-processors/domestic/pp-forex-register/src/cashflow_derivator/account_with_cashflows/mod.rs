// This file is generated by rust-protobuf 2.4.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq, Clone, Default)]
pub struct Cashflow {
    // message fields
    pub int_amt: f64,
    pub prin_amt: f64,
    pub date: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Cashflow {
    pub fn new() -> Cashflow {
        ::std::default::Default::default()
    }

    // double int_amt = 1;

    pub fn clear_int_amt(&mut self) {
        self.int_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_int_amt(&mut self, v: f64) {
        self.int_amt = v;
    }

    pub fn get_int_amt(&self) -> f64 {
        self.int_amt
    }

    // double prin_amt = 2;

    pub fn clear_prin_amt(&mut self) {
        self.prin_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_prin_amt(&mut self, v: f64) {
        self.prin_amt = v;
    }

    pub fn get_prin_amt(&self) -> f64 {
        self.prin_amt
    }

    // int64 date = 3;

    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }

    pub fn get_date(&self) -> i64 {
        self.date
    }
}

impl ::protobuf::Message for Cashflow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.int_amt = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.prin_amt = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.int_amt != 0. {
            my_size += 9;
        }
        if self.prin_amt != 0. {
            my_size += 9;
        }
        if self.date != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.int_amt != 0. {
            os.write_double(1, self.int_amt)?;
        }
        if self.prin_amt != 0. {
            os.write_double(2, self.prin_amt)?;
        }
        if self.date != 0 {
            os.write_int64(3, self.date)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cashflow {
        Cashflow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "int_amt",
                    |m: &Cashflow| &m.int_amt,
                    |m: &mut Cashflow| &mut m.int_amt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "prin_amt",
                    |m: &Cashflow| &m.prin_amt,
                    |m: &mut Cashflow| &mut m.prin_amt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "date",
                    |m: &Cashflow| &m.date,
                    |m: &mut Cashflow| &mut m.date,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Cashflow>(
                    "Cashflow",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Cashflow {
        static mut instance: ::protobuf::lazy::Lazy<Cashflow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Cashflow,
        };
        unsafe { instance.get(Cashflow::new) }
    }
}

impl ::protobuf::Clear for Cashflow {
    fn clear(&mut self) {
        self.clear_int_amt();
        self.clear_prin_amt();
        self.clear_date();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cashflow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cashflow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct AccountWithCashflows {
    // message fields
    pub entity: ::std::string::String,
    pub trade_id: ::std::string::String,
    pub contract_typology: ::std::string::String,
    pub trade_typology: ::std::string::String,
    pub usage: ::std::string::String,
    pub desk: ::std::string::String,
    pub book: ::std::string::String,
    pub folder: ::std::string::String,
    pub trading_banking: ::std::string::String,
    pub internal_external: ::std::string::String,
    pub inter_entity: ::std::string::String,
    pub counterparty_long_name: ::std::string::String,
    pub cp_category_level_1: ::std::string::String,
    pub cp_category_level_2: ::std::string::String,
    pub cp_category_level_3: ::std::string::String,
    pub near_leg_far_leg: ::std::string::String,
    pub option_start_date: i64,
    pub option_end_date: i64,
    pub effective_date: i64,
    pub mat_date_of_contract: i64,
    pub ccil_guranteed: ::std::string::String,
    pub buy_currency: ::std::string::String,
    pub buy_current_notional: f64,
    pub sell_currency: ::std::string::String,
    pub sell_current_notional: f64,
    pub forward_rate: f64,
    pub forward_mtm: f64,
    pub mtm_in_inr_forward: f64,
    pub mtm_in_usd_forward: f64,
    pub pv_mtm_in_inr: f64,
    pub pv_mtm_in_usd: f64,
    pub pv01_in_inr: f64,
    pub mduriation_ccy1_inr: f64,
    pub mduriation_ccy2_inr: f64,
    pub contingent_notional_in_inr: f64,
    pub npa: ::std::string::String,
    pub bank_nonbank: ::std::string::String,
    pub original_tenor: i64,
    pub residual_tenor: i64,
    pub currency: ::std::string::String,
    pub cf_type: ::std::string::String,
    pub cntry_resid: ::std::string::String,
    pub cntry_ultim_risk: ::std::string::String,
    pub tot_int_amt: f64,
    pub tot_prin_amt: f64,
    pub counterparty_child_code: ::std::string::String,
    pub cashflows: ::protobuf::RepeatedField<Cashflow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountWithCashflows {
    pub fn new() -> AccountWithCashflows {
        ::std::default::Default::default()
    }

    // string entity = 1;

    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    pub fn get_entity(&self) -> &str {
        &self.entity
    }

    // string trade_id = 2;

    pub fn clear_trade_id(&mut self) {
        self.trade_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_id(&mut self, v: ::std::string::String) {
        self.trade_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_id(&mut self) -> &mut ::std::string::String {
        &mut self.trade_id
    }

    // Take field
    pub fn take_trade_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_id, ::std::string::String::new())
    }

    pub fn get_trade_id(&self) -> &str {
        &self.trade_id
    }

    // string contract_typology = 3;

    pub fn clear_contract_typology(&mut self) {
        self.contract_typology.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_typology(&mut self, v: ::std::string::String) {
        self.contract_typology = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_typology(&mut self) -> &mut ::std::string::String {
        &mut self.contract_typology
    }

    // Take field
    pub fn take_contract_typology(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_typology, ::std::string::String::new())
    }

    pub fn get_contract_typology(&self) -> &str {
        &self.contract_typology
    }

    // string trade_typology = 4;

    pub fn clear_trade_typology(&mut self) {
        self.trade_typology.clear();
    }

    // Param is passed by value, moved
    pub fn set_trade_typology(&mut self, v: ::std::string::String) {
        self.trade_typology = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trade_typology(&mut self) -> &mut ::std::string::String {
        &mut self.trade_typology
    }

    // Take field
    pub fn take_trade_typology(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trade_typology, ::std::string::String::new())
    }

    pub fn get_trade_typology(&self) -> &str {
        &self.trade_typology
    }

    // string usage = 5;

    pub fn clear_usage(&mut self) {
        self.usage.clear();
    }

    // Param is passed by value, moved
    pub fn set_usage(&mut self, v: ::std::string::String) {
        self.usage = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_usage(&mut self) -> &mut ::std::string::String {
        &mut self.usage
    }

    // Take field
    pub fn take_usage(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.usage, ::std::string::String::new())
    }

    pub fn get_usage(&self) -> &str {
        &self.usage
    }

    // string desk = 6;

    pub fn clear_desk(&mut self) {
        self.desk.clear();
    }

    // Param is passed by value, moved
    pub fn set_desk(&mut self, v: ::std::string::String) {
        self.desk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desk(&mut self) -> &mut ::std::string::String {
        &mut self.desk
    }

    // Take field
    pub fn take_desk(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desk, ::std::string::String::new())
    }

    pub fn get_desk(&self) -> &str {
        &self.desk
    }

    // string book = 7;

    pub fn clear_book(&mut self) {
        self.book.clear();
    }

    // Param is passed by value, moved
    pub fn set_book(&mut self, v: ::std::string::String) {
        self.book = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_book(&mut self) -> &mut ::std::string::String {
        &mut self.book
    }

    // Take field
    pub fn take_book(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.book, ::std::string::String::new())
    }

    pub fn get_book(&self) -> &str {
        &self.book
    }

    // string folder = 8;

    pub fn clear_folder(&mut self) {
        self.folder.clear();
    }

    // Param is passed by value, moved
    pub fn set_folder(&mut self, v: ::std::string::String) {
        self.folder = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_folder(&mut self) -> &mut ::std::string::String {
        &mut self.folder
    }

    // Take field
    pub fn take_folder(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.folder, ::std::string::String::new())
    }

    pub fn get_folder(&self) -> &str {
        &self.folder
    }

    // string trading_banking = 9;

    pub fn clear_trading_banking(&mut self) {
        self.trading_banking.clear();
    }

    // Param is passed by value, moved
    pub fn set_trading_banking(&mut self, v: ::std::string::String) {
        self.trading_banking = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trading_banking(&mut self) -> &mut ::std::string::String {
        &mut self.trading_banking
    }

    // Take field
    pub fn take_trading_banking(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trading_banking, ::std::string::String::new())
    }

    pub fn get_trading_banking(&self) -> &str {
        &self.trading_banking
    }

    // string internal_external = 10;

    pub fn clear_internal_external(&mut self) {
        self.internal_external.clear();
    }

    // Param is passed by value, moved
    pub fn set_internal_external(&mut self, v: ::std::string::String) {
        self.internal_external = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_internal_external(&mut self) -> &mut ::std::string::String {
        &mut self.internal_external
    }

    // Take field
    pub fn take_internal_external(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.internal_external, ::std::string::String::new())
    }

    pub fn get_internal_external(&self) -> &str {
        &self.internal_external
    }

    // string inter_entity = 11;

    pub fn clear_inter_entity(&mut self) {
        self.inter_entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_inter_entity(&mut self, v: ::std::string::String) {
        self.inter_entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inter_entity(&mut self) -> &mut ::std::string::String {
        &mut self.inter_entity
    }

    // Take field
    pub fn take_inter_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.inter_entity, ::std::string::String::new())
    }

    pub fn get_inter_entity(&self) -> &str {
        &self.inter_entity
    }

    // string counterparty_long_name = 12;

    pub fn clear_counterparty_long_name(&mut self) {
        self.counterparty_long_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_counterparty_long_name(&mut self, v: ::std::string::String) {
        self.counterparty_long_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counterparty_long_name(&mut self) -> &mut ::std::string::String {
        &mut self.counterparty_long_name
    }

    // Take field
    pub fn take_counterparty_long_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.counterparty_long_name,
            ::std::string::String::new(),
        )
    }

    pub fn get_counterparty_long_name(&self) -> &str {
        &self.counterparty_long_name
    }

    // string cp_category_level_1 = 13;

    pub fn clear_cp_category_level_1(&mut self) {
        self.cp_category_level_1.clear();
    }

    // Param is passed by value, moved
    pub fn set_cp_category_level_1(&mut self, v: ::std::string::String) {
        self.cp_category_level_1 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cp_category_level_1(&mut self) -> &mut ::std::string::String {
        &mut self.cp_category_level_1
    }

    // Take field
    pub fn take_cp_category_level_1(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cp_category_level_1, ::std::string::String::new())
    }

    pub fn get_cp_category_level_1(&self) -> &str {
        &self.cp_category_level_1
    }

    // string cp_category_level_2 = 14;

    pub fn clear_cp_category_level_2(&mut self) {
        self.cp_category_level_2.clear();
    }

    // Param is passed by value, moved
    pub fn set_cp_category_level_2(&mut self, v: ::std::string::String) {
        self.cp_category_level_2 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cp_category_level_2(&mut self) -> &mut ::std::string::String {
        &mut self.cp_category_level_2
    }

    // Take field
    pub fn take_cp_category_level_2(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cp_category_level_2, ::std::string::String::new())
    }

    pub fn get_cp_category_level_2(&self) -> &str {
        &self.cp_category_level_2
    }

    // string cp_category_level_3 = 15;

    pub fn clear_cp_category_level_3(&mut self) {
        self.cp_category_level_3.clear();
    }

    // Param is passed by value, moved
    pub fn set_cp_category_level_3(&mut self, v: ::std::string::String) {
        self.cp_category_level_3 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cp_category_level_3(&mut self) -> &mut ::std::string::String {
        &mut self.cp_category_level_3
    }

    // Take field
    pub fn take_cp_category_level_3(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cp_category_level_3, ::std::string::String::new())
    }

    pub fn get_cp_category_level_3(&self) -> &str {
        &self.cp_category_level_3
    }

    // string near_leg_far_leg = 16;

    pub fn clear_near_leg_far_leg(&mut self) {
        self.near_leg_far_leg.clear();
    }

    // Param is passed by value, moved
    pub fn set_near_leg_far_leg(&mut self, v: ::std::string::String) {
        self.near_leg_far_leg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_near_leg_far_leg(&mut self) -> &mut ::std::string::String {
        &mut self.near_leg_far_leg
    }

    // Take field
    pub fn take_near_leg_far_leg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.near_leg_far_leg, ::std::string::String::new())
    }

    pub fn get_near_leg_far_leg(&self) -> &str {
        &self.near_leg_far_leg
    }

    // int64 option_start_date = 17;

    pub fn clear_option_start_date(&mut self) {
        self.option_start_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_option_start_date(&mut self, v: i64) {
        self.option_start_date = v;
    }

    pub fn get_option_start_date(&self) -> i64 {
        self.option_start_date
    }

    // int64 option_end_date = 18;

    pub fn clear_option_end_date(&mut self) {
        self.option_end_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_option_end_date(&mut self, v: i64) {
        self.option_end_date = v;
    }

    pub fn get_option_end_date(&self) -> i64 {
        self.option_end_date
    }

    // int64 effective_date = 19;

    pub fn clear_effective_date(&mut self) {
        self.effective_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_effective_date(&mut self, v: i64) {
        self.effective_date = v;
    }

    pub fn get_effective_date(&self) -> i64 {
        self.effective_date
    }

    // int64 mat_date_of_contract = 20;

    pub fn clear_mat_date_of_contract(&mut self) {
        self.mat_date_of_contract = 0;
    }

    // Param is passed by value, moved
    pub fn set_mat_date_of_contract(&mut self, v: i64) {
        self.mat_date_of_contract = v;
    }

    pub fn get_mat_date_of_contract(&self) -> i64 {
        self.mat_date_of_contract
    }

    // string ccil_guranteed = 21;

    pub fn clear_ccil_guranteed(&mut self) {
        self.ccil_guranteed.clear();
    }

    // Param is passed by value, moved
    pub fn set_ccil_guranteed(&mut self, v: ::std::string::String) {
        self.ccil_guranteed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ccil_guranteed(&mut self) -> &mut ::std::string::String {
        &mut self.ccil_guranteed
    }

    // Take field
    pub fn take_ccil_guranteed(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ccil_guranteed, ::std::string::String::new())
    }

    pub fn get_ccil_guranteed(&self) -> &str {
        &self.ccil_guranteed
    }

    // string buy_currency = 22;

    pub fn clear_buy_currency(&mut self) {
        self.buy_currency.clear();
    }

    // Param is passed by value, moved
    pub fn set_buy_currency(&mut self, v: ::std::string::String) {
        self.buy_currency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_buy_currency(&mut self) -> &mut ::std::string::String {
        &mut self.buy_currency
    }

    // Take field
    pub fn take_buy_currency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.buy_currency, ::std::string::String::new())
    }

    pub fn get_buy_currency(&self) -> &str {
        &self.buy_currency
    }

    // double buy_current_notional = 23;

    pub fn clear_buy_current_notional(&mut self) {
        self.buy_current_notional = 0.;
    }

    // Param is passed by value, moved
    pub fn set_buy_current_notional(&mut self, v: f64) {
        self.buy_current_notional = v;
    }

    pub fn get_buy_current_notional(&self) -> f64 {
        self.buy_current_notional
    }

    // string sell_currency = 24;

    pub fn clear_sell_currency(&mut self) {
        self.sell_currency.clear();
    }

    // Param is passed by value, moved
    pub fn set_sell_currency(&mut self, v: ::std::string::String) {
        self.sell_currency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sell_currency(&mut self) -> &mut ::std::string::String {
        &mut self.sell_currency
    }

    // Take field
    pub fn take_sell_currency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sell_currency, ::std::string::String::new())
    }

    pub fn get_sell_currency(&self) -> &str {
        &self.sell_currency
    }

    // double sell_current_notional = 25;

    pub fn clear_sell_current_notional(&mut self) {
        self.sell_current_notional = 0.;
    }

    // Param is passed by value, moved
    pub fn set_sell_current_notional(&mut self, v: f64) {
        self.sell_current_notional = v;
    }

    pub fn get_sell_current_notional(&self) -> f64 {
        self.sell_current_notional
    }

    // double forward_rate = 26;

    pub fn clear_forward_rate(&mut self) {
        self.forward_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_forward_rate(&mut self, v: f64) {
        self.forward_rate = v;
    }

    pub fn get_forward_rate(&self) -> f64 {
        self.forward_rate
    }

    // double forward_mtm = 27;

    pub fn clear_forward_mtm(&mut self) {
        self.forward_mtm = 0.;
    }

    // Param is passed by value, moved
    pub fn set_forward_mtm(&mut self, v: f64) {
        self.forward_mtm = v;
    }

    pub fn get_forward_mtm(&self) -> f64 {
        self.forward_mtm
    }

    // double mtm_in_inr_forward = 28;

    pub fn clear_mtm_in_inr_forward(&mut self) {
        self.mtm_in_inr_forward = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mtm_in_inr_forward(&mut self, v: f64) {
        self.mtm_in_inr_forward = v;
    }

    pub fn get_mtm_in_inr_forward(&self) -> f64 {
        self.mtm_in_inr_forward
    }

    // double mtm_in_usd_forward = 29;

    pub fn clear_mtm_in_usd_forward(&mut self) {
        self.mtm_in_usd_forward = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mtm_in_usd_forward(&mut self, v: f64) {
        self.mtm_in_usd_forward = v;
    }

    pub fn get_mtm_in_usd_forward(&self) -> f64 {
        self.mtm_in_usd_forward
    }

    // double pv_mtm_in_inr = 30;

    pub fn clear_pv_mtm_in_inr(&mut self) {
        self.pv_mtm_in_inr = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pv_mtm_in_inr(&mut self, v: f64) {
        self.pv_mtm_in_inr = v;
    }

    pub fn get_pv_mtm_in_inr(&self) -> f64 {
        self.pv_mtm_in_inr
    }

    // double pv_mtm_in_usd = 31;

    pub fn clear_pv_mtm_in_usd(&mut self) {
        self.pv_mtm_in_usd = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pv_mtm_in_usd(&mut self, v: f64) {
        self.pv_mtm_in_usd = v;
    }

    pub fn get_pv_mtm_in_usd(&self) -> f64 {
        self.pv_mtm_in_usd
    }

    // double pv01_in_inr = 32;

    pub fn clear_pv01_in_inr(&mut self) {
        self.pv01_in_inr = 0.;
    }

    // Param is passed by value, moved
    pub fn set_pv01_in_inr(&mut self, v: f64) {
        self.pv01_in_inr = v;
    }

    pub fn get_pv01_in_inr(&self) -> f64 {
        self.pv01_in_inr
    }

    // double mduriation_ccy1_inr = 33;

    pub fn clear_mduriation_ccy1_inr(&mut self) {
        self.mduriation_ccy1_inr = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mduriation_ccy1_inr(&mut self, v: f64) {
        self.mduriation_ccy1_inr = v;
    }

    pub fn get_mduriation_ccy1_inr(&self) -> f64 {
        self.mduriation_ccy1_inr
    }

    // double mduriation_ccy2_inr = 34;

    pub fn clear_mduriation_ccy2_inr(&mut self) {
        self.mduriation_ccy2_inr = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mduriation_ccy2_inr(&mut self, v: f64) {
        self.mduriation_ccy2_inr = v;
    }

    pub fn get_mduriation_ccy2_inr(&self) -> f64 {
        self.mduriation_ccy2_inr
    }

    // double contingent_notional_in_inr = 35;

    pub fn clear_contingent_notional_in_inr(&mut self) {
        self.contingent_notional_in_inr = 0.;
    }

    // Param is passed by value, moved
    pub fn set_contingent_notional_in_inr(&mut self, v: f64) {
        self.contingent_notional_in_inr = v;
    }

    pub fn get_contingent_notional_in_inr(&self) -> f64 {
        self.contingent_notional_in_inr
    }

    // string npa = 36;

    pub fn clear_npa(&mut self) {
        self.npa.clear();
    }

    // Param is passed by value, moved
    pub fn set_npa(&mut self, v: ::std::string::String) {
        self.npa = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npa(&mut self) -> &mut ::std::string::String {
        &mut self.npa
    }

    // Take field
    pub fn take_npa(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.npa, ::std::string::String::new())
    }

    pub fn get_npa(&self) -> &str {
        &self.npa
    }

    // string bank_nonbank = 37;

    pub fn clear_bank_nonbank(&mut self) {
        self.bank_nonbank.clear();
    }

    // Param is passed by value, moved
    pub fn set_bank_nonbank(&mut self, v: ::std::string::String) {
        self.bank_nonbank = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bank_nonbank(&mut self) -> &mut ::std::string::String {
        &mut self.bank_nonbank
    }

    // Take field
    pub fn take_bank_nonbank(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bank_nonbank, ::std::string::String::new())
    }

    pub fn get_bank_nonbank(&self) -> &str {
        &self.bank_nonbank
    }

    // int64 original_tenor = 38;

    pub fn clear_original_tenor(&mut self) {
        self.original_tenor = 0;
    }

    // Param is passed by value, moved
    pub fn set_original_tenor(&mut self, v: i64) {
        self.original_tenor = v;
    }

    pub fn get_original_tenor(&self) -> i64 {
        self.original_tenor
    }

    // int64 residual_tenor = 39;

    pub fn clear_residual_tenor(&mut self) {
        self.residual_tenor = 0;
    }

    // Param is passed by value, moved
    pub fn set_residual_tenor(&mut self, v: i64) {
        self.residual_tenor = v;
    }

    pub fn get_residual_tenor(&self) -> i64 {
        self.residual_tenor
    }

    // string currency = 40;

    pub fn clear_currency(&mut self) {
        self.currency.clear();
    }

    // Param is passed by value, moved
    pub fn set_currency(&mut self, v: ::std::string::String) {
        self.currency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_currency(&mut self) -> &mut ::std::string::String {
        &mut self.currency
    }

    // Take field
    pub fn take_currency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.currency, ::std::string::String::new())
    }

    pub fn get_currency(&self) -> &str {
        &self.currency
    }

    // string cf_type = 41;

    pub fn clear_cf_type(&mut self) {
        self.cf_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf_type(&mut self, v: ::std::string::String) {
        self.cf_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf_type(&mut self) -> &mut ::std::string::String {
        &mut self.cf_type
    }

    // Take field
    pub fn take_cf_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf_type, ::std::string::String::new())
    }

    pub fn get_cf_type(&self) -> &str {
        &self.cf_type
    }

    // string cntry_resid = 42;

    pub fn clear_cntry_resid(&mut self) {
        self.cntry_resid.clear();
    }

    // Param is passed by value, moved
    pub fn set_cntry_resid(&mut self, v: ::std::string::String) {
        self.cntry_resid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cntry_resid(&mut self) -> &mut ::std::string::String {
        &mut self.cntry_resid
    }

    // Take field
    pub fn take_cntry_resid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cntry_resid, ::std::string::String::new())
    }

    pub fn get_cntry_resid(&self) -> &str {
        &self.cntry_resid
    }

    // string cntry_ultim_risk = 43;

    pub fn clear_cntry_ultim_risk(&mut self) {
        self.cntry_ultim_risk.clear();
    }

    // Param is passed by value, moved
    pub fn set_cntry_ultim_risk(&mut self, v: ::std::string::String) {
        self.cntry_ultim_risk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cntry_ultim_risk(&mut self) -> &mut ::std::string::String {
        &mut self.cntry_ultim_risk
    }

    // Take field
    pub fn take_cntry_ultim_risk(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cntry_ultim_risk, ::std::string::String::new())
    }

    pub fn get_cntry_ultim_risk(&self) -> &str {
        &self.cntry_ultim_risk
    }

    // double tot_int_amt = 44;

    pub fn clear_tot_int_amt(&mut self) {
        self.tot_int_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tot_int_amt(&mut self, v: f64) {
        self.tot_int_amt = v;
    }

    pub fn get_tot_int_amt(&self) -> f64 {
        self.tot_int_amt
    }

    // double tot_prin_amt = 45;

    pub fn clear_tot_prin_amt(&mut self) {
        self.tot_prin_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tot_prin_amt(&mut self, v: f64) {
        self.tot_prin_amt = v;
    }

    pub fn get_tot_prin_amt(&self) -> f64 {
        self.tot_prin_amt
    }

    // string counterparty_child_code = 46;

    pub fn clear_counterparty_child_code(&mut self) {
        self.counterparty_child_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_counterparty_child_code(&mut self, v: ::std::string::String) {
        self.counterparty_child_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_counterparty_child_code(&mut self) -> &mut ::std::string::String {
        &mut self.counterparty_child_code
    }

    // Take field
    pub fn take_counterparty_child_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.counterparty_child_code,
            ::std::string::String::new(),
        )
    }

    pub fn get_counterparty_child_code(&self) -> &str {
        &self.counterparty_child_code
    }

    // repeated .Cashflow cashflows = 47;

    pub fn clear_cashflows(&mut self) {
        self.cashflows.clear();
    }

    // Param is passed by value, moved
    pub fn set_cashflows(&mut self, v: ::protobuf::RepeatedField<Cashflow>) {
        self.cashflows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cashflows(&mut self) -> &mut ::protobuf::RepeatedField<Cashflow> {
        &mut self.cashflows
    }

    // Take field
    pub fn take_cashflows(&mut self) -> ::protobuf::RepeatedField<Cashflow> {
        ::std::mem::replace(&mut self.cashflows, ::protobuf::RepeatedField::new())
    }

    pub fn get_cashflows(&self) -> &[Cashflow] {
        &self.cashflows
    }
}

impl ::protobuf::Message for AccountWithCashflows {
    fn is_initialized(&self) -> bool {
        for v in &self.cashflows {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.entity,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_id,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.contract_typology,
                    )?;
                }
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trade_typology,
                    )?;
                }
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.usage,
                    )?;
                }
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.desk,
                    )?;
                }
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.book,
                    )?;
                }
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.folder,
                    )?;
                }
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trading_banking,
                    )?;
                }
                10 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.internal_external,
                    )?;
                }
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.inter_entity,
                    )?;
                }
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.counterparty_long_name,
                    )?;
                }
                13 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.cp_category_level_1,
                    )?;
                }
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.cp_category_level_2,
                    )?;
                }
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.cp_category_level_3,
                    )?;
                }
                16 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.near_leg_far_leg,
                    )?;
                }
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.option_start_date = tmp;
                }
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.option_end_date = tmp;
                }
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.effective_date = tmp;
                }
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.mat_date_of_contract = tmp;
                }
                21 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.ccil_guranteed,
                    )?;
                }
                22 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.buy_currency,
                    )?;
                }
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.buy_current_notional = tmp;
                }
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.sell_currency,
                    )?;
                }
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.sell_current_notional = tmp;
                }
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.forward_rate = tmp;
                }
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.forward_mtm = tmp;
                }
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.mtm_in_inr_forward = tmp;
                }
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.mtm_in_usd_forward = tmp;
                }
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.pv_mtm_in_inr = tmp;
                }
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.pv_mtm_in_usd = tmp;
                }
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.pv01_in_inr = tmp;
                }
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.mduriation_ccy1_inr = tmp;
                }
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.mduriation_ccy2_inr = tmp;
                }
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.contingent_notional_in_inr = tmp;
                }
                36 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.npa)?;
                }
                37 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.bank_nonbank,
                    )?;
                }
                38 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.original_tenor = tmp;
                }
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.residual_tenor = tmp;
                }
                40 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.currency,
                    )?;
                }
                41 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.cf_type,
                    )?;
                }
                42 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.cntry_resid,
                    )?;
                }
                43 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.cntry_ultim_risk,
                    )?;
                }
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.tot_int_amt = tmp;
                }
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.tot_prin_amt = tmp;
                }
                46 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.counterparty_child_code,
                    )?;
                }
                47 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cashflows)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity);
        }
        if !self.trade_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.trade_id);
        }
        if !self.contract_typology.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.contract_typology);
        }
        if !self.trade_typology.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.trade_typology);
        }
        if !self.usage.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.usage);
        }
        if !self.desk.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.desk);
        }
        if !self.book.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.book);
        }
        if !self.folder.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.folder);
        }
        if !self.trading_banking.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.trading_banking);
        }
        if !self.internal_external.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.internal_external);
        }
        if !self.inter_entity.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.inter_entity);
        }
        if !self.counterparty_long_name.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.counterparty_long_name);
        }
        if !self.cp_category_level_1.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.cp_category_level_1);
        }
        if !self.cp_category_level_2.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.cp_category_level_2);
        }
        if !self.cp_category_level_3.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.cp_category_level_3);
        }
        if !self.near_leg_far_leg.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.near_leg_far_leg);
        }
        if self.option_start_date != 0 {
            my_size += ::protobuf::rt::value_size(
                17,
                self.option_start_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.option_end_date != 0 {
            my_size += ::protobuf::rt::value_size(
                18,
                self.option_end_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.effective_date != 0 {
            my_size += ::protobuf::rt::value_size(
                19,
                self.effective_date,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.mat_date_of_contract != 0 {
            my_size += ::protobuf::rt::value_size(
                20,
                self.mat_date_of_contract,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.ccil_guranteed.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.ccil_guranteed);
        }
        if !self.buy_currency.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.buy_currency);
        }
        if self.buy_current_notional != 0. {
            my_size += 10;
        }
        if !self.sell_currency.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.sell_currency);
        }
        if self.sell_current_notional != 0. {
            my_size += 10;
        }
        if self.forward_rate != 0. {
            my_size += 10;
        }
        if self.forward_mtm != 0. {
            my_size += 10;
        }
        if self.mtm_in_inr_forward != 0. {
            my_size += 10;
        }
        if self.mtm_in_usd_forward != 0. {
            my_size += 10;
        }
        if self.pv_mtm_in_inr != 0. {
            my_size += 10;
        }
        if self.pv_mtm_in_usd != 0. {
            my_size += 10;
        }
        if self.pv01_in_inr != 0. {
            my_size += 10;
        }
        if self.mduriation_ccy1_inr != 0. {
            my_size += 10;
        }
        if self.mduriation_ccy2_inr != 0. {
            my_size += 10;
        }
        if self.contingent_notional_in_inr != 0. {
            my_size += 10;
        }
        if !self.npa.is_empty() {
            my_size += ::protobuf::rt::string_size(36, &self.npa);
        }
        if !self.bank_nonbank.is_empty() {
            my_size += ::protobuf::rt::string_size(37, &self.bank_nonbank);
        }
        if self.original_tenor != 0 {
            my_size += ::protobuf::rt::value_size(
                38,
                self.original_tenor,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.residual_tenor != 0 {
            my_size += ::protobuf::rt::value_size(
                39,
                self.residual_tenor,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.currency.is_empty() {
            my_size += ::protobuf::rt::string_size(40, &self.currency);
        }
        if !self.cf_type.is_empty() {
            my_size += ::protobuf::rt::string_size(41, &self.cf_type);
        }
        if !self.cntry_resid.is_empty() {
            my_size += ::protobuf::rt::string_size(42, &self.cntry_resid);
        }
        if !self.cntry_ultim_risk.is_empty() {
            my_size += ::protobuf::rt::string_size(43, &self.cntry_ultim_risk);
        }
        if self.tot_int_amt != 0. {
            my_size += 10;
        }
        if self.tot_prin_amt != 0. {
            my_size += 10;
        }
        if !self.counterparty_child_code.is_empty() {
            my_size += ::protobuf::rt::string_size(46, &self.counterparty_child_code);
        }
        for value in &self.cashflows {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.entity.is_empty() {
            os.write_string(1, &self.entity)?;
        }
        if !self.trade_id.is_empty() {
            os.write_string(2, &self.trade_id)?;
        }
        if !self.contract_typology.is_empty() {
            os.write_string(3, &self.contract_typology)?;
        }
        if !self.trade_typology.is_empty() {
            os.write_string(4, &self.trade_typology)?;
        }
        if !self.usage.is_empty() {
            os.write_string(5, &self.usage)?;
        }
        if !self.desk.is_empty() {
            os.write_string(6, &self.desk)?;
        }
        if !self.book.is_empty() {
            os.write_string(7, &self.book)?;
        }
        if !self.folder.is_empty() {
            os.write_string(8, &self.folder)?;
        }
        if !self.trading_banking.is_empty() {
            os.write_string(9, &self.trading_banking)?;
        }
        if !self.internal_external.is_empty() {
            os.write_string(10, &self.internal_external)?;
        }
        if !self.inter_entity.is_empty() {
            os.write_string(11, &self.inter_entity)?;
        }
        if !self.counterparty_long_name.is_empty() {
            os.write_string(12, &self.counterparty_long_name)?;
        }
        if !self.cp_category_level_1.is_empty() {
            os.write_string(13, &self.cp_category_level_1)?;
        }
        if !self.cp_category_level_2.is_empty() {
            os.write_string(14, &self.cp_category_level_2)?;
        }
        if !self.cp_category_level_3.is_empty() {
            os.write_string(15, &self.cp_category_level_3)?;
        }
        if !self.near_leg_far_leg.is_empty() {
            os.write_string(16, &self.near_leg_far_leg)?;
        }
        if self.option_start_date != 0 {
            os.write_int64(17, self.option_start_date)?;
        }
        if self.option_end_date != 0 {
            os.write_int64(18, self.option_end_date)?;
        }
        if self.effective_date != 0 {
            os.write_int64(19, self.effective_date)?;
        }
        if self.mat_date_of_contract != 0 {
            os.write_int64(20, self.mat_date_of_contract)?;
        }
        if !self.ccil_guranteed.is_empty() {
            os.write_string(21, &self.ccil_guranteed)?;
        }
        if !self.buy_currency.is_empty() {
            os.write_string(22, &self.buy_currency)?;
        }
        if self.buy_current_notional != 0. {
            os.write_double(23, self.buy_current_notional)?;
        }
        if !self.sell_currency.is_empty() {
            os.write_string(24, &self.sell_currency)?;
        }
        if self.sell_current_notional != 0. {
            os.write_double(25, self.sell_current_notional)?;
        }
        if self.forward_rate != 0. {
            os.write_double(26, self.forward_rate)?;
        }
        if self.forward_mtm != 0. {
            os.write_double(27, self.forward_mtm)?;
        }
        if self.mtm_in_inr_forward != 0. {
            os.write_double(28, self.mtm_in_inr_forward)?;
        }
        if self.mtm_in_usd_forward != 0. {
            os.write_double(29, self.mtm_in_usd_forward)?;
        }
        if self.pv_mtm_in_inr != 0. {
            os.write_double(30, self.pv_mtm_in_inr)?;
        }
        if self.pv_mtm_in_usd != 0. {
            os.write_double(31, self.pv_mtm_in_usd)?;
        }
        if self.pv01_in_inr != 0. {
            os.write_double(32, self.pv01_in_inr)?;
        }
        if self.mduriation_ccy1_inr != 0. {
            os.write_double(33, self.mduriation_ccy1_inr)?;
        }
        if self.mduriation_ccy2_inr != 0. {
            os.write_double(34, self.mduriation_ccy2_inr)?;
        }
        if self.contingent_notional_in_inr != 0. {
            os.write_double(35, self.contingent_notional_in_inr)?;
        }
        if !self.npa.is_empty() {
            os.write_string(36, &self.npa)?;
        }
        if !self.bank_nonbank.is_empty() {
            os.write_string(37, &self.bank_nonbank)?;
        }
        if self.original_tenor != 0 {
            os.write_int64(38, self.original_tenor)?;
        }
        if self.residual_tenor != 0 {
            os.write_int64(39, self.residual_tenor)?;
        }
        if !self.currency.is_empty() {
            os.write_string(40, &self.currency)?;
        }
        if !self.cf_type.is_empty() {
            os.write_string(41, &self.cf_type)?;
        }
        if !self.cntry_resid.is_empty() {
            os.write_string(42, &self.cntry_resid)?;
        }
        if !self.cntry_ultim_risk.is_empty() {
            os.write_string(43, &self.cntry_ultim_risk)?;
        }
        if self.tot_int_amt != 0. {
            os.write_double(44, self.tot_int_amt)?;
        }
        if self.tot_prin_amt != 0. {
            os.write_double(45, self.tot_prin_amt)?;
        }
        if !self.counterparty_child_code.is_empty() {
            os.write_string(46, &self.counterparty_child_code)?;
        }
        for v in &self.cashflows {
            os.write_tag(47, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountWithCashflows {
        AccountWithCashflows::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "entity",
                    |m: &AccountWithCashflows| &m.entity,
                    |m: &mut AccountWithCashflows| &mut m.entity,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_id",
                    |m: &AccountWithCashflows| &m.trade_id,
                    |m: &mut AccountWithCashflows| &mut m.trade_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "contract_typology",
                    |m: &AccountWithCashflows| &m.contract_typology,
                    |m: &mut AccountWithCashflows| &mut m.contract_typology,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trade_typology",
                    |m: &AccountWithCashflows| &m.trade_typology,
                    |m: &mut AccountWithCashflows| &mut m.trade_typology,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "usage",
                    |m: &AccountWithCashflows| &m.usage,
                    |m: &mut AccountWithCashflows| &mut m.usage,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "desk",
                    |m: &AccountWithCashflows| &m.desk,
                    |m: &mut AccountWithCashflows| &mut m.desk,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "book",
                    |m: &AccountWithCashflows| &m.book,
                    |m: &mut AccountWithCashflows| &mut m.book,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "folder",
                    |m: &AccountWithCashflows| &m.folder,
                    |m: &mut AccountWithCashflows| &mut m.folder,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trading_banking",
                    |m: &AccountWithCashflows| &m.trading_banking,
                    |m: &mut AccountWithCashflows| &mut m.trading_banking,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "internal_external",
                    |m: &AccountWithCashflows| &m.internal_external,
                    |m: &mut AccountWithCashflows| &mut m.internal_external,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "inter_entity",
                    |m: &AccountWithCashflows| &m.inter_entity,
                    |m: &mut AccountWithCashflows| &mut m.inter_entity,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "counterparty_long_name",
                    |m: &AccountWithCashflows| &m.counterparty_long_name,
                    |m: &mut AccountWithCashflows| &mut m.counterparty_long_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cp_category_level_1",
                    |m: &AccountWithCashflows| &m.cp_category_level_1,
                    |m: &mut AccountWithCashflows| &mut m.cp_category_level_1,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cp_category_level_2",
                    |m: &AccountWithCashflows| &m.cp_category_level_2,
                    |m: &mut AccountWithCashflows| &mut m.cp_category_level_2,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cp_category_level_3",
                    |m: &AccountWithCashflows| &m.cp_category_level_3,
                    |m: &mut AccountWithCashflows| &mut m.cp_category_level_3,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "near_leg_far_leg",
                    |m: &AccountWithCashflows| &m.near_leg_far_leg,
                    |m: &mut AccountWithCashflows| &mut m.near_leg_far_leg,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "option_start_date",
                    |m: &AccountWithCashflows| &m.option_start_date,
                    |m: &mut AccountWithCashflows| &mut m.option_start_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "option_end_date",
                    |m: &AccountWithCashflows| &m.option_end_date,
                    |m: &mut AccountWithCashflows| &mut m.option_end_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "effective_date",
                    |m: &AccountWithCashflows| &m.effective_date,
                    |m: &mut AccountWithCashflows| &mut m.effective_date,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "mat_date_of_contract",
                    |m: &AccountWithCashflows| &m.mat_date_of_contract,
                    |m: &mut AccountWithCashflows| &mut m.mat_date_of_contract,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "ccil_guranteed",
                    |m: &AccountWithCashflows| &m.ccil_guranteed,
                    |m: &mut AccountWithCashflows| &mut m.ccil_guranteed,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "buy_currency",
                    |m: &AccountWithCashflows| &m.buy_currency,
                    |m: &mut AccountWithCashflows| &mut m.buy_currency,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "buy_current_notional",
                    |m: &AccountWithCashflows| &m.buy_current_notional,
                    |m: &mut AccountWithCashflows| &mut m.buy_current_notional,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "sell_currency",
                    |m: &AccountWithCashflows| &m.sell_currency,
                    |m: &mut AccountWithCashflows| &mut m.sell_currency,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "sell_current_notional",
                    |m: &AccountWithCashflows| &m.sell_current_notional,
                    |m: &mut AccountWithCashflows| &mut m.sell_current_notional,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "forward_rate",
                    |m: &AccountWithCashflows| &m.forward_rate,
                    |m: &mut AccountWithCashflows| &mut m.forward_rate,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "forward_mtm",
                    |m: &AccountWithCashflows| &m.forward_mtm,
                    |m: &mut AccountWithCashflows| &mut m.forward_mtm,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "mtm_in_inr_forward",
                    |m: &AccountWithCashflows| &m.mtm_in_inr_forward,
                    |m: &mut AccountWithCashflows| &mut m.mtm_in_inr_forward,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "mtm_in_usd_forward",
                    |m: &AccountWithCashflows| &m.mtm_in_usd_forward,
                    |m: &mut AccountWithCashflows| &mut m.mtm_in_usd_forward,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "pv_mtm_in_inr",
                    |m: &AccountWithCashflows| &m.pv_mtm_in_inr,
                    |m: &mut AccountWithCashflows| &mut m.pv_mtm_in_inr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "pv_mtm_in_usd",
                    |m: &AccountWithCashflows| &m.pv_mtm_in_usd,
                    |m: &mut AccountWithCashflows| &mut m.pv_mtm_in_usd,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "pv01_in_inr",
                    |m: &AccountWithCashflows| &m.pv01_in_inr,
                    |m: &mut AccountWithCashflows| &mut m.pv01_in_inr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "mduriation_ccy1_inr",
                    |m: &AccountWithCashflows| &m.mduriation_ccy1_inr,
                    |m: &mut AccountWithCashflows| &mut m.mduriation_ccy1_inr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "mduriation_ccy2_inr",
                    |m: &AccountWithCashflows| &m.mduriation_ccy2_inr,
                    |m: &mut AccountWithCashflows| &mut m.mduriation_ccy2_inr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "contingent_notional_in_inr",
                    |m: &AccountWithCashflows| &m.contingent_notional_in_inr,
                    |m: &mut AccountWithCashflows| &mut m.contingent_notional_in_inr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "npa",
                    |m: &AccountWithCashflows| &m.npa,
                    |m: &mut AccountWithCashflows| &mut m.npa,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "bank_nonbank",
                    |m: &AccountWithCashflows| &m.bank_nonbank,
                    |m: &mut AccountWithCashflows| &mut m.bank_nonbank,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "original_tenor",
                    |m: &AccountWithCashflows| &m.original_tenor,
                    |m: &mut AccountWithCashflows| &mut m.original_tenor,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "residual_tenor",
                    |m: &AccountWithCashflows| &m.residual_tenor,
                    |m: &mut AccountWithCashflows| &mut m.residual_tenor,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "currency",
                    |m: &AccountWithCashflows| &m.currency,
                    |m: &mut AccountWithCashflows| &mut m.currency,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cf_type",
                    |m: &AccountWithCashflows| &m.cf_type,
                    |m: &mut AccountWithCashflows| &mut m.cf_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cntry_resid",
                    |m: &AccountWithCashflows| &m.cntry_resid,
                    |m: &mut AccountWithCashflows| &mut m.cntry_resid,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cntry_ultim_risk",
                    |m: &AccountWithCashflows| &m.cntry_ultim_risk,
                    |m: &mut AccountWithCashflows| &mut m.cntry_ultim_risk,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "tot_int_amt",
                    |m: &AccountWithCashflows| &m.tot_int_amt,
                    |m: &mut AccountWithCashflows| &mut m.tot_int_amt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "tot_prin_amt",
                    |m: &AccountWithCashflows| &m.tot_prin_amt,
                    |m: &mut AccountWithCashflows| &mut m.tot_prin_amt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "counterparty_child_code",
                    |m: &AccountWithCashflows| &m.counterparty_child_code,
                    |m: &mut AccountWithCashflows| &mut m.counterparty_child_code,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Cashflow>,
                    >(
                        "cashflows",
                        |m: &AccountWithCashflows| &m.cashflows,
                        |m: &mut AccountWithCashflows| &mut m.cashflows,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<AccountWithCashflows>(
                    "AccountWithCashflows",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static AccountWithCashflows {
        static mut instance: ::protobuf::lazy::Lazy<AccountWithCashflows> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const AccountWithCashflows,
            };
        unsafe { instance.get(AccountWithCashflows::new) }
    }
}

impl ::protobuf::Clear for AccountWithCashflows {
    fn clear(&mut self) {
        self.clear_entity();
        self.clear_trade_id();
        self.clear_contract_typology();
        self.clear_trade_typology();
        self.clear_usage();
        self.clear_desk();
        self.clear_book();
        self.clear_folder();
        self.clear_trading_banking();
        self.clear_internal_external();
        self.clear_inter_entity();
        self.clear_counterparty_long_name();
        self.clear_cp_category_level_1();
        self.clear_cp_category_level_2();
        self.clear_cp_category_level_3();
        self.clear_near_leg_far_leg();
        self.clear_option_start_date();
        self.clear_option_end_date();
        self.clear_effective_date();
        self.clear_mat_date_of_contract();
        self.clear_ccil_guranteed();
        self.clear_buy_currency();
        self.clear_buy_current_notional();
        self.clear_sell_currency();
        self.clear_sell_current_notional();
        self.clear_forward_rate();
        self.clear_forward_mtm();
        self.clear_mtm_in_inr_forward();
        self.clear_mtm_in_usd_forward();
        self.clear_pv_mtm_in_inr();
        self.clear_pv_mtm_in_usd();
        self.clear_pv01_in_inr();
        self.clear_mduriation_ccy1_inr();
        self.clear_mduriation_ccy2_inr();
        self.clear_contingent_notional_in_inr();
        self.clear_npa();
        self.clear_bank_nonbank();
        self.clear_original_tenor();
        self.clear_residual_tenor();
        self.clear_currency();
        self.clear_cf_type();
        self.clear_cntry_resid();
        self.clear_cntry_ultim_risk();
        self.clear_tot_int_amt();
        self.clear_tot_prin_amt();
        self.clear_counterparty_child_code();
        self.clear_cashflows();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountWithCashflows {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountWithCashflows {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rmessage.proto\"R\n\x08Cashflow\x12\x17\n\x07int_amt\x18\x01\x20\x01(\
    \x01R\x06intAmt\x12\x19\n\x08prin_amt\x18\x02\x20\x01(\x01R\x07prinAmt\
    \x12\x12\n\x04date\x18\x03\x20\x01(\x03R\x04date\"\xa0\x0e\n\x14AccountW\
    ithCashflows\x12\x16\n\x06entity\x18\x01\x20\x01(\tR\x06entity\x12\x19\n\
    \x08trade_id\x18\x02\x20\x01(\tR\x07tradeId\x12+\n\x11contract_typology\
    \x18\x03\x20\x01(\tR\x10contractTypology\x12%\n\x0etrade_typology\x18\
    \x04\x20\x01(\tR\rtradeTypology\x12\x14\n\x05usage\x18\x05\x20\x01(\tR\
    \x05usage\x12\x12\n\x04desk\x18\x06\x20\x01(\tR\x04desk\x12\x12\n\x04boo\
    k\x18\x07\x20\x01(\tR\x04book\x12\x16\n\x06folder\x18\x08\x20\x01(\tR\
    \x06folder\x12'\n\x0ftrading_banking\x18\t\x20\x01(\tR\x0etradingBanking\
    \x12+\n\x11internal_external\x18\n\x20\x01(\tR\x10internalExternal\x12!\
    \n\x0cinter_entity\x18\x0b\x20\x01(\tR\x0binterEntity\x124\n\x16counterp\
    arty_long_name\x18\x0c\x20\x01(\tR\x14counterpartyLongName\x12-\n\x13cp_\
    category_level_1\x18\r\x20\x01(\tR\x10cpCategoryLevel1\x12-\n\x13cp_cate\
    gory_level_2\x18\x0e\x20\x01(\tR\x10cpCategoryLevel2\x12-\n\x13cp_catego\
    ry_level_3\x18\x0f\x20\x01(\tR\x10cpCategoryLevel3\x12'\n\x10near_leg_fa\
    r_leg\x18\x10\x20\x01(\tR\rnearLegFarLeg\x12*\n\x11option_start_date\x18\
    \x11\x20\x01(\x03R\x0foptionStartDate\x12&\n\x0foption_end_date\x18\x12\
    \x20\x01(\x03R\roptionEndDate\x12%\n\x0eeffective_date\x18\x13\x20\x01(\
    \x03R\reffectiveDate\x12/\n\x14mat_date_of_contract\x18\x14\x20\x01(\x03\
    R\x11matDateOfContract\x12%\n\x0eccil_guranteed\x18\x15\x20\x01(\tR\rcci\
    lGuranteed\x12!\n\x0cbuy_currency\x18\x16\x20\x01(\tR\x0bbuyCurrency\x12\
    0\n\x14buy_current_notional\x18\x17\x20\x01(\x01R\x12buyCurrentNotional\
    \x12#\n\rsell_currency\x18\x18\x20\x01(\tR\x0csellCurrency\x122\n\x15sel\
    l_current_notional\x18\x19\x20\x01(\x01R\x13sellCurrentNotional\x12!\n\
    \x0cforward_rate\x18\x1a\x20\x01(\x01R\x0bforwardRate\x12\x1f\n\x0bforwa\
    rd_mtm\x18\x1b\x20\x01(\x01R\nforwardMtm\x12+\n\x12mtm_in_inr_forward\
    \x18\x1c\x20\x01(\x01R\x0fmtmInInrForward\x12+\n\x12mtm_in_usd_forward\
    \x18\x1d\x20\x01(\x01R\x0fmtmInUsdForward\x12!\n\rpv_mtm_in_inr\x18\x1e\
    \x20\x01(\x01R\npvMtmInInr\x12!\n\rpv_mtm_in_usd\x18\x1f\x20\x01(\x01R\n\
    pvMtmInUsd\x12\x1e\n\x0bpv01_in_inr\x18\x20\x20\x01(\x01R\tpv01InInr\x12\
    .\n\x13mduriation_ccy1_inr\x18!\x20\x01(\x01R\x11mduriationCcy1Inr\x12.\
    \n\x13mduriation_ccy2_inr\x18\"\x20\x01(\x01R\x11mduriationCcy2Inr\x12;\
    \n\x1acontingent_notional_in_inr\x18#\x20\x01(\x01R\x17contingentNotiona\
    lInInr\x12\x10\n\x03npa\x18$\x20\x01(\tR\x03npa\x12!\n\x0cbank_nonbank\
    \x18%\x20\x01(\tR\x0bbankNonbank\x12%\n\x0eoriginal_tenor\x18&\x20\x01(\
    \x03R\roriginalTenor\x12%\n\x0eresidual_tenor\x18'\x20\x01(\x03R\rresidu\
    alTenor\x12\x1a\n\x08currency\x18(\x20\x01(\tR\x08currency\x12\x17\n\x07\
    cf_type\x18)\x20\x01(\tR\x06cfType\x12\x1f\n\x0bcntry_resid\x18*\x20\x01\
    (\tR\ncntryResid\x12(\n\x10cntry_ultim_risk\x18+\x20\x01(\tR\x0ecntryUlt\
    imRisk\x12\x1e\n\x0btot_int_amt\x18,\x20\x01(\x01R\ttotIntAmt\x12\x20\n\
    \x0ctot_prin_amt\x18-\x20\x01(\x01R\ntotPrinAmt\x126\n\x17counterparty_c\
    hild_code\x18.\x20\x01(\tR\x15counterpartyChildCode\x12'\n\tcashflows\
    \x18/\x20\x03(\x0b2\t.CashflowR\tcashflowsb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<
    ::protobuf::descriptor::FileDescriptorProto,
> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe { file_descriptor_proto_lazy.get(|| parse_descriptor_proto()) }
}
