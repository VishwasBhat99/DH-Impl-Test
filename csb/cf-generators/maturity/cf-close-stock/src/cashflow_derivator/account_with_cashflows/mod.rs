// This file is generated by rust-protobuf 2.4.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq, Clone, Default)]
pub struct Cashflow {
    // message fields
    pub int_amt: f64,
    pub prin_amt: f64,
    pub date: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Cashflow {
    pub fn new() -> Cashflow {
        ::std::default::Default::default()
    }

    // double int_amt = 1;

    pub fn clear_int_amt(&mut self) {
        self.int_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_int_amt(&mut self, v: f64) {
        self.int_amt = v;
    }

    pub fn get_int_amt(&self) -> f64 {
        self.int_amt
    }

    // double prin_amt = 2;

    pub fn clear_prin_amt(&mut self) {
        self.prin_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_prin_amt(&mut self, v: f64) {
        self.prin_amt = v;
    }

    pub fn get_prin_amt(&self) -> f64 {
        self.prin_amt
    }

    // int64 date = 3;

    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }

    pub fn get_date(&self) -> i64 {
        self.date
    }
}

impl ::protobuf::Message for Cashflow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.int_amt = tmp;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.prin_amt = tmp;
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.int_amt != 0. {
            my_size += 9;
        }
        if self.prin_amt != 0. {
            my_size += 9;
        }
        if self.date != 0 {
            my_size +=
                ::protobuf::rt::value_size(3, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream,
    ) -> ::protobuf::ProtobufResult<()> {
        if self.int_amt != 0. {
            os.write_double(1, self.int_amt)?;
        }
        if self.prin_amt != 0. {
            os.write_double(2, self.prin_amt)?;
        }
        if self.date != 0 {
            os.write_int64(3, self.date)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cashflow {
        Cashflow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "int_amt",
                    |m: &Cashflow| &m.int_amt,
                    |m: &mut Cashflow| &mut m.int_amt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "prin_amt",
                    |m: &Cashflow| &m.prin_amt,
                    |m: &mut Cashflow| &mut m.prin_amt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "date",
                    |m: &Cashflow| &m.date,
                    |m: &mut Cashflow| &mut m.date,
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Cashflow>(
                    "Cashflow",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static Cashflow {
        static mut instance: ::protobuf::lazy::Lazy<Cashflow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Cashflow,
        };
        unsafe { instance.get(Cashflow::new) }
    }
}

impl ::protobuf::Clear for Cashflow {
    fn clear(&mut self) {
        self.clear_int_amt();
        self.clear_prin_amt();
        self.clear_date();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cashflow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cashflow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
pub struct AccountWithCashflows {
    // message fields
    pub portfolio_num: ::std::string::String,
    pub portfolio: ::std::string::String,
    pub security_name: ::std::string::String,
    pub maturity_dt: i64,
    pub coupon: f64,
    pub face_val_per_units: f64,
    pub quantity: f64,
    pub face_val: f64,
    pub wap: f64,
    pub book_val: f64,
    pub market_val: f64,
    pub mtm: f64,
    pub yeild: f64,
    pub appreciation: f64,
    pub depreciation: f64,
    pub net_appreciation_depreciation: f64,
    pub amort_as_on_dt: f64,
    pub accounted_amort: f64,
    pub un_accounted_amort: f64,
    pub accrued_int: f64,
    pub no_ca_skipped: f64,
    pub ca_int_not_receieved: f64,
    pub total_int: f64,
    pub inst_id: ::std::string::String,
    pub inst_typ: ::std::string::String,
    pub isin_code: ::std::string::String,
    pub int_freq: ::std::string::String,
    pub int_practice: ::std::string::String,
    pub category: ::std::string::String,
    pub sub_category: ::std::string::String,
    pub put_dt: i64,
    pub call_dt: i64,
    pub lst_coupon: i64,
    pub nxt_coupon: i64,
    pub issue_dt: i64,
    pub place: ::std::string::String,
    pub country: ::std::string::String,
    pub booking_basis: ::std::string::String,
    pub residual_maturity: i64,
    pub slr_non_slr: ::std::string::String,
    pub listed: ::std::string::String,
    pub issuer_name: ::std::string::String,
    pub rating_agency: ::std::string::String,
    pub rating: ::std::string::String,
    pub market: ::std::string::String,
    pub asset_classification: ::std::string::String,
    pub gurantor: ::std::string::String,
    pub industry: ::std::string::String,
    pub sub_industry: ::std::string::String,
    pub borrower_category: ::std::string::String,
    pub asset_typ: ::std::string::String,
    pub asset_category: ::std::string::String,
    pub curr: ::std::string::String,
    pub coupon_classification_1: ::std::string::String,
    pub lst_rep_dt: i64,
    pub nxt_rep_dt: i64,
    pub m_duration: f64,
    pub trsy_gl_cd: ::std::string::String,
    pub cf_type: ::std::string::String,
    pub cf_amt: ::std::string::String,
    pub cf_ccy: ::std::string::String,
    pub cf_dt: i64,
    pub prin_amt: f64,
    pub int_amt: f64,
    pub cbs_gl_cd: ::std::string::String,
    pub w4b_cd: ::std::string::String,
    pub balm_llg: ::std::string::String,
    pub care_llg: ::std::string::String,
    pub ba_llg: ::std::string::String,
    pub tot_prin_amt: f64,
    pub tot_int_amt: f64,
    pub cashflows: ::protobuf::RepeatedField<Cashflow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountWithCashflows {
    pub fn new() -> AccountWithCashflows {
        ::std::default::Default::default()
    }

    // string portfolio_num = 1;

    pub fn clear_portfolio_num(&mut self) {
        self.portfolio_num.clear();
    }

    // Param is passed by value, moved
    pub fn set_portfolio_num(&mut self, v: ::std::string::String) {
        self.portfolio_num = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portfolio_num(&mut self) -> &mut ::std::string::String {
        &mut self.portfolio_num
    }

    // Take field
    pub fn take_portfolio_num(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.portfolio_num, ::std::string::String::new())
    }

    pub fn get_portfolio_num(&self) -> &str {
        &self.portfolio_num
    }

    // string portfolio = 2;

    pub fn clear_portfolio(&mut self) {
        self.portfolio.clear();
    }

    // Param is passed by value, moved
    pub fn set_portfolio(&mut self, v: ::std::string::String) {
        self.portfolio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portfolio(&mut self) -> &mut ::std::string::String {
        &mut self.portfolio
    }

    // Take field
    pub fn take_portfolio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.portfolio, ::std::string::String::new())
    }

    pub fn get_portfolio(&self) -> &str {
        &self.portfolio
    }

    // string security_name = 3;

    pub fn clear_security_name(&mut self) {
        self.security_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_security_name(&mut self, v: ::std::string::String) {
        self.security_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_security_name(&mut self) -> &mut ::std::string::String {
        &mut self.security_name
    }

    // Take field
    pub fn take_security_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.security_name, ::std::string::String::new())
    }

    pub fn get_security_name(&self) -> &str {
        &self.security_name
    }

    // int64 maturity_dt = 4;

    pub fn clear_maturity_dt(&mut self) {
        self.maturity_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_maturity_dt(&mut self, v: i64) {
        self.maturity_dt = v;
    }

    pub fn get_maturity_dt(&self) -> i64 {
        self.maturity_dt
    }

    // double coupon = 5;

    pub fn clear_coupon(&mut self) {
        self.coupon = 0.;
    }

    // Param is passed by value, moved
    pub fn set_coupon(&mut self, v: f64) {
        self.coupon = v;
    }

    pub fn get_coupon(&self) -> f64 {
        self.coupon
    }

    // double face_val_per_units = 6;

    pub fn clear_face_val_per_units(&mut self) {
        self.face_val_per_units = 0.;
    }

    // Param is passed by value, moved
    pub fn set_face_val_per_units(&mut self, v: f64) {
        self.face_val_per_units = v;
    }

    pub fn get_face_val_per_units(&self) -> f64 {
        self.face_val_per_units
    }

    // double quantity = 7;

    pub fn clear_quantity(&mut self) {
        self.quantity = 0.;
    }

    // Param is passed by value, moved
    pub fn set_quantity(&mut self, v: f64) {
        self.quantity = v;
    }

    pub fn get_quantity(&self) -> f64 {
        self.quantity
    }

    // double face_val = 8;

    pub fn clear_face_val(&mut self) {
        self.face_val = 0.;
    }

    // Param is passed by value, moved
    pub fn set_face_val(&mut self, v: f64) {
        self.face_val = v;
    }

    pub fn get_face_val(&self) -> f64 {
        self.face_val
    }

    // double wap = 9;

    pub fn clear_wap(&mut self) {
        self.wap = 0.;
    }

    // Param is passed by value, moved
    pub fn set_wap(&mut self, v: f64) {
        self.wap = v;
    }

    pub fn get_wap(&self) -> f64 {
        self.wap
    }

    // double book_val = 10;

    pub fn clear_book_val(&mut self) {
        self.book_val = 0.;
    }

    // Param is passed by value, moved
    pub fn set_book_val(&mut self, v: f64) {
        self.book_val = v;
    }

    pub fn get_book_val(&self) -> f64 {
        self.book_val
    }

    // double market_val = 11;

    pub fn clear_market_val(&mut self) {
        self.market_val = 0.;
    }

    // Param is passed by value, moved
    pub fn set_market_val(&mut self, v: f64) {
        self.market_val = v;
    }

    pub fn get_market_val(&self) -> f64 {
        self.market_val
    }

    // double mtm = 12;

    pub fn clear_mtm(&mut self) {
        self.mtm = 0.;
    }

    // Param is passed by value, moved
    pub fn set_mtm(&mut self, v: f64) {
        self.mtm = v;
    }

    pub fn get_mtm(&self) -> f64 {
        self.mtm
    }

    // double yeild = 13;

    pub fn clear_yeild(&mut self) {
        self.yeild = 0.;
    }

    // Param is passed by value, moved
    pub fn set_yeild(&mut self, v: f64) {
        self.yeild = v;
    }

    pub fn get_yeild(&self) -> f64 {
        self.yeild
    }

    // double appreciation = 14;

    pub fn clear_appreciation(&mut self) {
        self.appreciation = 0.;
    }

    // Param is passed by value, moved
    pub fn set_appreciation(&mut self, v: f64) {
        self.appreciation = v;
    }

    pub fn get_appreciation(&self) -> f64 {
        self.appreciation
    }

    // double depreciation = 15;

    pub fn clear_depreciation(&mut self) {
        self.depreciation = 0.;
    }

    // Param is passed by value, moved
    pub fn set_depreciation(&mut self, v: f64) {
        self.depreciation = v;
    }

    pub fn get_depreciation(&self) -> f64 {
        self.depreciation
    }

    // double net_appreciation_depreciation = 16;

    pub fn clear_net_appreciation_depreciation(&mut self) {
        self.net_appreciation_depreciation = 0.;
    }

    // Param is passed by value, moved
    pub fn set_net_appreciation_depreciation(&mut self, v: f64) {
        self.net_appreciation_depreciation = v;
    }

    pub fn get_net_appreciation_depreciation(&self) -> f64 {
        self.net_appreciation_depreciation
    }

    // double amort_as_on_dt = 17;

    pub fn clear_amort_as_on_dt(&mut self) {
        self.amort_as_on_dt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_amort_as_on_dt(&mut self, v: f64) {
        self.amort_as_on_dt = v;
    }

    pub fn get_amort_as_on_dt(&self) -> f64 {
        self.amort_as_on_dt
    }

    // double accounted_amort = 18;

    pub fn clear_accounted_amort(&mut self) {
        self.accounted_amort = 0.;
    }

    // Param is passed by value, moved
    pub fn set_accounted_amort(&mut self, v: f64) {
        self.accounted_amort = v;
    }

    pub fn get_accounted_amort(&self) -> f64 {
        self.accounted_amort
    }

    // double un_accounted_amort = 19;

    pub fn clear_un_accounted_amort(&mut self) {
        self.un_accounted_amort = 0.;
    }

    // Param is passed by value, moved
    pub fn set_un_accounted_amort(&mut self, v: f64) {
        self.un_accounted_amort = v;
    }

    pub fn get_un_accounted_amort(&self) -> f64 {
        self.un_accounted_amort
    }

    // double accrued_int = 20;

    pub fn clear_accrued_int(&mut self) {
        self.accrued_int = 0.;
    }

    // Param is passed by value, moved
    pub fn set_accrued_int(&mut self, v: f64) {
        self.accrued_int = v;
    }

    pub fn get_accrued_int(&self) -> f64 {
        self.accrued_int
    }

    // double no_ca_skipped = 21;

    pub fn clear_no_ca_skipped(&mut self) {
        self.no_ca_skipped = 0.;
    }

    // Param is passed by value, moved
    pub fn set_no_ca_skipped(&mut self, v: f64) {
        self.no_ca_skipped = v;
    }

    pub fn get_no_ca_skipped(&self) -> f64 {
        self.no_ca_skipped
    }

    // double ca_int_not_receieved = 22;

    pub fn clear_ca_int_not_receieved(&mut self) {
        self.ca_int_not_receieved = 0.;
    }

    // Param is passed by value, moved
    pub fn set_ca_int_not_receieved(&mut self, v: f64) {
        self.ca_int_not_receieved = v;
    }

    pub fn get_ca_int_not_receieved(&self) -> f64 {
        self.ca_int_not_receieved
    }

    // double total_int = 23;

    pub fn clear_total_int(&mut self) {
        self.total_int = 0.;
    }

    // Param is passed by value, moved
    pub fn set_total_int(&mut self, v: f64) {
        self.total_int = v;
    }

    pub fn get_total_int(&self) -> f64 {
        self.total_int
    }

    // string inst_id = 24;

    pub fn clear_inst_id(&mut self) {
        self.inst_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_inst_id(&mut self, v: ::std::string::String) {
        self.inst_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inst_id(&mut self) -> &mut ::std::string::String {
        &mut self.inst_id
    }

    // Take field
    pub fn take_inst_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.inst_id, ::std::string::String::new())
    }

    pub fn get_inst_id(&self) -> &str {
        &self.inst_id
    }

    // string inst_typ = 25;

    pub fn clear_inst_typ(&mut self) {
        self.inst_typ.clear();
    }

    // Param is passed by value, moved
    pub fn set_inst_typ(&mut self, v: ::std::string::String) {
        self.inst_typ = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inst_typ(&mut self) -> &mut ::std::string::String {
        &mut self.inst_typ
    }

    // Take field
    pub fn take_inst_typ(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.inst_typ, ::std::string::String::new())
    }

    pub fn get_inst_typ(&self) -> &str {
        &self.inst_typ
    }

    // string isin_code = 26;

    pub fn clear_isin_code(&mut self) {
        self.isin_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_isin_code(&mut self, v: ::std::string::String) {
        self.isin_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_isin_code(&mut self) -> &mut ::std::string::String {
        &mut self.isin_code
    }

    // Take field
    pub fn take_isin_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.isin_code, ::std::string::String::new())
    }

    pub fn get_isin_code(&self) -> &str {
        &self.isin_code
    }

    // string int_freq = 27;

    pub fn clear_int_freq(&mut self) {
        self.int_freq.clear();
    }

    // Param is passed by value, moved
    pub fn set_int_freq(&mut self, v: ::std::string::String) {
        self.int_freq = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_int_freq(&mut self) -> &mut ::std::string::String {
        &mut self.int_freq
    }

    // Take field
    pub fn take_int_freq(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.int_freq, ::std::string::String::new())
    }

    pub fn get_int_freq(&self) -> &str {
        &self.int_freq
    }

    // string int_practice = 28;

    pub fn clear_int_practice(&mut self) {
        self.int_practice.clear();
    }

    // Param is passed by value, moved
    pub fn set_int_practice(&mut self, v: ::std::string::String) {
        self.int_practice = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_int_practice(&mut self) -> &mut ::std::string::String {
        &mut self.int_practice
    }

    // Take field
    pub fn take_int_practice(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.int_practice, ::std::string::String::new())
    }

    pub fn get_int_practice(&self) -> &str {
        &self.int_practice
    }

    // string category = 29;

    pub fn clear_category(&mut self) {
        self.category.clear();
    }

    // Param is passed by value, moved
    pub fn set_category(&mut self, v: ::std::string::String) {
        self.category = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_category(&mut self) -> &mut ::std::string::String {
        &mut self.category
    }

    // Take field
    pub fn take_category(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.category, ::std::string::String::new())
    }

    pub fn get_category(&self) -> &str {
        &self.category
    }

    // string sub_category = 30;

    pub fn clear_sub_category(&mut self) {
        self.sub_category.clear();
    }

    // Param is passed by value, moved
    pub fn set_sub_category(&mut self, v: ::std::string::String) {
        self.sub_category = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sub_category(&mut self) -> &mut ::std::string::String {
        &mut self.sub_category
    }

    // Take field
    pub fn take_sub_category(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sub_category, ::std::string::String::new())
    }

    pub fn get_sub_category(&self) -> &str {
        &self.sub_category
    }

    // int64 put_dt = 31;

    pub fn clear_put_dt(&mut self) {
        self.put_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_put_dt(&mut self, v: i64) {
        self.put_dt = v;
    }

    pub fn get_put_dt(&self) -> i64 {
        self.put_dt
    }

    // int64 call_dt = 32;

    pub fn clear_call_dt(&mut self) {
        self.call_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_call_dt(&mut self, v: i64) {
        self.call_dt = v;
    }

    pub fn get_call_dt(&self) -> i64 {
        self.call_dt
    }

    // int64 lst_coupon = 33;

    pub fn clear_lst_coupon(&mut self) {
        self.lst_coupon = 0;
    }

    // Param is passed by value, moved
    pub fn set_lst_coupon(&mut self, v: i64) {
        self.lst_coupon = v;
    }

    pub fn get_lst_coupon(&self) -> i64 {
        self.lst_coupon
    }

    // int64 nxt_coupon = 34;

    pub fn clear_nxt_coupon(&mut self) {
        self.nxt_coupon = 0;
    }

    // Param is passed by value, moved
    pub fn set_nxt_coupon(&mut self, v: i64) {
        self.nxt_coupon = v;
    }

    pub fn get_nxt_coupon(&self) -> i64 {
        self.nxt_coupon
    }

    // int64 issue_dt = 35;

    pub fn clear_issue_dt(&mut self) {
        self.issue_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_issue_dt(&mut self, v: i64) {
        self.issue_dt = v;
    }

    pub fn get_issue_dt(&self) -> i64 {
        self.issue_dt
    }

    // string place = 36;

    pub fn clear_place(&mut self) {
        self.place.clear();
    }

    // Param is passed by value, moved
    pub fn set_place(&mut self, v: ::std::string::String) {
        self.place = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_place(&mut self) -> &mut ::std::string::String {
        &mut self.place
    }

    // Take field
    pub fn take_place(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.place, ::std::string::String::new())
    }

    pub fn get_place(&self) -> &str {
        &self.place
    }

    // string country = 37;

    pub fn clear_country(&mut self) {
        self.country.clear();
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        &mut self.country
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.country, ::std::string::String::new())
    }

    pub fn get_country(&self) -> &str {
        &self.country
    }

    // string booking_basis = 38;

    pub fn clear_booking_basis(&mut self) {
        self.booking_basis.clear();
    }

    // Param is passed by value, moved
    pub fn set_booking_basis(&mut self, v: ::std::string::String) {
        self.booking_basis = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_booking_basis(&mut self) -> &mut ::std::string::String {
        &mut self.booking_basis
    }

    // Take field
    pub fn take_booking_basis(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.booking_basis, ::std::string::String::new())
    }

    pub fn get_booking_basis(&self) -> &str {
        &self.booking_basis
    }

    // int64 residual_maturity = 39;

    pub fn clear_residual_maturity(&mut self) {
        self.residual_maturity = 0;
    }

    // Param is passed by value, moved
    pub fn set_residual_maturity(&mut self, v: i64) {
        self.residual_maturity = v;
    }

    pub fn get_residual_maturity(&self) -> i64 {
        self.residual_maturity
    }

    // string slr_non_slr = 40;

    pub fn clear_slr_non_slr(&mut self) {
        self.slr_non_slr.clear();
    }

    // Param is passed by value, moved
    pub fn set_slr_non_slr(&mut self, v: ::std::string::String) {
        self.slr_non_slr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slr_non_slr(&mut self) -> &mut ::std::string::String {
        &mut self.slr_non_slr
    }

    // Take field
    pub fn take_slr_non_slr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.slr_non_slr, ::std::string::String::new())
    }

    pub fn get_slr_non_slr(&self) -> &str {
        &self.slr_non_slr
    }

    // string listed = 41;

    pub fn clear_listed(&mut self) {
        self.listed.clear();
    }

    // Param is passed by value, moved
    pub fn set_listed(&mut self, v: ::std::string::String) {
        self.listed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listed(&mut self) -> &mut ::std::string::String {
        &mut self.listed
    }

    // Take field
    pub fn take_listed(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.listed, ::std::string::String::new())
    }

    pub fn get_listed(&self) -> &str {
        &self.listed
    }

    // string issuer_name = 42;

    pub fn clear_issuer_name(&mut self) {
        self.issuer_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuer_name(&mut self, v: ::std::string::String) {
        self.issuer_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuer_name(&mut self) -> &mut ::std::string::String {
        &mut self.issuer_name
    }

    // Take field
    pub fn take_issuer_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.issuer_name, ::std::string::String::new())
    }

    pub fn get_issuer_name(&self) -> &str {
        &self.issuer_name
    }

    // string rating_agency = 43;

    pub fn clear_rating_agency(&mut self) {
        self.rating_agency.clear();
    }

    // Param is passed by value, moved
    pub fn set_rating_agency(&mut self, v: ::std::string::String) {
        self.rating_agency = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rating_agency(&mut self) -> &mut ::std::string::String {
        &mut self.rating_agency
    }

    // Take field
    pub fn take_rating_agency(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rating_agency, ::std::string::String::new())
    }

    pub fn get_rating_agency(&self) -> &str {
        &self.rating_agency
    }

    // string rating = 44;

    pub fn clear_rating(&mut self) {
        self.rating.clear();
    }

    // Param is passed by value, moved
    pub fn set_rating(&mut self, v: ::std::string::String) {
        self.rating = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rating(&mut self) -> &mut ::std::string::String {
        &mut self.rating
    }

    // Take field
    pub fn take_rating(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rating, ::std::string::String::new())
    }

    pub fn get_rating(&self) -> &str {
        &self.rating
    }

    // string market = 45;

    pub fn clear_market(&mut self) {
        self.market.clear();
    }

    // Param is passed by value, moved
    pub fn set_market(&mut self, v: ::std::string::String) {
        self.market = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_market(&mut self) -> &mut ::std::string::String {
        &mut self.market
    }

    // Take field
    pub fn take_market(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.market, ::std::string::String::new())
    }

    pub fn get_market(&self) -> &str {
        &self.market
    }

    // string asset_classification = 46;

    pub fn clear_asset_classification(&mut self) {
        self.asset_classification.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_classification(&mut self, v: ::std::string::String) {
        self.asset_classification = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_classification(&mut self) -> &mut ::std::string::String {
        &mut self.asset_classification
    }

    // Take field
    pub fn take_asset_classification(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.asset_classification, ::std::string::String::new())
    }

    pub fn get_asset_classification(&self) -> &str {
        &self.asset_classification
    }

    // string gurantor = 47;

    pub fn clear_gurantor(&mut self) {
        self.gurantor.clear();
    }

    // Param is passed by value, moved
    pub fn set_gurantor(&mut self, v: ::std::string::String) {
        self.gurantor = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gurantor(&mut self) -> &mut ::std::string::String {
        &mut self.gurantor
    }

    // Take field
    pub fn take_gurantor(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gurantor, ::std::string::String::new())
    }

    pub fn get_gurantor(&self) -> &str {
        &self.gurantor
    }

    // string industry = 48;

    pub fn clear_industry(&mut self) {
        self.industry.clear();
    }

    // Param is passed by value, moved
    pub fn set_industry(&mut self, v: ::std::string::String) {
        self.industry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_industry(&mut self) -> &mut ::std::string::String {
        &mut self.industry
    }

    // Take field
    pub fn take_industry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.industry, ::std::string::String::new())
    }

    pub fn get_industry(&self) -> &str {
        &self.industry
    }

    // string sub_industry = 49;

    pub fn clear_sub_industry(&mut self) {
        self.sub_industry.clear();
    }

    // Param is passed by value, moved
    pub fn set_sub_industry(&mut self, v: ::std::string::String) {
        self.sub_industry = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sub_industry(&mut self) -> &mut ::std::string::String {
        &mut self.sub_industry
    }

    // Take field
    pub fn take_sub_industry(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sub_industry, ::std::string::String::new())
    }

    pub fn get_sub_industry(&self) -> &str {
        &self.sub_industry
    }

    // string borrower_category = 50;

    pub fn clear_borrower_category(&mut self) {
        self.borrower_category.clear();
    }

    // Param is passed by value, moved
    pub fn set_borrower_category(&mut self, v: ::std::string::String) {
        self.borrower_category = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_borrower_category(&mut self) -> &mut ::std::string::String {
        &mut self.borrower_category
    }

    // Take field
    pub fn take_borrower_category(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.borrower_category, ::std::string::String::new())
    }

    pub fn get_borrower_category(&self) -> &str {
        &self.borrower_category
    }

    // string asset_typ = 51;

    pub fn clear_asset_typ(&mut self) {
        self.asset_typ.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_typ(&mut self, v: ::std::string::String) {
        self.asset_typ = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_typ(&mut self) -> &mut ::std::string::String {
        &mut self.asset_typ
    }

    // Take field
    pub fn take_asset_typ(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.asset_typ, ::std::string::String::new())
    }

    pub fn get_asset_typ(&self) -> &str {
        &self.asset_typ
    }

    // string asset_category = 52;

    pub fn clear_asset_category(&mut self) {
        self.asset_category.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_category(&mut self, v: ::std::string::String) {
        self.asset_category = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_category(&mut self) -> &mut ::std::string::String {
        &mut self.asset_category
    }

    // Take field
    pub fn take_asset_category(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.asset_category, ::std::string::String::new())
    }

    pub fn get_asset_category(&self) -> &str {
        &self.asset_category
    }

    // string curr = 53;

    pub fn clear_curr(&mut self) {
        self.curr.clear();
    }

    // Param is passed by value, moved
    pub fn set_curr(&mut self, v: ::std::string::String) {
        self.curr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_curr(&mut self) -> &mut ::std::string::String {
        &mut self.curr
    }

    // Take field
    pub fn take_curr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.curr, ::std::string::String::new())
    }

    pub fn get_curr(&self) -> &str {
        &self.curr
    }

    // string coupon_classification_1 = 54;

    pub fn clear_coupon_classification_1(&mut self) {
        self.coupon_classification_1.clear();
    }

    // Param is passed by value, moved
    pub fn set_coupon_classification_1(&mut self, v: ::std::string::String) {
        self.coupon_classification_1 = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coupon_classification_1(&mut self) -> &mut ::std::string::String {
        &mut self.coupon_classification_1
    }

    // Take field
    pub fn take_coupon_classification_1(&mut self) -> ::std::string::String {
        ::std::mem::replace(
            &mut self.coupon_classification_1,
            ::std::string::String::new(),
        )
    }

    pub fn get_coupon_classification_1(&self) -> &str {
        &self.coupon_classification_1
    }

    // int64 lst_rep_dt = 55;

    pub fn clear_lst_rep_dt(&mut self) {
        self.lst_rep_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_lst_rep_dt(&mut self, v: i64) {
        self.lst_rep_dt = v;
    }

    pub fn get_lst_rep_dt(&self) -> i64 {
        self.lst_rep_dt
    }

    // int64 nxt_rep_dt = 56;

    pub fn clear_nxt_rep_dt(&mut self) {
        self.nxt_rep_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_nxt_rep_dt(&mut self, v: i64) {
        self.nxt_rep_dt = v;
    }

    pub fn get_nxt_rep_dt(&self) -> i64 {
        self.nxt_rep_dt
    }

    // double m_duration = 57;

    pub fn clear_m_duration(&mut self) {
        self.m_duration = 0.;
    }

    // Param is passed by value, moved
    pub fn set_m_duration(&mut self, v: f64) {
        self.m_duration = v;
    }

    pub fn get_m_duration(&self) -> f64 {
        self.m_duration
    }

    // string trsy_gl_cd = 58;

    pub fn clear_trsy_gl_cd(&mut self) {
        self.trsy_gl_cd.clear();
    }

    // Param is passed by value, moved
    pub fn set_trsy_gl_cd(&mut self, v: ::std::string::String) {
        self.trsy_gl_cd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_trsy_gl_cd(&mut self) -> &mut ::std::string::String {
        &mut self.trsy_gl_cd
    }

    // Take field
    pub fn take_trsy_gl_cd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.trsy_gl_cd, ::std::string::String::new())
    }

    pub fn get_trsy_gl_cd(&self) -> &str {
        &self.trsy_gl_cd
    }

    // string cf_type = 59;

    pub fn clear_cf_type(&mut self) {
        self.cf_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf_type(&mut self, v: ::std::string::String) {
        self.cf_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf_type(&mut self) -> &mut ::std::string::String {
        &mut self.cf_type
    }

    // Take field
    pub fn take_cf_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf_type, ::std::string::String::new())
    }

    pub fn get_cf_type(&self) -> &str {
        &self.cf_type
    }

    // string cf_amt = 60;

    pub fn clear_cf_amt(&mut self) {
        self.cf_amt.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf_amt(&mut self, v: ::std::string::String) {
        self.cf_amt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf_amt(&mut self) -> &mut ::std::string::String {
        &mut self.cf_amt
    }

    // Take field
    pub fn take_cf_amt(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf_amt, ::std::string::String::new())
    }

    pub fn get_cf_amt(&self) -> &str {
        &self.cf_amt
    }

    // string cf_ccy = 61;

    pub fn clear_cf_ccy(&mut self) {
        self.cf_ccy.clear();
    }

    // Param is passed by value, moved
    pub fn set_cf_ccy(&mut self, v: ::std::string::String) {
        self.cf_ccy = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cf_ccy(&mut self) -> &mut ::std::string::String {
        &mut self.cf_ccy
    }

    // Take field
    pub fn take_cf_ccy(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cf_ccy, ::std::string::String::new())
    }

    pub fn get_cf_ccy(&self) -> &str {
        &self.cf_ccy
    }

    // int64 cf_dt = 62;

    pub fn clear_cf_dt(&mut self) {
        self.cf_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_cf_dt(&mut self, v: i64) {
        self.cf_dt = v;
    }

    pub fn get_cf_dt(&self) -> i64 {
        self.cf_dt
    }

    // double prin_amt = 63;

    pub fn clear_prin_amt(&mut self) {
        self.prin_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_prin_amt(&mut self, v: f64) {
        self.prin_amt = v;
    }

    pub fn get_prin_amt(&self) -> f64 {
        self.prin_amt
    }

    // double int_amt = 64;

    pub fn clear_int_amt(&mut self) {
        self.int_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_int_amt(&mut self, v: f64) {
        self.int_amt = v;
    }

    pub fn get_int_amt(&self) -> f64 {
        self.int_amt
    }

    // string cbs_gl_cd = 65;

    pub fn clear_cbs_gl_cd(&mut self) {
        self.cbs_gl_cd.clear();
    }

    // Param is passed by value, moved
    pub fn set_cbs_gl_cd(&mut self, v: ::std::string::String) {
        self.cbs_gl_cd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cbs_gl_cd(&mut self) -> &mut ::std::string::String {
        &mut self.cbs_gl_cd
    }

    // Take field
    pub fn take_cbs_gl_cd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cbs_gl_cd, ::std::string::String::new())
    }

    pub fn get_cbs_gl_cd(&self) -> &str {
        &self.cbs_gl_cd
    }

    // string w4b_cd = 66;

    pub fn clear_w4b_cd(&mut self) {
        self.w4b_cd.clear();
    }

    // Param is passed by value, moved
    pub fn set_w4b_cd(&mut self, v: ::std::string::String) {
        self.w4b_cd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_w4b_cd(&mut self) -> &mut ::std::string::String {
        &mut self.w4b_cd
    }

    // Take field
    pub fn take_w4b_cd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.w4b_cd, ::std::string::String::new())
    }

    pub fn get_w4b_cd(&self) -> &str {
        &self.w4b_cd
    }

    // string balm_llg = 67;

    pub fn clear_balm_llg(&mut self) {
        self.balm_llg.clear();
    }

    // Param is passed by value, moved
    pub fn set_balm_llg(&mut self, v: ::std::string::String) {
        self.balm_llg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balm_llg(&mut self) -> &mut ::std::string::String {
        &mut self.balm_llg
    }

    // Take field
    pub fn take_balm_llg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.balm_llg, ::std::string::String::new())
    }

    pub fn get_balm_llg(&self) -> &str {
        &self.balm_llg
    }

    // string care_llg = 68;

    pub fn clear_care_llg(&mut self) {
        self.care_llg.clear();
    }

    // Param is passed by value, moved
    pub fn set_care_llg(&mut self, v: ::std::string::String) {
        self.care_llg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_care_llg(&mut self) -> &mut ::std::string::String {
        &mut self.care_llg
    }

    // Take field
    pub fn take_care_llg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.care_llg, ::std::string::String::new())
    }

    pub fn get_care_llg(&self) -> &str {
        &self.care_llg
    }

    // string ba_llg = 69;

    pub fn clear_ba_llg(&mut self) {
        self.ba_llg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ba_llg(&mut self, v: ::std::string::String) {
        self.ba_llg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ba_llg(&mut self) -> &mut ::std::string::String {
        &mut self.ba_llg
    }

    // Take field
    pub fn take_ba_llg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ba_llg, ::std::string::String::new())
    }

    pub fn get_ba_llg(&self) -> &str {
        &self.ba_llg
    }

    // double tot_prin_amt = 70;

    pub fn clear_tot_prin_amt(&mut self) {
        self.tot_prin_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tot_prin_amt(&mut self, v: f64) {
        self.tot_prin_amt = v;
    }

    pub fn get_tot_prin_amt(&self) -> f64 {
        self.tot_prin_amt
    }

    // double tot_int_amt = 71;

    pub fn clear_tot_int_amt(&mut self) {
        self.tot_int_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tot_int_amt(&mut self, v: f64) {
        self.tot_int_amt = v;
    }

    pub fn get_tot_int_amt(&self) -> f64 {
        self.tot_int_amt
    }

    // repeated .Cashflow cashflows = 72;

    pub fn clear_cashflows(&mut self) {
        self.cashflows.clear();
    }

    // Param is passed by value, moved
    pub fn set_cashflows(&mut self, v: ::protobuf::RepeatedField<Cashflow>) {
        self.cashflows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cashflows(&mut self) -> &mut ::protobuf::RepeatedField<Cashflow> {
        &mut self.cashflows
    }

    // Take field
    pub fn take_cashflows(&mut self) -> ::protobuf::RepeatedField<Cashflow> {
        ::std::mem::replace(&mut self.cashflows, ::protobuf::RepeatedField::new())
    }

    pub fn get_cashflows(&self) -> &[Cashflow] {
        &self.cashflows
    }
}

impl ::protobuf::Message for AccountWithCashflows {
    fn is_initialized(&self) -> bool {
        for v in &self.cashflows {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(
        &mut self,
        is: &mut ::protobuf::CodedInputStream,
    ) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.portfolio_num,
                    )?;
                }
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.portfolio,
                    )?;
                }
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.security_name,
                    )?;
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.maturity_dt = tmp;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.coupon = tmp;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.face_val_per_units = tmp;
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.quantity = tmp;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.face_val = tmp;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.wap = tmp;
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.book_val = tmp;
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.market_val = tmp;
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.mtm = tmp;
                }
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.yeild = tmp;
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.appreciation = tmp;
                }
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.depreciation = tmp;
                }
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.net_appreciation_depreciation = tmp;
                }
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.amort_as_on_dt = tmp;
                }
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.accounted_amort = tmp;
                }
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.un_accounted_amort = tmp;
                }
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.accrued_int = tmp;
                }
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.no_ca_skipped = tmp;
                }
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.ca_int_not_receieved = tmp;
                }
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.total_int = tmp;
                }
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.inst_id,
                    )?;
                }
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.inst_typ,
                    )?;
                }
                26 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.isin_code,
                    )?;
                }
                27 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.int_freq,
                    )?;
                }
                28 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.int_practice,
                    )?;
                }
                29 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.category,
                    )?;
                }
                30 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.sub_category,
                    )?;
                }
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.put_dt = tmp;
                }
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.call_dt = tmp;
                }
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.lst_coupon = tmp;
                }
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.nxt_coupon = tmp;
                }
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.issue_dt = tmp;
                }
                36 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.place,
                    )?;
                }
                37 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.country,
                    )?;
                }
                38 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.booking_basis,
                    )?;
                }
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.residual_maturity = tmp;
                }
                40 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.slr_non_slr,
                    )?;
                }
                41 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.listed,
                    )?;
                }
                42 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.issuer_name,
                    )?;
                }
                43 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.rating_agency,
                    )?;
                }
                44 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.rating,
                    )?;
                }
                45 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.market,
                    )?;
                }
                46 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.asset_classification,
                    )?;
                }
                47 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.gurantor,
                    )?;
                }
                48 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.industry,
                    )?;
                }
                49 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.sub_industry,
                    )?;
                }
                50 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.borrower_category,
                    )?;
                }
                51 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.asset_typ,
                    )?;
                }
                52 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.asset_category,
                    )?;
                }
                53 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.curr,
                    )?;
                }
                54 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.coupon_classification_1,
                    )?;
                }
                55 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.lst_rep_dt = tmp;
                }
                56 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.nxt_rep_dt = tmp;
                }
                57 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.m_duration = tmp;
                }
                58 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.trsy_gl_cd,
                    )?;
                }
                59 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.cf_type,
                    )?;
                }
                60 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.cf_amt,
                    )?;
                }
                61 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.cf_ccy,
                    )?;
                }
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_int64()?;
                    self.cf_dt = tmp;
                }
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.prin_amt = tmp;
                }
                64 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.int_amt = tmp;
                }
                65 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.cbs_gl_cd,
                    )?;
                }
                66 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.w4b_cd,
                    )?;
                }
                67 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.balm_llg,
                    )?;
                }
                68 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.care_llg,
                    )?;
                }
                69 => {
                    ::protobuf::rt::read_singular_proto3_string_into(
                        wire_type,
                        is,
                        &mut self.ba_llg,
                    )?;
                }
                70 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.tot_prin_amt = tmp;
                }
                71 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(
                            wire_type,
                        ));
                    }
                    let tmp = is.read_double()?;
                    self.tot_int_amt = tmp;
                }
                72 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cashflows)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(
                        field_number,
                        wire_type,
                        is,
                        self.mut_unknown_fields(),
                    )?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.portfolio_num.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.portfolio_num);
        }
        if !self.portfolio.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.portfolio);
        }
        if !self.security_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.security_name);
        }
        if self.maturity_dt != 0 {
            my_size += ::protobuf::rt::value_size(
                4,
                self.maturity_dt,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.coupon != 0. {
            my_size += 9;
        }
        if self.face_val_per_units != 0. {
            my_size += 9;
        }
        if self.quantity != 0. {
            my_size += 9;
        }
        if self.face_val != 0. {
            my_size += 9;
        }
        if self.wap != 0. {
            my_size += 9;
        }
        if self.book_val != 0. {
            my_size += 9;
        }
        if self.market_val != 0. {
            my_size += 9;
        }
        if self.mtm != 0. {
            my_size += 9;
        }
        if self.yeild != 0. {
            my_size += 9;
        }
        if self.appreciation != 0. {
            my_size += 9;
        }
        if self.depreciation != 0. {
            my_size += 9;
        }
        if self.net_appreciation_depreciation != 0. {
            my_size += 10;
        }
        if self.amort_as_on_dt != 0. {
            my_size += 10;
        }
        if self.accounted_amort != 0. {
            my_size += 10;
        }
        if self.un_accounted_amort != 0. {
            my_size += 10;
        }
        if self.accrued_int != 0. {
            my_size += 10;
        }
        if self.no_ca_skipped != 0. {
            my_size += 10;
        }
        if self.ca_int_not_receieved != 0. {
            my_size += 10;
        }
        if self.total_int != 0. {
            my_size += 10;
        }
        if !self.inst_id.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.inst_id);
        }
        if !self.inst_typ.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.inst_typ);
        }
        if !self.isin_code.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.isin_code);
        }
        if !self.int_freq.is_empty() {
            my_size += ::protobuf::rt::string_size(27, &self.int_freq);
        }
        if !self.int_practice.is_empty() {
            my_size += ::protobuf::rt::string_size(28, &self.int_practice);
        }
        if !self.category.is_empty() {
            my_size += ::protobuf::rt::string_size(29, &self.category);
        }
        if !self.sub_category.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.sub_category);
        }
        if self.put_dt != 0 {
            my_size += ::protobuf::rt::value_size(
                31,
                self.put_dt,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.call_dt != 0 {
            my_size += ::protobuf::rt::value_size(
                32,
                self.call_dt,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.lst_coupon != 0 {
            my_size += ::protobuf::rt::value_size(
                33,
                self.lst_coupon,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.nxt_coupon != 0 {
            my_size += ::protobuf::rt::value_size(
                34,
                self.nxt_coupon,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.issue_dt != 0 {
            my_size += ::protobuf::rt::value_size(
                35,
                self.issue_dt,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.place.is_empty() {
            my_size += ::protobuf::rt::string_size(36, &self.place);
        }
        if !self.country.is_empty() {
            my_size += ::protobuf::rt::string_size(37, &self.country);
        }
        if !self.booking_basis.is_empty() {
            my_size += ::protobuf::rt::string_size(38, &self.booking_basis);
        }
        if self.residual_maturity != 0 {
            my_size += ::protobuf::rt::value_size(
                39,
                self.residual_maturity,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if !self.slr_non_slr.is_empty() {
            my_size += ::protobuf::rt::string_size(40, &self.slr_non_slr);
        }
        if !self.listed.is_empty() {
            my_size += ::protobuf::rt::string_size(41, &self.listed);
        }
        if !self.issuer_name.is_empty() {
            my_size += ::protobuf::rt::string_size(42, &self.issuer_name);
        }
        if !self.rating_agency.is_empty() {
            my_size += ::protobuf::rt::string_size(43, &self.rating_agency);
        }
        if !self.rating.is_empty() {
            my_size += ::protobuf::rt::string_size(44, &self.rating);
        }
        if !self.market.is_empty() {
            my_size += ::protobuf::rt::string_size(45, &self.market);
        }
        if !self.asset_classification.is_empty() {
            my_size += ::protobuf::rt::string_size(46, &self.asset_classification);
        }
        if !self.gurantor.is_empty() {
            my_size += ::protobuf::rt::string_size(47, &self.gurantor);
        }
        if !self.industry.is_empty() {
            my_size += ::protobuf::rt::string_size(48, &self.industry);
        }
        if !self.sub_industry.is_empty() {
            my_size += ::protobuf::rt::string_size(49, &self.sub_industry);
        }
        if !self.borrower_category.is_empty() {
            my_size += ::protobuf::rt::string_size(50, &self.borrower_category);
        }
        if !self.asset_typ.is_empty() {
            my_size += ::protobuf::rt::string_size(51, &self.asset_typ);
        }
        if !self.asset_category.is_empty() {
            my_size += ::protobuf::rt::string_size(52, &self.asset_category);
        }
        if !self.curr.is_empty() {
            my_size += ::protobuf::rt::string_size(53, &self.curr);
        }
        if !self.coupon_classification_1.is_empty() {
            my_size += ::protobuf::rt::string_size(54, &self.coupon_classification_1);
        }
        if self.lst_rep_dt != 0 {
            my_size += ::protobuf::rt::value_size(
                55,
                self.lst_rep_dt,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.nxt_rep_dt != 0 {
            my_size += ::protobuf::rt::value_size(
                56,
                self.nxt_rep_dt,
                ::protobuf::wire_format::WireTypeVarint,
            );
        }
        if self.m_duration != 0. {
            my_size += 10;
        }
        if !self.trsy_gl_cd.is_empty() {
            my_size += ::protobuf::rt::string_size(58, &self.trsy_gl_cd);
        }
        if !self.cf_type.is_empty() {
            my_size += ::protobuf::rt::string_size(59, &self.cf_type);
        }
        if !self.cf_amt.is_empty() {
            my_size += ::protobuf::rt::string_size(60, &self.cf_amt);
        }
        if !self.cf_ccy.is_empty() {
            my_size += ::protobuf::rt::string_size(61, &self.cf_ccy);
        }
        if self.cf_dt != 0 {
            my_size +=
                ::protobuf::rt::value_size(62, self.cf_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prin_amt != 0. {
            my_size += 10;
        }
        if self.int_amt != 0. {
            my_size += 10;
        }
        if !self.cbs_gl_cd.is_empty() {
            my_size += ::protobuf::rt::string_size(65, &self.cbs_gl_cd);
        }
        if !self.w4b_cd.is_empty() {
            my_size += ::protobuf::rt::string_size(66, &self.w4b_cd);
        }
        if !self.balm_llg.is_empty() {
            my_size += ::protobuf::rt::string_size(67, &self.balm_llg);
        }
        if !self.care_llg.is_empty() {
            my_size += ::protobuf::rt::string_size(68, &self.care_llg);
        }
        if !self.ba_llg.is_empty() {
            my_size += ::protobuf::rt::string_size(69, &self.ba_llg);
        }
        if self.tot_prin_amt != 0. {
            my_size += 10;
        }
        if self.tot_int_amt != 0. {
            my_size += 10;
        }
        for value in &self.cashflows {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(
        &self,
        os: &mut ::protobuf::CodedOutputStream,
    ) -> ::protobuf::ProtobufResult<()> {
        if !self.portfolio_num.is_empty() {
            os.write_string(1, &self.portfolio_num)?;
        }
        if !self.portfolio.is_empty() {
            os.write_string(2, &self.portfolio)?;
        }
        if !self.security_name.is_empty() {
            os.write_string(3, &self.security_name)?;
        }
        if self.maturity_dt != 0 {
            os.write_int64(4, self.maturity_dt)?;
        }
        if self.coupon != 0. {
            os.write_double(5, self.coupon)?;
        }
        if self.face_val_per_units != 0. {
            os.write_double(6, self.face_val_per_units)?;
        }
        if self.quantity != 0. {
            os.write_double(7, self.quantity)?;
        }
        if self.face_val != 0. {
            os.write_double(8, self.face_val)?;
        }
        if self.wap != 0. {
            os.write_double(9, self.wap)?;
        }
        if self.book_val != 0. {
            os.write_double(10, self.book_val)?;
        }
        if self.market_val != 0. {
            os.write_double(11, self.market_val)?;
        }
        if self.mtm != 0. {
            os.write_double(12, self.mtm)?;
        }
        if self.yeild != 0. {
            os.write_double(13, self.yeild)?;
        }
        if self.appreciation != 0. {
            os.write_double(14, self.appreciation)?;
        }
        if self.depreciation != 0. {
            os.write_double(15, self.depreciation)?;
        }
        if self.net_appreciation_depreciation != 0. {
            os.write_double(16, self.net_appreciation_depreciation)?;
        }
        if self.amort_as_on_dt != 0. {
            os.write_double(17, self.amort_as_on_dt)?;
        }
        if self.accounted_amort != 0. {
            os.write_double(18, self.accounted_amort)?;
        }
        if self.un_accounted_amort != 0. {
            os.write_double(19, self.un_accounted_amort)?;
        }
        if self.accrued_int != 0. {
            os.write_double(20, self.accrued_int)?;
        }
        if self.no_ca_skipped != 0. {
            os.write_double(21, self.no_ca_skipped)?;
        }
        if self.ca_int_not_receieved != 0. {
            os.write_double(22, self.ca_int_not_receieved)?;
        }
        if self.total_int != 0. {
            os.write_double(23, self.total_int)?;
        }
        if !self.inst_id.is_empty() {
            os.write_string(24, &self.inst_id)?;
        }
        if !self.inst_typ.is_empty() {
            os.write_string(25, &self.inst_typ)?;
        }
        if !self.isin_code.is_empty() {
            os.write_string(26, &self.isin_code)?;
        }
        if !self.int_freq.is_empty() {
            os.write_string(27, &self.int_freq)?;
        }
        if !self.int_practice.is_empty() {
            os.write_string(28, &self.int_practice)?;
        }
        if !self.category.is_empty() {
            os.write_string(29, &self.category)?;
        }
        if !self.sub_category.is_empty() {
            os.write_string(30, &self.sub_category)?;
        }
        if self.put_dt != 0 {
            os.write_int64(31, self.put_dt)?;
        }
        if self.call_dt != 0 {
            os.write_int64(32, self.call_dt)?;
        }
        if self.lst_coupon != 0 {
            os.write_int64(33, self.lst_coupon)?;
        }
        if self.nxt_coupon != 0 {
            os.write_int64(34, self.nxt_coupon)?;
        }
        if self.issue_dt != 0 {
            os.write_int64(35, self.issue_dt)?;
        }
        if !self.place.is_empty() {
            os.write_string(36, &self.place)?;
        }
        if !self.country.is_empty() {
            os.write_string(37, &self.country)?;
        }
        if !self.booking_basis.is_empty() {
            os.write_string(38, &self.booking_basis)?;
        }
        if self.residual_maturity != 0 {
            os.write_int64(39, self.residual_maturity)?;
        }
        if !self.slr_non_slr.is_empty() {
            os.write_string(40, &self.slr_non_slr)?;
        }
        if !self.listed.is_empty() {
            os.write_string(41, &self.listed)?;
        }
        if !self.issuer_name.is_empty() {
            os.write_string(42, &self.issuer_name)?;
        }
        if !self.rating_agency.is_empty() {
            os.write_string(43, &self.rating_agency)?;
        }
        if !self.rating.is_empty() {
            os.write_string(44, &self.rating)?;
        }
        if !self.market.is_empty() {
            os.write_string(45, &self.market)?;
        }
        if !self.asset_classification.is_empty() {
            os.write_string(46, &self.asset_classification)?;
        }
        if !self.gurantor.is_empty() {
            os.write_string(47, &self.gurantor)?;
        }
        if !self.industry.is_empty() {
            os.write_string(48, &self.industry)?;
        }
        if !self.sub_industry.is_empty() {
            os.write_string(49, &self.sub_industry)?;
        }
        if !self.borrower_category.is_empty() {
            os.write_string(50, &self.borrower_category)?;
        }
        if !self.asset_typ.is_empty() {
            os.write_string(51, &self.asset_typ)?;
        }
        if !self.asset_category.is_empty() {
            os.write_string(52, &self.asset_category)?;
        }
        if !self.curr.is_empty() {
            os.write_string(53, &self.curr)?;
        }
        if !self.coupon_classification_1.is_empty() {
            os.write_string(54, &self.coupon_classification_1)?;
        }
        if self.lst_rep_dt != 0 {
            os.write_int64(55, self.lst_rep_dt)?;
        }
        if self.nxt_rep_dt != 0 {
            os.write_int64(56, self.nxt_rep_dt)?;
        }
        if self.m_duration != 0. {
            os.write_double(57, self.m_duration)?;
        }
        if !self.trsy_gl_cd.is_empty() {
            os.write_string(58, &self.trsy_gl_cd)?;
        }
        if !self.cf_type.is_empty() {
            os.write_string(59, &self.cf_type)?;
        }
        if !self.cf_amt.is_empty() {
            os.write_string(60, &self.cf_amt)?;
        }
        if !self.cf_ccy.is_empty() {
            os.write_string(61, &self.cf_ccy)?;
        }
        if self.cf_dt != 0 {
            os.write_int64(62, self.cf_dt)?;
        }
        if self.prin_amt != 0. {
            os.write_double(63, self.prin_amt)?;
        }
        if self.int_amt != 0. {
            os.write_double(64, self.int_amt)?;
        }
        if !self.cbs_gl_cd.is_empty() {
            os.write_string(65, &self.cbs_gl_cd)?;
        }
        if !self.w4b_cd.is_empty() {
            os.write_string(66, &self.w4b_cd)?;
        }
        if !self.balm_llg.is_empty() {
            os.write_string(67, &self.balm_llg)?;
        }
        if !self.care_llg.is_empty() {
            os.write_string(68, &self.care_llg)?;
        }
        if !self.ba_llg.is_empty() {
            os.write_string(69, &self.ba_llg)?;
        }
        if self.tot_prin_amt != 0. {
            os.write_double(70, self.tot_prin_amt)?;
        }
        if self.tot_int_amt != 0. {
            os.write_double(71, self.tot_int_amt)?;
        }
        for v in &self.cashflows {
            os.write_tag(72, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountWithCashflows {
        AccountWithCashflows::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
            };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "portfolio_num",
                    |m: &AccountWithCashflows| &m.portfolio_num,
                    |m: &mut AccountWithCashflows| &mut m.portfolio_num,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "portfolio",
                    |m: &AccountWithCashflows| &m.portfolio,
                    |m: &mut AccountWithCashflows| &mut m.portfolio,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "security_name",
                    |m: &AccountWithCashflows| &m.security_name,
                    |m: &mut AccountWithCashflows| &mut m.security_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "maturity_dt",
                    |m: &AccountWithCashflows| &m.maturity_dt,
                    |m: &mut AccountWithCashflows| &mut m.maturity_dt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "coupon",
                    |m: &AccountWithCashflows| &m.coupon,
                    |m: &mut AccountWithCashflows| &mut m.coupon,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "face_val_per_units",
                    |m: &AccountWithCashflows| &m.face_val_per_units,
                    |m: &mut AccountWithCashflows| &mut m.face_val_per_units,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "quantity",
                    |m: &AccountWithCashflows| &m.quantity,
                    |m: &mut AccountWithCashflows| &mut m.quantity,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "face_val",
                    |m: &AccountWithCashflows| &m.face_val,
                    |m: &mut AccountWithCashflows| &mut m.face_val,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "wap",
                    |m: &AccountWithCashflows| &m.wap,
                    |m: &mut AccountWithCashflows| &mut m.wap,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "book_val",
                    |m: &AccountWithCashflows| &m.book_val,
                    |m: &mut AccountWithCashflows| &mut m.book_val,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "market_val",
                    |m: &AccountWithCashflows| &m.market_val,
                    |m: &mut AccountWithCashflows| &mut m.market_val,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "mtm",
                    |m: &AccountWithCashflows| &m.mtm,
                    |m: &mut AccountWithCashflows| &mut m.mtm,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "yeild",
                    |m: &AccountWithCashflows| &m.yeild,
                    |m: &mut AccountWithCashflows| &mut m.yeild,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "appreciation",
                    |m: &AccountWithCashflows| &m.appreciation,
                    |m: &mut AccountWithCashflows| &mut m.appreciation,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "depreciation",
                    |m: &AccountWithCashflows| &m.depreciation,
                    |m: &mut AccountWithCashflows| &mut m.depreciation,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "net_appreciation_depreciation",
                    |m: &AccountWithCashflows| &m.net_appreciation_depreciation,
                    |m: &mut AccountWithCashflows| &mut m.net_appreciation_depreciation,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "amort_as_on_dt",
                    |m: &AccountWithCashflows| &m.amort_as_on_dt,
                    |m: &mut AccountWithCashflows| &mut m.amort_as_on_dt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "accounted_amort",
                    |m: &AccountWithCashflows| &m.accounted_amort,
                    |m: &mut AccountWithCashflows| &mut m.accounted_amort,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "un_accounted_amort",
                    |m: &AccountWithCashflows| &m.un_accounted_amort,
                    |m: &mut AccountWithCashflows| &mut m.un_accounted_amort,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "accrued_int",
                    |m: &AccountWithCashflows| &m.accrued_int,
                    |m: &mut AccountWithCashflows| &mut m.accrued_int,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "no_ca_skipped",
                    |m: &AccountWithCashflows| &m.no_ca_skipped,
                    |m: &mut AccountWithCashflows| &mut m.no_ca_skipped,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "ca_int_not_receieved",
                    |m: &AccountWithCashflows| &m.ca_int_not_receieved,
                    |m: &mut AccountWithCashflows| &mut m.ca_int_not_receieved,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "total_int",
                    |m: &AccountWithCashflows| &m.total_int,
                    |m: &mut AccountWithCashflows| &mut m.total_int,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "inst_id",
                    |m: &AccountWithCashflows| &m.inst_id,
                    |m: &mut AccountWithCashflows| &mut m.inst_id,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "inst_typ",
                    |m: &AccountWithCashflows| &m.inst_typ,
                    |m: &mut AccountWithCashflows| &mut m.inst_typ,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "isin_code",
                    |m: &AccountWithCashflows| &m.isin_code,
                    |m: &mut AccountWithCashflows| &mut m.isin_code,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "int_freq",
                    |m: &AccountWithCashflows| &m.int_freq,
                    |m: &mut AccountWithCashflows| &mut m.int_freq,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "int_practice",
                    |m: &AccountWithCashflows| &m.int_practice,
                    |m: &mut AccountWithCashflows| &mut m.int_practice,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "category",
                    |m: &AccountWithCashflows| &m.category,
                    |m: &mut AccountWithCashflows| &mut m.category,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "sub_category",
                    |m: &AccountWithCashflows| &m.sub_category,
                    |m: &mut AccountWithCashflows| &mut m.sub_category,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "put_dt",
                    |m: &AccountWithCashflows| &m.put_dt,
                    |m: &mut AccountWithCashflows| &mut m.put_dt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "call_dt",
                    |m: &AccountWithCashflows| &m.call_dt,
                    |m: &mut AccountWithCashflows| &mut m.call_dt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "lst_coupon",
                    |m: &AccountWithCashflows| &m.lst_coupon,
                    |m: &mut AccountWithCashflows| &mut m.lst_coupon,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "nxt_coupon",
                    |m: &AccountWithCashflows| &m.nxt_coupon,
                    |m: &mut AccountWithCashflows| &mut m.nxt_coupon,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "issue_dt",
                    |m: &AccountWithCashflows| &m.issue_dt,
                    |m: &mut AccountWithCashflows| &mut m.issue_dt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "place",
                    |m: &AccountWithCashflows| &m.place,
                    |m: &mut AccountWithCashflows| &mut m.place,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "country",
                    |m: &AccountWithCashflows| &m.country,
                    |m: &mut AccountWithCashflows| &mut m.country,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "booking_basis",
                    |m: &AccountWithCashflows| &m.booking_basis,
                    |m: &mut AccountWithCashflows| &mut m.booking_basis,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "residual_maturity",
                    |m: &AccountWithCashflows| &m.residual_maturity,
                    |m: &mut AccountWithCashflows| &mut m.residual_maturity,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "slr_non_slr",
                    |m: &AccountWithCashflows| &m.slr_non_slr,
                    |m: &mut AccountWithCashflows| &mut m.slr_non_slr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "listed",
                    |m: &AccountWithCashflows| &m.listed,
                    |m: &mut AccountWithCashflows| &mut m.listed,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "issuer_name",
                    |m: &AccountWithCashflows| &m.issuer_name,
                    |m: &mut AccountWithCashflows| &mut m.issuer_name,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "rating_agency",
                    |m: &AccountWithCashflows| &m.rating_agency,
                    |m: &mut AccountWithCashflows| &mut m.rating_agency,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "rating",
                    |m: &AccountWithCashflows| &m.rating,
                    |m: &mut AccountWithCashflows| &mut m.rating,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "market",
                    |m: &AccountWithCashflows| &m.market,
                    |m: &mut AccountWithCashflows| &mut m.market,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "asset_classification",
                    |m: &AccountWithCashflows| &m.asset_classification,
                    |m: &mut AccountWithCashflows| &mut m.asset_classification,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "gurantor",
                    |m: &AccountWithCashflows| &m.gurantor,
                    |m: &mut AccountWithCashflows| &mut m.gurantor,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "industry",
                    |m: &AccountWithCashflows| &m.industry,
                    |m: &mut AccountWithCashflows| &mut m.industry,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "sub_industry",
                    |m: &AccountWithCashflows| &m.sub_industry,
                    |m: &mut AccountWithCashflows| &mut m.sub_industry,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "borrower_category",
                    |m: &AccountWithCashflows| &m.borrower_category,
                    |m: &mut AccountWithCashflows| &mut m.borrower_category,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "asset_typ",
                    |m: &AccountWithCashflows| &m.asset_typ,
                    |m: &mut AccountWithCashflows| &mut m.asset_typ,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "asset_category",
                    |m: &AccountWithCashflows| &m.asset_category,
                    |m: &mut AccountWithCashflows| &mut m.asset_category,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "curr",
                    |m: &AccountWithCashflows| &m.curr,
                    |m: &mut AccountWithCashflows| &mut m.curr,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "coupon_classification_1",
                    |m: &AccountWithCashflows| &m.coupon_classification_1,
                    |m: &mut AccountWithCashflows| &mut m.coupon_classification_1,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "lst_rep_dt",
                    |m: &AccountWithCashflows| &m.lst_rep_dt,
                    |m: &mut AccountWithCashflows| &mut m.lst_rep_dt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "nxt_rep_dt",
                    |m: &AccountWithCashflows| &m.nxt_rep_dt,
                    |m: &mut AccountWithCashflows| &mut m.nxt_rep_dt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "m_duration",
                    |m: &AccountWithCashflows| &m.m_duration,
                    |m: &mut AccountWithCashflows| &mut m.m_duration,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "trsy_gl_cd",
                    |m: &AccountWithCashflows| &m.trsy_gl_cd,
                    |m: &mut AccountWithCashflows| &mut m.trsy_gl_cd,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cf_type",
                    |m: &AccountWithCashflows| &m.cf_type,
                    |m: &mut AccountWithCashflows| &mut m.cf_type,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cf_amt",
                    |m: &AccountWithCashflows| &m.cf_amt,
                    |m: &mut AccountWithCashflows| &mut m.cf_amt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cf_ccy",
                    |m: &AccountWithCashflows| &m.cf_ccy,
                    |m: &mut AccountWithCashflows| &mut m.cf_ccy,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeInt64,
                >(
                    "cf_dt",
                    |m: &AccountWithCashflows| &m.cf_dt,
                    |m: &mut AccountWithCashflows| &mut m.cf_dt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "prin_amt",
                    |m: &AccountWithCashflows| &m.prin_amt,
                    |m: &mut AccountWithCashflows| &mut m.prin_amt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "int_amt",
                    |m: &AccountWithCashflows| &m.int_amt,
                    |m: &mut AccountWithCashflows| &mut m.int_amt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "cbs_gl_cd",
                    |m: &AccountWithCashflows| &m.cbs_gl_cd,
                    |m: &mut AccountWithCashflows| &mut m.cbs_gl_cd,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "w4b_cd",
                    |m: &AccountWithCashflows| &m.w4b_cd,
                    |m: &mut AccountWithCashflows| &mut m.w4b_cd,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "balm_llg",
                    |m: &AccountWithCashflows| &m.balm_llg,
                    |m: &mut AccountWithCashflows| &mut m.balm_llg,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "care_llg",
                    |m: &AccountWithCashflows| &m.care_llg,
                    |m: &mut AccountWithCashflows| &mut m.care_llg,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeString,
                >(
                    "ba_llg",
                    |m: &AccountWithCashflows| &m.ba_llg,
                    |m: &mut AccountWithCashflows| &mut m.ba_llg,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "tot_prin_amt",
                    |m: &AccountWithCashflows| &m.tot_prin_amt,
                    |m: &mut AccountWithCashflows| &mut m.tot_prin_amt,
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<
                    _,
                    ::protobuf::types::ProtobufTypeDouble,
                >(
                    "tot_int_amt",
                    |m: &AccountWithCashflows| &m.tot_int_amt,
                    |m: &mut AccountWithCashflows| &mut m.tot_int_amt,
                ));
                fields.push(
                    ::protobuf::reflect::accessor::make_repeated_field_accessor::<
                        _,
                        ::protobuf::types::ProtobufTypeMessage<Cashflow>,
                    >(
                        "cashflows",
                        |m: &AccountWithCashflows| &m.cashflows,
                        |m: &mut AccountWithCashflows| &mut m.cashflows,
                    ),
                );
                ::protobuf::reflect::MessageDescriptor::new::<AccountWithCashflows>(
                    "AccountWithCashflows",
                    fields,
                    file_descriptor_proto(),
                )
            })
        }
    }

    fn default_instance() -> &'static AccountWithCashflows {
        static mut instance: ::protobuf::lazy::Lazy<AccountWithCashflows> =
            ::protobuf::lazy::Lazy {
                lock: ::protobuf::lazy::ONCE_INIT,
                ptr: 0 as *const AccountWithCashflows,
            };
        unsafe { instance.get(AccountWithCashflows::new) }
    }
}

impl ::protobuf::Clear for AccountWithCashflows {
    fn clear(&mut self) {
        self.clear_portfolio_num();
        self.clear_portfolio();
        self.clear_security_name();
        self.clear_maturity_dt();
        self.clear_coupon();
        self.clear_face_val_per_units();
        self.clear_quantity();
        self.clear_face_val();
        self.clear_wap();
        self.clear_book_val();
        self.clear_market_val();
        self.clear_mtm();
        self.clear_yeild();
        self.clear_appreciation();
        self.clear_depreciation();
        self.clear_net_appreciation_depreciation();
        self.clear_amort_as_on_dt();
        self.clear_accounted_amort();
        self.clear_un_accounted_amort();
        self.clear_accrued_int();
        self.clear_no_ca_skipped();
        self.clear_ca_int_not_receieved();
        self.clear_total_int();
        self.clear_inst_id();
        self.clear_inst_typ();
        self.clear_isin_code();
        self.clear_int_freq();
        self.clear_int_practice();
        self.clear_category();
        self.clear_sub_category();
        self.clear_put_dt();
        self.clear_call_dt();
        self.clear_lst_coupon();
        self.clear_nxt_coupon();
        self.clear_issue_dt();
        self.clear_place();
        self.clear_country();
        self.clear_booking_basis();
        self.clear_residual_maturity();
        self.clear_slr_non_slr();
        self.clear_listed();
        self.clear_issuer_name();
        self.clear_rating_agency();
        self.clear_rating();
        self.clear_market();
        self.clear_asset_classification();
        self.clear_gurantor();
        self.clear_industry();
        self.clear_sub_industry();
        self.clear_borrower_category();
        self.clear_asset_typ();
        self.clear_asset_category();
        self.clear_curr();
        self.clear_coupon_classification_1();
        self.clear_lst_rep_dt();
        self.clear_nxt_rep_dt();
        self.clear_m_duration();
        self.clear_trsy_gl_cd();
        self.clear_cf_type();
        self.clear_cf_amt();
        self.clear_cf_ccy();
        self.clear_cf_dt();
        self.clear_prin_amt();
        self.clear_int_amt();
        self.clear_cbs_gl_cd();
        self.clear_w4b_cd();
        self.clear_balm_llg();
        self.clear_care_llg();
        self.clear_ba_llg();
        self.clear_tot_prin_amt();
        self.clear_tot_int_amt();
        self.clear_cashflows();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountWithCashflows {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountWithCashflows {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\rmessage.proto\"R\n\x08Cashflow\x12\x17\n\x07int_amt\x18\x01\x20\x01(\
    \x01R\x06intAmt\x12\x19\n\x08prin_amt\x18\x02\x20\x01(\x01R\x07prinAmt\
    \x12\x12\n\x04date\x18\x03\x20\x01(\x03R\x04date\"\xf0\x11\n\x14AccountW\
    ithCashflows\x12#\n\rportfolio_num\x18\x01\x20\x01(\tR\x0cportfolioNum\
    \x12\x1c\n\tportfolio\x18\x02\x20\x01(\tR\tportfolio\x12#\n\rsecurity_na\
    me\x18\x03\x20\x01(\tR\x0csecurityName\x12\x1f\n\x0bmaturity_dt\x18\x04\
    \x20\x01(\x03R\nmaturityDt\x12\x16\n\x06coupon\x18\x05\x20\x01(\x01R\x06\
    coupon\x12+\n\x12face_val_per_units\x18\x06\x20\x01(\x01R\x0ffaceValPerU\
    nits\x12\x1a\n\x08quantity\x18\x07\x20\x01(\x01R\x08quantity\x12\x19\n\
    \x08face_val\x18\x08\x20\x01(\x01R\x07faceVal\x12\x10\n\x03wap\x18\t\x20\
    \x01(\x01R\x03wap\x12\x19\n\x08book_val\x18\n\x20\x01(\x01R\x07bookVal\
    \x12\x1d\n\nmarket_val\x18\x0b\x20\x01(\x01R\tmarketVal\x12\x10\n\x03mtm\
    \x18\x0c\x20\x01(\x01R\x03mtm\x12\x14\n\x05yeild\x18\r\x20\x01(\x01R\x05\
    yeild\x12\"\n\x0cappreciation\x18\x0e\x20\x01(\x01R\x0cappreciation\x12\
    \"\n\x0cdepreciation\x18\x0f\x20\x01(\x01R\x0cdepreciation\x12B\n\x1dnet\
    _appreciation_depreciation\x18\x10\x20\x01(\x01R\x1bnetAppreciationDepre\
    ciation\x12#\n\x0eamort_as_on_dt\x18\x11\x20\x01(\x01R\x0bamortAsOnDt\
    \x12'\n\x0faccounted_amort\x18\x12\x20\x01(\x01R\x0eaccountedAmort\x12,\
    \n\x12un_accounted_amort\x18\x13\x20\x01(\x01R\x10unAccountedAmort\x12\
    \x1f\n\x0baccrued_int\x18\x14\x20\x01(\x01R\naccruedInt\x12\"\n\rno_ca_s\
    kipped\x18\x15\x20\x01(\x01R\x0bnoCaSkipped\x12/\n\x14ca_int_not_receiev\
    ed\x18\x16\x20\x01(\x01R\x11caIntNotReceieved\x12\x1b\n\ttotal_int\x18\
    \x17\x20\x01(\x01R\x08totalInt\x12\x17\n\x07inst_id\x18\x18\x20\x01(\tR\
    \x06instId\x12\x19\n\x08inst_typ\x18\x19\x20\x01(\tR\x07instTyp\x12\x1b\
    \n\tisin_code\x18\x1a\x20\x01(\tR\x08isinCode\x12\x19\n\x08int_freq\x18\
    \x1b\x20\x01(\tR\x07intFreq\x12!\n\x0cint_practice\x18\x1c\x20\x01(\tR\
    \x0bintPractice\x12\x1a\n\x08category\x18\x1d\x20\x01(\tR\x08category\
    \x12!\n\x0csub_category\x18\x1e\x20\x01(\tR\x0bsubCategory\x12\x15\n\x06\
    put_dt\x18\x1f\x20\x01(\x03R\x05putDt\x12\x17\n\x07call_dt\x18\x20\x20\
    \x01(\x03R\x06callDt\x12\x1d\n\nlst_coupon\x18!\x20\x01(\x03R\tlstCoupon\
    \x12\x1d\n\nnxt_coupon\x18\"\x20\x01(\x03R\tnxtCoupon\x12\x19\n\x08issue\
    _dt\x18#\x20\x01(\x03R\x07issueDt\x12\x14\n\x05place\x18$\x20\x01(\tR\
    \x05place\x12\x18\n\x07country\x18%\x20\x01(\tR\x07country\x12#\n\rbooki\
    ng_basis\x18&\x20\x01(\tR\x0cbookingBasis\x12+\n\x11residual_maturity\
    \x18'\x20\x01(\x03R\x10residualMaturity\x12\x1e\n\x0bslr_non_slr\x18(\
    \x20\x01(\tR\tslrNonSlr\x12\x16\n\x06listed\x18)\x20\x01(\tR\x06listed\
    \x12\x1f\n\x0bissuer_name\x18*\x20\x01(\tR\nissuerName\x12#\n\rrating_ag\
    ency\x18+\x20\x01(\tR\x0cratingAgency\x12\x16\n\x06rating\x18,\x20\x01(\
    \tR\x06rating\x12\x16\n\x06market\x18-\x20\x01(\tR\x06market\x121\n\x14a\
    sset_classification\x18.\x20\x01(\tR\x13assetClassification\x12\x1a\n\
    \x08gurantor\x18/\x20\x01(\tR\x08gurantor\x12\x1a\n\x08industry\x180\x20\
    \x01(\tR\x08industry\x12!\n\x0csub_industry\x181\x20\x01(\tR\x0bsubIndus\
    try\x12+\n\x11borrower_category\x182\x20\x01(\tR\x10borrowerCategory\x12\
    \x1b\n\tasset_typ\x183\x20\x01(\tR\x08assetTyp\x12%\n\x0easset_category\
    \x184\x20\x01(\tR\rassetCategory\x12\x12\n\x04curr\x185\x20\x01(\tR\x04c\
    urr\x126\n\x17coupon_classification_1\x186\x20\x01(\tR\x15couponClassifi\
    cation1\x12\x1c\n\nlst_rep_dt\x187\x20\x01(\x03R\x08lstRepDt\x12\x1c\n\n\
    nxt_rep_dt\x188\x20\x01(\x03R\x08nxtRepDt\x12\x1d\n\nm_duration\x189\x20\
    \x01(\x01R\tmDuration\x12\x1c\n\ntrsy_gl_cd\x18:\x20\x01(\tR\x08trsyGlCd\
    \x12\x17\n\x07cf_type\x18;\x20\x01(\tR\x06cfType\x12\x15\n\x06cf_amt\x18\
    <\x20\x01(\tR\x05cfAmt\x12\x15\n\x06cf_ccy\x18=\x20\x01(\tR\x05cfCcy\x12\
    \x13\n\x05cf_dt\x18>\x20\x01(\x03R\x04cfDt\x12\x19\n\x08prin_amt\x18?\
    \x20\x01(\x01R\x07prinAmt\x12\x17\n\x07int_amt\x18@\x20\x01(\x01R\x06int\
    Amt\x12\x1a\n\tcbs_gl_cd\x18A\x20\x01(\tR\x07cbsGlCd\x12\x15\n\x06w4b_cd\
    \x18B\x20\x01(\tR\x05w4bCd\x12\x19\n\x08balm_llg\x18C\x20\x01(\tR\x07bal\
    mLlg\x12\x19\n\x08care_llg\x18D\x20\x01(\tR\x07careLlg\x12\x15\n\x06ba_l\
    lg\x18E\x20\x01(\tR\x05baLlg\x12\x20\n\x0ctot_prin_amt\x18F\x20\x01(\x01\
    R\ntotPrinAmt\x12\x1e\n\x0btot_int_amt\x18G\x20\x01(\x01R\ttotIntAmt\x12\
    '\n\tcashflows\x18H\x20\x03(\x0b2\t.CashflowR\tcashflowsb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<
    ::protobuf::descriptor::FileDescriptorProto,
> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe { file_descriptor_proto_lazy.get(|| parse_descriptor_proto()) }
}
