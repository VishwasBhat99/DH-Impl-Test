// This file is generated by rust-protobuf 2.28.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `maturity.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_28_0;

#[derive(PartialEq,Clone,Default)]
pub struct Cashflow {
    // message fields
    pub interest_amount: f64,
    pub principal_amount: f64,
    pub date: i64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Cashflow {
    fn default() -> &'a Cashflow {
        <Cashflow as ::protobuf::Message>::default_instance()
    }
}

impl Cashflow {
    pub fn new() -> Cashflow {
        ::std::default::Default::default()
    }

    // double interest_amount = 1;


    pub fn get_interest_amount(&self) -> f64 {
        self.interest_amount
    }
    pub fn clear_interest_amount(&mut self) {
        self.interest_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_interest_amount(&mut self, v: f64) {
        self.interest_amount = v;
    }

    // double principal_amount = 2;


    pub fn get_principal_amount(&self) -> f64 {
        self.principal_amount
    }
    pub fn clear_principal_amount(&mut self) {
        self.principal_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_principal_amount(&mut self, v: f64) {
        self.principal_amount = v;
    }

    // int64 date = 3;


    pub fn get_date(&self) -> i64 {
        self.date
    }
    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }
}

impl ::protobuf::Message for Cashflow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.interest_amount = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.principal_amount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.interest_amount != 0. {
            my_size += 9;
        }
        if self.principal_amount != 0. {
            my_size += 9;
        }
        if self.date != 0 {
            my_size += ::protobuf::rt::value_size(3, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.interest_amount != 0. {
            os.write_double(1, self.interest_amount)?;
        }
        if self.principal_amount != 0. {
            os.write_double(2, self.principal_amount)?;
        }
        if self.date != 0 {
            os.write_int64(3, self.date)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cashflow {
        Cashflow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "interest_amount",
                |m: &Cashflow| { &m.interest_amount },
                |m: &mut Cashflow| { &mut m.interest_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "principal_amount",
                |m: &Cashflow| { &m.principal_amount },
                |m: &mut Cashflow| { &mut m.principal_amount },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "date",
                |m: &Cashflow| { &m.date },
                |m: &mut Cashflow| { &mut m.date },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Cashflow>(
                "Cashflow",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Cashflow {
        static instance: ::protobuf::rt::LazyV2<Cashflow> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Cashflow::new)
    }
}

impl ::protobuf::Clear for Cashflow {
    fn clear(&mut self) {
        self.interest_amount = 0.;
        self.principal_amount = 0.;
        self.date = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cashflow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cashflow {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OutputAccount {
    // message fields
    pub cod_acc_no: ::std::string::String,
    pub cod_cc_brn: ::std::string::String,
    pub cod_prod: ::std::string::String,
    pub bal_book: f64,
    pub bal_book_lcy: f64,
    pub amt_od_lmt: f64,
    pub amt_od_lmt_lcy: f64,
    pub cod_cust: i64,
    pub cod_acc_title: ::std::string::String,
    pub dt_open_acc: i64,
    pub cod_int_accr_bas: ::std::string::String,
    pub freq_int_accr: ::std::string::String,
    pub dt_acc_close: i64,
    pub cod_collat_id: ::std::string::String,
    pub collat_desc: ::std::string::String,
    pub as_of_dt: i64,
    pub cost_cntr: ::std::string::String,
    pub gl_acc_no: ::std::string::String,
    pub rt_flg: ::std::string::String,
    pub inst: ::std::string::String,
    pub crnt_book_bal: f64,
    pub acrl_basis: ::std::string::String,
    pub int_rt: f64,
    pub div: ::std::string::String,
    pub alm_line: ::std::string::String,
    pub ia_llg: ::std::string::String,
    pub balm_llg: ::std::string::String,
    pub mis1: i64,
    pub npa_flg: ::std::string::String,
    pub benchmark: ::std::string::String,
    pub rep_freq: ::std::string::String,
    pub nxt_rep_dt: i64,
    pub lst_rep_dt: i64,
    pub cust_typ: ::std::string::String,
    pub country: ::std::string::String,
    pub bm_id_lookup: ::std::string::String,
    pub alm_concat: ::std::string::String,
    pub mis2_code: ::std::string::String,
    pub der_int_rate: f64,
    pub bnchmrk_rate: f64,
    pub spread: f64,
    pub fully_floating_flg: ::std::string::String,
    pub b1: f64,
    pub b2: f64,
    pub b3: f64,
    pub flg_frequency: f64,
    pub dat_start_frq: i64,
    pub dat_frq_last_reset: i64,
    pub dat_frq_next_reset: i64,
    pub rat_var_penalty: f64,
    pub sma_flag: ::std::string::String,
    pub cashflows: ::protobuf::RepeatedField<Cashflow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OutputAccount {
    fn default() -> &'a OutputAccount {
        <OutputAccount as ::protobuf::Message>::default_instance()
    }
}

impl OutputAccount {
    pub fn new() -> OutputAccount {
        ::std::default::Default::default()
    }

    // string cod_acc_no = 1;


    pub fn get_cod_acc_no(&self) -> &str {
        &self.cod_acc_no
    }
    pub fn clear_cod_acc_no(&mut self) {
        self.cod_acc_no.clear();
    }

    // Param is passed by value, moved
    pub fn set_cod_acc_no(&mut self, v: ::std::string::String) {
        self.cod_acc_no = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cod_acc_no(&mut self) -> &mut ::std::string::String {
        &mut self.cod_acc_no
    }

    // Take field
    pub fn take_cod_acc_no(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cod_acc_no, ::std::string::String::new())
    }

    // string cod_cc_brn = 2;


    pub fn get_cod_cc_brn(&self) -> &str {
        &self.cod_cc_brn
    }
    pub fn clear_cod_cc_brn(&mut self) {
        self.cod_cc_brn.clear();
    }

    // Param is passed by value, moved
    pub fn set_cod_cc_brn(&mut self, v: ::std::string::String) {
        self.cod_cc_brn = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cod_cc_brn(&mut self) -> &mut ::std::string::String {
        &mut self.cod_cc_brn
    }

    // Take field
    pub fn take_cod_cc_brn(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cod_cc_brn, ::std::string::String::new())
    }

    // string cod_prod = 3;


    pub fn get_cod_prod(&self) -> &str {
        &self.cod_prod
    }
    pub fn clear_cod_prod(&mut self) {
        self.cod_prod.clear();
    }

    // Param is passed by value, moved
    pub fn set_cod_prod(&mut self, v: ::std::string::String) {
        self.cod_prod = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cod_prod(&mut self) -> &mut ::std::string::String {
        &mut self.cod_prod
    }

    // Take field
    pub fn take_cod_prod(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cod_prod, ::std::string::String::new())
    }

    // double bal_book = 4;


    pub fn get_bal_book(&self) -> f64 {
        self.bal_book
    }
    pub fn clear_bal_book(&mut self) {
        self.bal_book = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bal_book(&mut self, v: f64) {
        self.bal_book = v;
    }

    // double bal_book_lcy = 5;


    pub fn get_bal_book_lcy(&self) -> f64 {
        self.bal_book_lcy
    }
    pub fn clear_bal_book_lcy(&mut self) {
        self.bal_book_lcy = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bal_book_lcy(&mut self, v: f64) {
        self.bal_book_lcy = v;
    }

    // double amt_od_lmt = 6;


    pub fn get_amt_od_lmt(&self) -> f64 {
        self.amt_od_lmt
    }
    pub fn clear_amt_od_lmt(&mut self) {
        self.amt_od_lmt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_amt_od_lmt(&mut self, v: f64) {
        self.amt_od_lmt = v;
    }

    // double amt_od_lmt_lcy = 7;


    pub fn get_amt_od_lmt_lcy(&self) -> f64 {
        self.amt_od_lmt_lcy
    }
    pub fn clear_amt_od_lmt_lcy(&mut self) {
        self.amt_od_lmt_lcy = 0.;
    }

    // Param is passed by value, moved
    pub fn set_amt_od_lmt_lcy(&mut self, v: f64) {
        self.amt_od_lmt_lcy = v;
    }

    // int64 cod_cust = 8;


    pub fn get_cod_cust(&self) -> i64 {
        self.cod_cust
    }
    pub fn clear_cod_cust(&mut self) {
        self.cod_cust = 0;
    }

    // Param is passed by value, moved
    pub fn set_cod_cust(&mut self, v: i64) {
        self.cod_cust = v;
    }

    // string cod_acc_title = 9;


    pub fn get_cod_acc_title(&self) -> &str {
        &self.cod_acc_title
    }
    pub fn clear_cod_acc_title(&mut self) {
        self.cod_acc_title.clear();
    }

    // Param is passed by value, moved
    pub fn set_cod_acc_title(&mut self, v: ::std::string::String) {
        self.cod_acc_title = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cod_acc_title(&mut self) -> &mut ::std::string::String {
        &mut self.cod_acc_title
    }

    // Take field
    pub fn take_cod_acc_title(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cod_acc_title, ::std::string::String::new())
    }

    // int64 dt_open_acc = 10;


    pub fn get_dt_open_acc(&self) -> i64 {
        self.dt_open_acc
    }
    pub fn clear_dt_open_acc(&mut self) {
        self.dt_open_acc = 0;
    }

    // Param is passed by value, moved
    pub fn set_dt_open_acc(&mut self, v: i64) {
        self.dt_open_acc = v;
    }

    // string cod_int_accr_bas = 11;


    pub fn get_cod_int_accr_bas(&self) -> &str {
        &self.cod_int_accr_bas
    }
    pub fn clear_cod_int_accr_bas(&mut self) {
        self.cod_int_accr_bas.clear();
    }

    // Param is passed by value, moved
    pub fn set_cod_int_accr_bas(&mut self, v: ::std::string::String) {
        self.cod_int_accr_bas = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cod_int_accr_bas(&mut self) -> &mut ::std::string::String {
        &mut self.cod_int_accr_bas
    }

    // Take field
    pub fn take_cod_int_accr_bas(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cod_int_accr_bas, ::std::string::String::new())
    }

    // string freq_int_accr = 12;


    pub fn get_freq_int_accr(&self) -> &str {
        &self.freq_int_accr
    }
    pub fn clear_freq_int_accr(&mut self) {
        self.freq_int_accr.clear();
    }

    // Param is passed by value, moved
    pub fn set_freq_int_accr(&mut self, v: ::std::string::String) {
        self.freq_int_accr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_freq_int_accr(&mut self) -> &mut ::std::string::String {
        &mut self.freq_int_accr
    }

    // Take field
    pub fn take_freq_int_accr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.freq_int_accr, ::std::string::String::new())
    }

    // int64 dt_acc_close = 13;


    pub fn get_dt_acc_close(&self) -> i64 {
        self.dt_acc_close
    }
    pub fn clear_dt_acc_close(&mut self) {
        self.dt_acc_close = 0;
    }

    // Param is passed by value, moved
    pub fn set_dt_acc_close(&mut self, v: i64) {
        self.dt_acc_close = v;
    }

    // string cod_collat_id = 14;


    pub fn get_cod_collat_id(&self) -> &str {
        &self.cod_collat_id
    }
    pub fn clear_cod_collat_id(&mut self) {
        self.cod_collat_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_cod_collat_id(&mut self, v: ::std::string::String) {
        self.cod_collat_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cod_collat_id(&mut self) -> &mut ::std::string::String {
        &mut self.cod_collat_id
    }

    // Take field
    pub fn take_cod_collat_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cod_collat_id, ::std::string::String::new())
    }

    // string collat_desc = 15;


    pub fn get_collat_desc(&self) -> &str {
        &self.collat_desc
    }
    pub fn clear_collat_desc(&mut self) {
        self.collat_desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_collat_desc(&mut self, v: ::std::string::String) {
        self.collat_desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_collat_desc(&mut self) -> &mut ::std::string::String {
        &mut self.collat_desc
    }

    // Take field
    pub fn take_collat_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.collat_desc, ::std::string::String::new())
    }

    // int64 as_of_dt = 16;


    pub fn get_as_of_dt(&self) -> i64 {
        self.as_of_dt
    }
    pub fn clear_as_of_dt(&mut self) {
        self.as_of_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_as_of_dt(&mut self, v: i64) {
        self.as_of_dt = v;
    }

    // string cost_cntr = 17;


    pub fn get_cost_cntr(&self) -> &str {
        &self.cost_cntr
    }
    pub fn clear_cost_cntr(&mut self) {
        self.cost_cntr.clear();
    }

    // Param is passed by value, moved
    pub fn set_cost_cntr(&mut self, v: ::std::string::String) {
        self.cost_cntr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cost_cntr(&mut self) -> &mut ::std::string::String {
        &mut self.cost_cntr
    }

    // Take field
    pub fn take_cost_cntr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cost_cntr, ::std::string::String::new())
    }

    // string gl_acc_no = 18;


    pub fn get_gl_acc_no(&self) -> &str {
        &self.gl_acc_no
    }
    pub fn clear_gl_acc_no(&mut self) {
        self.gl_acc_no.clear();
    }

    // Param is passed by value, moved
    pub fn set_gl_acc_no(&mut self, v: ::std::string::String) {
        self.gl_acc_no = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gl_acc_no(&mut self) -> &mut ::std::string::String {
        &mut self.gl_acc_no
    }

    // Take field
    pub fn take_gl_acc_no(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.gl_acc_no, ::std::string::String::new())
    }

    // string rt_flg = 19;


    pub fn get_rt_flg(&self) -> &str {
        &self.rt_flg
    }
    pub fn clear_rt_flg(&mut self) {
        self.rt_flg.clear();
    }

    // Param is passed by value, moved
    pub fn set_rt_flg(&mut self, v: ::std::string::String) {
        self.rt_flg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rt_flg(&mut self) -> &mut ::std::string::String {
        &mut self.rt_flg
    }

    // Take field
    pub fn take_rt_flg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rt_flg, ::std::string::String::new())
    }

    // string inst = 20;


    pub fn get_inst(&self) -> &str {
        &self.inst
    }
    pub fn clear_inst(&mut self) {
        self.inst.clear();
    }

    // Param is passed by value, moved
    pub fn set_inst(&mut self, v: ::std::string::String) {
        self.inst = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inst(&mut self) -> &mut ::std::string::String {
        &mut self.inst
    }

    // Take field
    pub fn take_inst(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.inst, ::std::string::String::new())
    }

    // double crnt_book_bal = 21;


    pub fn get_crnt_book_bal(&self) -> f64 {
        self.crnt_book_bal
    }
    pub fn clear_crnt_book_bal(&mut self) {
        self.crnt_book_bal = 0.;
    }

    // Param is passed by value, moved
    pub fn set_crnt_book_bal(&mut self, v: f64) {
        self.crnt_book_bal = v;
    }

    // string acrl_basis = 22;


    pub fn get_acrl_basis(&self) -> &str {
        &self.acrl_basis
    }
    pub fn clear_acrl_basis(&mut self) {
        self.acrl_basis.clear();
    }

    // Param is passed by value, moved
    pub fn set_acrl_basis(&mut self, v: ::std::string::String) {
        self.acrl_basis = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acrl_basis(&mut self) -> &mut ::std::string::String {
        &mut self.acrl_basis
    }

    // Take field
    pub fn take_acrl_basis(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.acrl_basis, ::std::string::String::new())
    }

    // double int_rt = 23;


    pub fn get_int_rt(&self) -> f64 {
        self.int_rt
    }
    pub fn clear_int_rt(&mut self) {
        self.int_rt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_int_rt(&mut self, v: f64) {
        self.int_rt = v;
    }

    // string div = 24;


    pub fn get_div(&self) -> &str {
        &self.div
    }
    pub fn clear_div(&mut self) {
        self.div.clear();
    }

    // Param is passed by value, moved
    pub fn set_div(&mut self, v: ::std::string::String) {
        self.div = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_div(&mut self) -> &mut ::std::string::String {
        &mut self.div
    }

    // Take field
    pub fn take_div(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.div, ::std::string::String::new())
    }

    // string alm_line = 25;


    pub fn get_alm_line(&self) -> &str {
        &self.alm_line
    }
    pub fn clear_alm_line(&mut self) {
        self.alm_line.clear();
    }

    // Param is passed by value, moved
    pub fn set_alm_line(&mut self, v: ::std::string::String) {
        self.alm_line = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alm_line(&mut self) -> &mut ::std::string::String {
        &mut self.alm_line
    }

    // Take field
    pub fn take_alm_line(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alm_line, ::std::string::String::new())
    }

    // string ia_llg = 26;


    pub fn get_ia_llg(&self) -> &str {
        &self.ia_llg
    }
    pub fn clear_ia_llg(&mut self) {
        self.ia_llg.clear();
    }

    // Param is passed by value, moved
    pub fn set_ia_llg(&mut self, v: ::std::string::String) {
        self.ia_llg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ia_llg(&mut self) -> &mut ::std::string::String {
        &mut self.ia_llg
    }

    // Take field
    pub fn take_ia_llg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ia_llg, ::std::string::String::new())
    }

    // string balm_llg = 27;


    pub fn get_balm_llg(&self) -> &str {
        &self.balm_llg
    }
    pub fn clear_balm_llg(&mut self) {
        self.balm_llg.clear();
    }

    // Param is passed by value, moved
    pub fn set_balm_llg(&mut self, v: ::std::string::String) {
        self.balm_llg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balm_llg(&mut self) -> &mut ::std::string::String {
        &mut self.balm_llg
    }

    // Take field
    pub fn take_balm_llg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.balm_llg, ::std::string::String::new())
    }

    // int64 mis1 = 28;


    pub fn get_mis1(&self) -> i64 {
        self.mis1
    }
    pub fn clear_mis1(&mut self) {
        self.mis1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_mis1(&mut self, v: i64) {
        self.mis1 = v;
    }

    // string npa_flg = 29;


    pub fn get_npa_flg(&self) -> &str {
        &self.npa_flg
    }
    pub fn clear_npa_flg(&mut self) {
        self.npa_flg.clear();
    }

    // Param is passed by value, moved
    pub fn set_npa_flg(&mut self, v: ::std::string::String) {
        self.npa_flg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npa_flg(&mut self) -> &mut ::std::string::String {
        &mut self.npa_flg
    }

    // Take field
    pub fn take_npa_flg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.npa_flg, ::std::string::String::new())
    }

    // string benchmark = 30;


    pub fn get_benchmark(&self) -> &str {
        &self.benchmark
    }
    pub fn clear_benchmark(&mut self) {
        self.benchmark.clear();
    }

    // Param is passed by value, moved
    pub fn set_benchmark(&mut self, v: ::std::string::String) {
        self.benchmark = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_benchmark(&mut self) -> &mut ::std::string::String {
        &mut self.benchmark
    }

    // Take field
    pub fn take_benchmark(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.benchmark, ::std::string::String::new())
    }

    // string rep_freq = 31;


    pub fn get_rep_freq(&self) -> &str {
        &self.rep_freq
    }
    pub fn clear_rep_freq(&mut self) {
        self.rep_freq.clear();
    }

    // Param is passed by value, moved
    pub fn set_rep_freq(&mut self, v: ::std::string::String) {
        self.rep_freq = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rep_freq(&mut self) -> &mut ::std::string::String {
        &mut self.rep_freq
    }

    // Take field
    pub fn take_rep_freq(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rep_freq, ::std::string::String::new())
    }

    // int64 nxt_rep_dt = 32;


    pub fn get_nxt_rep_dt(&self) -> i64 {
        self.nxt_rep_dt
    }
    pub fn clear_nxt_rep_dt(&mut self) {
        self.nxt_rep_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_nxt_rep_dt(&mut self, v: i64) {
        self.nxt_rep_dt = v;
    }

    // int64 lst_rep_dt = 33;


    pub fn get_lst_rep_dt(&self) -> i64 {
        self.lst_rep_dt
    }
    pub fn clear_lst_rep_dt(&mut self) {
        self.lst_rep_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_lst_rep_dt(&mut self, v: i64) {
        self.lst_rep_dt = v;
    }

    // string cust_typ = 34;


    pub fn get_cust_typ(&self) -> &str {
        &self.cust_typ
    }
    pub fn clear_cust_typ(&mut self) {
        self.cust_typ.clear();
    }

    // Param is passed by value, moved
    pub fn set_cust_typ(&mut self, v: ::std::string::String) {
        self.cust_typ = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cust_typ(&mut self) -> &mut ::std::string::String {
        &mut self.cust_typ
    }

    // Take field
    pub fn take_cust_typ(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.cust_typ, ::std::string::String::new())
    }

    // string country = 35;


    pub fn get_country(&self) -> &str {
        &self.country
    }
    pub fn clear_country(&mut self) {
        self.country.clear();
    }

    // Param is passed by value, moved
    pub fn set_country(&mut self, v: ::std::string::String) {
        self.country = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country(&mut self) -> &mut ::std::string::String {
        &mut self.country
    }

    // Take field
    pub fn take_country(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.country, ::std::string::String::new())
    }

    // string bm_id_lookup = 36;


    pub fn get_bm_id_lookup(&self) -> &str {
        &self.bm_id_lookup
    }
    pub fn clear_bm_id_lookup(&mut self) {
        self.bm_id_lookup.clear();
    }

    // Param is passed by value, moved
    pub fn set_bm_id_lookup(&mut self, v: ::std::string::String) {
        self.bm_id_lookup = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bm_id_lookup(&mut self) -> &mut ::std::string::String {
        &mut self.bm_id_lookup
    }

    // Take field
    pub fn take_bm_id_lookup(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bm_id_lookup, ::std::string::String::new())
    }

    // string alm_concat = 37;


    pub fn get_alm_concat(&self) -> &str {
        &self.alm_concat
    }
    pub fn clear_alm_concat(&mut self) {
        self.alm_concat.clear();
    }

    // Param is passed by value, moved
    pub fn set_alm_concat(&mut self, v: ::std::string::String) {
        self.alm_concat = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alm_concat(&mut self) -> &mut ::std::string::String {
        &mut self.alm_concat
    }

    // Take field
    pub fn take_alm_concat(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alm_concat, ::std::string::String::new())
    }

    // string mis2_code = 38;


    pub fn get_mis2_code(&self) -> &str {
        &self.mis2_code
    }
    pub fn clear_mis2_code(&mut self) {
        self.mis2_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_mis2_code(&mut self, v: ::std::string::String) {
        self.mis2_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mis2_code(&mut self) -> &mut ::std::string::String {
        &mut self.mis2_code
    }

    // Take field
    pub fn take_mis2_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mis2_code, ::std::string::String::new())
    }

    // double der_int_rate = 39;


    pub fn get_der_int_rate(&self) -> f64 {
        self.der_int_rate
    }
    pub fn clear_der_int_rate(&mut self) {
        self.der_int_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_der_int_rate(&mut self, v: f64) {
        self.der_int_rate = v;
    }

    // double bnchmrk_rate = 40;


    pub fn get_bnchmrk_rate(&self) -> f64 {
        self.bnchmrk_rate
    }
    pub fn clear_bnchmrk_rate(&mut self) {
        self.bnchmrk_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_bnchmrk_rate(&mut self, v: f64) {
        self.bnchmrk_rate = v;
    }

    // double spread = 41;


    pub fn get_spread(&self) -> f64 {
        self.spread
    }
    pub fn clear_spread(&mut self) {
        self.spread = 0.;
    }

    // Param is passed by value, moved
    pub fn set_spread(&mut self, v: f64) {
        self.spread = v;
    }

    // string fully_floating_flg = 42;


    pub fn get_fully_floating_flg(&self) -> &str {
        &self.fully_floating_flg
    }
    pub fn clear_fully_floating_flg(&mut self) {
        self.fully_floating_flg.clear();
    }

    // Param is passed by value, moved
    pub fn set_fully_floating_flg(&mut self, v: ::std::string::String) {
        self.fully_floating_flg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fully_floating_flg(&mut self) -> &mut ::std::string::String {
        &mut self.fully_floating_flg
    }

    // Take field
    pub fn take_fully_floating_flg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.fully_floating_flg, ::std::string::String::new())
    }

    // double b1 = 43;


    pub fn get_b1(&self) -> f64 {
        self.b1
    }
    pub fn clear_b1(&mut self) {
        self.b1 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_b1(&mut self, v: f64) {
        self.b1 = v;
    }

    // double b2 = 44;


    pub fn get_b2(&self) -> f64 {
        self.b2
    }
    pub fn clear_b2(&mut self) {
        self.b2 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_b2(&mut self, v: f64) {
        self.b2 = v;
    }

    // double b3 = 45;


    pub fn get_b3(&self) -> f64 {
        self.b3
    }
    pub fn clear_b3(&mut self) {
        self.b3 = 0.;
    }

    // Param is passed by value, moved
    pub fn set_b3(&mut self, v: f64) {
        self.b3 = v;
    }

    // double flg_frequency = 46;


    pub fn get_flg_frequency(&self) -> f64 {
        self.flg_frequency
    }
    pub fn clear_flg_frequency(&mut self) {
        self.flg_frequency = 0.;
    }

    // Param is passed by value, moved
    pub fn set_flg_frequency(&mut self, v: f64) {
        self.flg_frequency = v;
    }

    // int64 dat_start_frq = 47;


    pub fn get_dat_start_frq(&self) -> i64 {
        self.dat_start_frq
    }
    pub fn clear_dat_start_frq(&mut self) {
        self.dat_start_frq = 0;
    }

    // Param is passed by value, moved
    pub fn set_dat_start_frq(&mut self, v: i64) {
        self.dat_start_frq = v;
    }

    // int64 dat_frq_last_reset = 48;


    pub fn get_dat_frq_last_reset(&self) -> i64 {
        self.dat_frq_last_reset
    }
    pub fn clear_dat_frq_last_reset(&mut self) {
        self.dat_frq_last_reset = 0;
    }

    // Param is passed by value, moved
    pub fn set_dat_frq_last_reset(&mut self, v: i64) {
        self.dat_frq_last_reset = v;
    }

    // int64 dat_frq_next_reset = 49;


    pub fn get_dat_frq_next_reset(&self) -> i64 {
        self.dat_frq_next_reset
    }
    pub fn clear_dat_frq_next_reset(&mut self) {
        self.dat_frq_next_reset = 0;
    }

    // Param is passed by value, moved
    pub fn set_dat_frq_next_reset(&mut self, v: i64) {
        self.dat_frq_next_reset = v;
    }

    // double rat_var_penalty = 50;


    pub fn get_rat_var_penalty(&self) -> f64 {
        self.rat_var_penalty
    }
    pub fn clear_rat_var_penalty(&mut self) {
        self.rat_var_penalty = 0.;
    }

    // Param is passed by value, moved
    pub fn set_rat_var_penalty(&mut self, v: f64) {
        self.rat_var_penalty = v;
    }

    // string sma_flag = 51;


    pub fn get_sma_flag(&self) -> &str {
        &self.sma_flag
    }
    pub fn clear_sma_flag(&mut self) {
        self.sma_flag.clear();
    }

    // Param is passed by value, moved
    pub fn set_sma_flag(&mut self, v: ::std::string::String) {
        self.sma_flag = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sma_flag(&mut self) -> &mut ::std::string::String {
        &mut self.sma_flag
    }

    // Take field
    pub fn take_sma_flag(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sma_flag, ::std::string::String::new())
    }

    // repeated .Cashflow cashflows = 52;


    pub fn get_cashflows(&self) -> &[Cashflow] {
        &self.cashflows
    }
    pub fn clear_cashflows(&mut self) {
        self.cashflows.clear();
    }

    // Param is passed by value, moved
    pub fn set_cashflows(&mut self, v: ::protobuf::RepeatedField<Cashflow>) {
        self.cashflows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cashflows(&mut self) -> &mut ::protobuf::RepeatedField<Cashflow> {
        &mut self.cashflows
    }

    // Take field
    pub fn take_cashflows(&mut self) -> ::protobuf::RepeatedField<Cashflow> {
        ::std::mem::replace(&mut self.cashflows, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for OutputAccount {
    fn is_initialized(&self) -> bool {
        for v in &self.cashflows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cod_acc_no)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cod_cc_brn)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cod_prod)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.bal_book = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.bal_book_lcy = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.amt_od_lmt = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.amt_od_lmt_lcy = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cod_cust = tmp;
                },
                9 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cod_acc_title)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dt_open_acc = tmp;
                },
                11 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cod_int_accr_bas)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.freq_int_accr)?;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dt_acc_close = tmp;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cod_collat_id)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.collat_desc)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.as_of_dt = tmp;
                },
                17 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cost_cntr)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.gl_acc_no)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rt_flg)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.inst)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.crnt_book_bal = tmp;
                },
                22 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.acrl_basis)?;
                },
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.int_rt = tmp;
                },
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.div)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alm_line)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ia_llg)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.balm_llg)?;
                },
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.mis1 = tmp;
                },
                29 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.npa_flg)?;
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.benchmark)?;
                },
                31 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rep_freq)?;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nxt_rep_dt = tmp;
                },
                33 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lst_rep_dt = tmp;
                },
                34 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.cust_typ)?;
                },
                35 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.country)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bm_id_lookup)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alm_concat)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mis2_code)?;
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.der_int_rate = tmp;
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.bnchmrk_rate = tmp;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.spread = tmp;
                },
                42 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.fully_floating_flg)?;
                },
                43 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.b1 = tmp;
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.b2 = tmp;
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.b3 = tmp;
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.flg_frequency = tmp;
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dat_start_frq = tmp;
                },
                48 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dat_frq_last_reset = tmp;
                },
                49 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.dat_frq_next_reset = tmp;
                },
                50 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.rat_var_penalty = tmp;
                },
                51 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sma_flag)?;
                },
                52 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cashflows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.cod_acc_no.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.cod_acc_no);
        }
        if !self.cod_cc_brn.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.cod_cc_brn);
        }
        if !self.cod_prod.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.cod_prod);
        }
        if self.bal_book != 0. {
            my_size += 9;
        }
        if self.bal_book_lcy != 0. {
            my_size += 9;
        }
        if self.amt_od_lmt != 0. {
            my_size += 9;
        }
        if self.amt_od_lmt_lcy != 0. {
            my_size += 9;
        }
        if self.cod_cust != 0 {
            my_size += ::protobuf::rt::value_size(8, self.cod_cust, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.cod_acc_title.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.cod_acc_title);
        }
        if self.dt_open_acc != 0 {
            my_size += ::protobuf::rt::value_size(10, self.dt_open_acc, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.cod_int_accr_bas.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.cod_int_accr_bas);
        }
        if !self.freq_int_accr.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.freq_int_accr);
        }
        if self.dt_acc_close != 0 {
            my_size += ::protobuf::rt::value_size(13, self.dt_acc_close, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.cod_collat_id.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.cod_collat_id);
        }
        if !self.collat_desc.is_empty() {
            my_size += ::protobuf::rt::string_size(15, &self.collat_desc);
        }
        if self.as_of_dt != 0 {
            my_size += ::protobuf::rt::value_size(16, self.as_of_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.cost_cntr.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.cost_cntr);
        }
        if !self.gl_acc_no.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.gl_acc_no);
        }
        if !self.rt_flg.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.rt_flg);
        }
        if !self.inst.is_empty() {
            my_size += ::protobuf::rt::string_size(20, &self.inst);
        }
        if self.crnt_book_bal != 0. {
            my_size += 10;
        }
        if !self.acrl_basis.is_empty() {
            my_size += ::protobuf::rt::string_size(22, &self.acrl_basis);
        }
        if self.int_rt != 0. {
            my_size += 10;
        }
        if !self.div.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.div);
        }
        if !self.alm_line.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.alm_line);
        }
        if !self.ia_llg.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.ia_llg);
        }
        if !self.balm_llg.is_empty() {
            my_size += ::protobuf::rt::string_size(27, &self.balm_llg);
        }
        if self.mis1 != 0 {
            my_size += ::protobuf::rt::value_size(28, self.mis1, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.npa_flg.is_empty() {
            my_size += ::protobuf::rt::string_size(29, &self.npa_flg);
        }
        if !self.benchmark.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.benchmark);
        }
        if !self.rep_freq.is_empty() {
            my_size += ::protobuf::rt::string_size(31, &self.rep_freq);
        }
        if self.nxt_rep_dt != 0 {
            my_size += ::protobuf::rt::value_size(32, self.nxt_rep_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lst_rep_dt != 0 {
            my_size += ::protobuf::rt::value_size(33, self.lst_rep_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.cust_typ.is_empty() {
            my_size += ::protobuf::rt::string_size(34, &self.cust_typ);
        }
        if !self.country.is_empty() {
            my_size += ::protobuf::rt::string_size(35, &self.country);
        }
        if !self.bm_id_lookup.is_empty() {
            my_size += ::protobuf::rt::string_size(36, &self.bm_id_lookup);
        }
        if !self.alm_concat.is_empty() {
            my_size += ::protobuf::rt::string_size(37, &self.alm_concat);
        }
        if !self.mis2_code.is_empty() {
            my_size += ::protobuf::rt::string_size(38, &self.mis2_code);
        }
        if self.der_int_rate != 0. {
            my_size += 10;
        }
        if self.bnchmrk_rate != 0. {
            my_size += 10;
        }
        if self.spread != 0. {
            my_size += 10;
        }
        if !self.fully_floating_flg.is_empty() {
            my_size += ::protobuf::rt::string_size(42, &self.fully_floating_flg);
        }
        if self.b1 != 0. {
            my_size += 10;
        }
        if self.b2 != 0. {
            my_size += 10;
        }
        if self.b3 != 0. {
            my_size += 10;
        }
        if self.flg_frequency != 0. {
            my_size += 10;
        }
        if self.dat_start_frq != 0 {
            my_size += ::protobuf::rt::value_size(47, self.dat_start_frq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dat_frq_last_reset != 0 {
            my_size += ::protobuf::rt::value_size(48, self.dat_frq_last_reset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.dat_frq_next_reset != 0 {
            my_size += ::protobuf::rt::value_size(49, self.dat_frq_next_reset, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rat_var_penalty != 0. {
            my_size += 10;
        }
        if !self.sma_flag.is_empty() {
            my_size += ::protobuf::rt::string_size(51, &self.sma_flag);
        }
        for value in &self.cashflows {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.cod_acc_no.is_empty() {
            os.write_string(1, &self.cod_acc_no)?;
        }
        if !self.cod_cc_brn.is_empty() {
            os.write_string(2, &self.cod_cc_brn)?;
        }
        if !self.cod_prod.is_empty() {
            os.write_string(3, &self.cod_prod)?;
        }
        if self.bal_book != 0. {
            os.write_double(4, self.bal_book)?;
        }
        if self.bal_book_lcy != 0. {
            os.write_double(5, self.bal_book_lcy)?;
        }
        if self.amt_od_lmt != 0. {
            os.write_double(6, self.amt_od_lmt)?;
        }
        if self.amt_od_lmt_lcy != 0. {
            os.write_double(7, self.amt_od_lmt_lcy)?;
        }
        if self.cod_cust != 0 {
            os.write_int64(8, self.cod_cust)?;
        }
        if !self.cod_acc_title.is_empty() {
            os.write_string(9, &self.cod_acc_title)?;
        }
        if self.dt_open_acc != 0 {
            os.write_int64(10, self.dt_open_acc)?;
        }
        if !self.cod_int_accr_bas.is_empty() {
            os.write_string(11, &self.cod_int_accr_bas)?;
        }
        if !self.freq_int_accr.is_empty() {
            os.write_string(12, &self.freq_int_accr)?;
        }
        if self.dt_acc_close != 0 {
            os.write_int64(13, self.dt_acc_close)?;
        }
        if !self.cod_collat_id.is_empty() {
            os.write_string(14, &self.cod_collat_id)?;
        }
        if !self.collat_desc.is_empty() {
            os.write_string(15, &self.collat_desc)?;
        }
        if self.as_of_dt != 0 {
            os.write_int64(16, self.as_of_dt)?;
        }
        if !self.cost_cntr.is_empty() {
            os.write_string(17, &self.cost_cntr)?;
        }
        if !self.gl_acc_no.is_empty() {
            os.write_string(18, &self.gl_acc_no)?;
        }
        if !self.rt_flg.is_empty() {
            os.write_string(19, &self.rt_flg)?;
        }
        if !self.inst.is_empty() {
            os.write_string(20, &self.inst)?;
        }
        if self.crnt_book_bal != 0. {
            os.write_double(21, self.crnt_book_bal)?;
        }
        if !self.acrl_basis.is_empty() {
            os.write_string(22, &self.acrl_basis)?;
        }
        if self.int_rt != 0. {
            os.write_double(23, self.int_rt)?;
        }
        if !self.div.is_empty() {
            os.write_string(24, &self.div)?;
        }
        if !self.alm_line.is_empty() {
            os.write_string(25, &self.alm_line)?;
        }
        if !self.ia_llg.is_empty() {
            os.write_string(26, &self.ia_llg)?;
        }
        if !self.balm_llg.is_empty() {
            os.write_string(27, &self.balm_llg)?;
        }
        if self.mis1 != 0 {
            os.write_int64(28, self.mis1)?;
        }
        if !self.npa_flg.is_empty() {
            os.write_string(29, &self.npa_flg)?;
        }
        if !self.benchmark.is_empty() {
            os.write_string(30, &self.benchmark)?;
        }
        if !self.rep_freq.is_empty() {
            os.write_string(31, &self.rep_freq)?;
        }
        if self.nxt_rep_dt != 0 {
            os.write_int64(32, self.nxt_rep_dt)?;
        }
        if self.lst_rep_dt != 0 {
            os.write_int64(33, self.lst_rep_dt)?;
        }
        if !self.cust_typ.is_empty() {
            os.write_string(34, &self.cust_typ)?;
        }
        if !self.country.is_empty() {
            os.write_string(35, &self.country)?;
        }
        if !self.bm_id_lookup.is_empty() {
            os.write_string(36, &self.bm_id_lookup)?;
        }
        if !self.alm_concat.is_empty() {
            os.write_string(37, &self.alm_concat)?;
        }
        if !self.mis2_code.is_empty() {
            os.write_string(38, &self.mis2_code)?;
        }
        if self.der_int_rate != 0. {
            os.write_double(39, self.der_int_rate)?;
        }
        if self.bnchmrk_rate != 0. {
            os.write_double(40, self.bnchmrk_rate)?;
        }
        if self.spread != 0. {
            os.write_double(41, self.spread)?;
        }
        if !self.fully_floating_flg.is_empty() {
            os.write_string(42, &self.fully_floating_flg)?;
        }
        if self.b1 != 0. {
            os.write_double(43, self.b1)?;
        }
        if self.b2 != 0. {
            os.write_double(44, self.b2)?;
        }
        if self.b3 != 0. {
            os.write_double(45, self.b3)?;
        }
        if self.flg_frequency != 0. {
            os.write_double(46, self.flg_frequency)?;
        }
        if self.dat_start_frq != 0 {
            os.write_int64(47, self.dat_start_frq)?;
        }
        if self.dat_frq_last_reset != 0 {
            os.write_int64(48, self.dat_frq_last_reset)?;
        }
        if self.dat_frq_next_reset != 0 {
            os.write_int64(49, self.dat_frq_next_reset)?;
        }
        if self.rat_var_penalty != 0. {
            os.write_double(50, self.rat_var_penalty)?;
        }
        if !self.sma_flag.is_empty() {
            os.write_string(51, &self.sma_flag)?;
        }
        for v in &self.cashflows {
            os.write_tag(52, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OutputAccount {
        OutputAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cod_acc_no",
                |m: &OutputAccount| { &m.cod_acc_no },
                |m: &mut OutputAccount| { &mut m.cod_acc_no },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cod_cc_brn",
                |m: &OutputAccount| { &m.cod_cc_brn },
                |m: &mut OutputAccount| { &mut m.cod_cc_brn },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cod_prod",
                |m: &OutputAccount| { &m.cod_prod },
                |m: &mut OutputAccount| { &mut m.cod_prod },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bal_book",
                |m: &OutputAccount| { &m.bal_book },
                |m: &mut OutputAccount| { &mut m.bal_book },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bal_book_lcy",
                |m: &OutputAccount| { &m.bal_book_lcy },
                |m: &mut OutputAccount| { &mut m.bal_book_lcy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "amt_od_lmt",
                |m: &OutputAccount| { &m.amt_od_lmt },
                |m: &mut OutputAccount| { &mut m.amt_od_lmt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "amt_od_lmt_lcy",
                |m: &OutputAccount| { &m.amt_od_lmt_lcy },
                |m: &mut OutputAccount| { &mut m.amt_od_lmt_lcy },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "cod_cust",
                |m: &OutputAccount| { &m.cod_cust },
                |m: &mut OutputAccount| { &mut m.cod_cust },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cod_acc_title",
                |m: &OutputAccount| { &m.cod_acc_title },
                |m: &mut OutputAccount| { &mut m.cod_acc_title },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dt_open_acc",
                |m: &OutputAccount| { &m.dt_open_acc },
                |m: &mut OutputAccount| { &mut m.dt_open_acc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cod_int_accr_bas",
                |m: &OutputAccount| { &m.cod_int_accr_bas },
                |m: &mut OutputAccount| { &mut m.cod_int_accr_bas },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "freq_int_accr",
                |m: &OutputAccount| { &m.freq_int_accr },
                |m: &mut OutputAccount| { &mut m.freq_int_accr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dt_acc_close",
                |m: &OutputAccount| { &m.dt_acc_close },
                |m: &mut OutputAccount| { &mut m.dt_acc_close },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cod_collat_id",
                |m: &OutputAccount| { &m.cod_collat_id },
                |m: &mut OutputAccount| { &mut m.cod_collat_id },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "collat_desc",
                |m: &OutputAccount| { &m.collat_desc },
                |m: &mut OutputAccount| { &mut m.collat_desc },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "as_of_dt",
                |m: &OutputAccount| { &m.as_of_dt },
                |m: &mut OutputAccount| { &mut m.as_of_dt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cost_cntr",
                |m: &OutputAccount| { &m.cost_cntr },
                |m: &mut OutputAccount| { &mut m.cost_cntr },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gl_acc_no",
                |m: &OutputAccount| { &m.gl_acc_no },
                |m: &mut OutputAccount| { &mut m.gl_acc_no },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rt_flg",
                |m: &OutputAccount| { &m.rt_flg },
                |m: &mut OutputAccount| { &mut m.rt_flg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "inst",
                |m: &OutputAccount| { &m.inst },
                |m: &mut OutputAccount| { &mut m.inst },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "crnt_book_bal",
                |m: &OutputAccount| { &m.crnt_book_bal },
                |m: &mut OutputAccount| { &mut m.crnt_book_bal },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "acrl_basis",
                |m: &OutputAccount| { &m.acrl_basis },
                |m: &mut OutputAccount| { &mut m.acrl_basis },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "int_rt",
                |m: &OutputAccount| { &m.int_rt },
                |m: &mut OutputAccount| { &mut m.int_rt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "div",
                |m: &OutputAccount| { &m.div },
                |m: &mut OutputAccount| { &mut m.div },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "alm_line",
                |m: &OutputAccount| { &m.alm_line },
                |m: &mut OutputAccount| { &mut m.alm_line },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ia_llg",
                |m: &OutputAccount| { &m.ia_llg },
                |m: &mut OutputAccount| { &mut m.ia_llg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "balm_llg",
                |m: &OutputAccount| { &m.balm_llg },
                |m: &mut OutputAccount| { &mut m.balm_llg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "mis1",
                |m: &OutputAccount| { &m.mis1 },
                |m: &mut OutputAccount| { &mut m.mis1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "npa_flg",
                |m: &OutputAccount| { &m.npa_flg },
                |m: &mut OutputAccount| { &mut m.npa_flg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "benchmark",
                |m: &OutputAccount| { &m.benchmark },
                |m: &mut OutputAccount| { &mut m.benchmark },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rep_freq",
                |m: &OutputAccount| { &m.rep_freq },
                |m: &mut OutputAccount| { &mut m.rep_freq },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "nxt_rep_dt",
                |m: &OutputAccount| { &m.nxt_rep_dt },
                |m: &mut OutputAccount| { &mut m.nxt_rep_dt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "lst_rep_dt",
                |m: &OutputAccount| { &m.lst_rep_dt },
                |m: &mut OutputAccount| { &mut m.lst_rep_dt },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cust_typ",
                |m: &OutputAccount| { &m.cust_typ },
                |m: &mut OutputAccount| { &mut m.cust_typ },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "country",
                |m: &OutputAccount| { &m.country },
                |m: &mut OutputAccount| { &mut m.country },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bm_id_lookup",
                |m: &OutputAccount| { &m.bm_id_lookup },
                |m: &mut OutputAccount| { &mut m.bm_id_lookup },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "alm_concat",
                |m: &OutputAccount| { &m.alm_concat },
                |m: &mut OutputAccount| { &mut m.alm_concat },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mis2_code",
                |m: &OutputAccount| { &m.mis2_code },
                |m: &mut OutputAccount| { &mut m.mis2_code },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "der_int_rate",
                |m: &OutputAccount| { &m.der_int_rate },
                |m: &mut OutputAccount| { &mut m.der_int_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "bnchmrk_rate",
                |m: &OutputAccount| { &m.bnchmrk_rate },
                |m: &mut OutputAccount| { &mut m.bnchmrk_rate },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "spread",
                |m: &OutputAccount| { &m.spread },
                |m: &mut OutputAccount| { &mut m.spread },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fully_floating_flg",
                |m: &OutputAccount| { &m.fully_floating_flg },
                |m: &mut OutputAccount| { &mut m.fully_floating_flg },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "b1",
                |m: &OutputAccount| { &m.b1 },
                |m: &mut OutputAccount| { &mut m.b1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "b2",
                |m: &OutputAccount| { &m.b2 },
                |m: &mut OutputAccount| { &mut m.b2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "b3",
                |m: &OutputAccount| { &m.b3 },
                |m: &mut OutputAccount| { &mut m.b3 },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "flg_frequency",
                |m: &OutputAccount| { &m.flg_frequency },
                |m: &mut OutputAccount| { &mut m.flg_frequency },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dat_start_frq",
                |m: &OutputAccount| { &m.dat_start_frq },
                |m: &mut OutputAccount| { &mut m.dat_start_frq },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dat_frq_last_reset",
                |m: &OutputAccount| { &m.dat_frq_last_reset },
                |m: &mut OutputAccount| { &mut m.dat_frq_last_reset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "dat_frq_next_reset",
                |m: &OutputAccount| { &m.dat_frq_next_reset },
                |m: &mut OutputAccount| { &mut m.dat_frq_next_reset },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                "rat_var_penalty",
                |m: &OutputAccount| { &m.rat_var_penalty },
                |m: &mut OutputAccount| { &mut m.rat_var_penalty },
            ));
            fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sma_flag",
                |m: &OutputAccount| { &m.sma_flag },
                |m: &mut OutputAccount| { &mut m.sma_flag },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cashflow>>(
                "cashflows",
                |m: &OutputAccount| { &m.cashflows },
                |m: &mut OutputAccount| { &mut m.cashflows },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OutputAccount>(
                "OutputAccount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OutputAccount {
        static instance: ::protobuf::rt::LazyV2<OutputAccount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OutputAccount::new)
    }
}

impl ::protobuf::Clear for OutputAccount {
    fn clear(&mut self) {
        self.cod_acc_no.clear();
        self.cod_cc_brn.clear();
        self.cod_prod.clear();
        self.bal_book = 0.;
        self.bal_book_lcy = 0.;
        self.amt_od_lmt = 0.;
        self.amt_od_lmt_lcy = 0.;
        self.cod_cust = 0;
        self.cod_acc_title.clear();
        self.dt_open_acc = 0;
        self.cod_int_accr_bas.clear();
        self.freq_int_accr.clear();
        self.dt_acc_close = 0;
        self.cod_collat_id.clear();
        self.collat_desc.clear();
        self.as_of_dt = 0;
        self.cost_cntr.clear();
        self.gl_acc_no.clear();
        self.rt_flg.clear();
        self.inst.clear();
        self.crnt_book_bal = 0.;
        self.acrl_basis.clear();
        self.int_rt = 0.;
        self.div.clear();
        self.alm_line.clear();
        self.ia_llg.clear();
        self.balm_llg.clear();
        self.mis1 = 0;
        self.npa_flg.clear();
        self.benchmark.clear();
        self.rep_freq.clear();
        self.nxt_rep_dt = 0;
        self.lst_rep_dt = 0;
        self.cust_typ.clear();
        self.country.clear();
        self.bm_id_lookup.clear();
        self.alm_concat.clear();
        self.mis2_code.clear();
        self.der_int_rate = 0.;
        self.bnchmrk_rate = 0.;
        self.spread = 0.;
        self.fully_floating_flg.clear();
        self.b1 = 0.;
        self.b2 = 0.;
        self.b3 = 0.;
        self.flg_frequency = 0.;
        self.dat_start_frq = 0;
        self.dat_frq_last_reset = 0;
        self.dat_frq_next_reset = 0;
        self.rat_var_penalty = 0.;
        self.sma_flag.clear();
        self.cashflows.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OutputAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OutputAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0ematurity.proto\"r\n\x08Cashflow\x12'\n\x0finterest_amount\x18\x01\
    \x20\x01(\x01R\x0einterestAmount\x12)\n\x10principal_amount\x18\x02\x20\
    \x01(\x01R\x0fprincipalAmount\x12\x12\n\x04date\x18\x03\x20\x01(\x03R\
    \x04date\"\xaf\x0c\n\rOutputAccount\x12\x1c\n\ncod_acc_no\x18\x01\x20\
    \x01(\tR\x08codAccNo\x12\x1c\n\ncod_cc_brn\x18\x02\x20\x01(\tR\x08codCcB\
    rn\x12\x19\n\x08cod_prod\x18\x03\x20\x01(\tR\x07codProd\x12\x19\n\x08bal\
    _book\x18\x04\x20\x01(\x01R\x07balBook\x12\x20\n\x0cbal_book_lcy\x18\x05\
    \x20\x01(\x01R\nbalBookLcy\x12\x1c\n\namt_od_lmt\x18\x06\x20\x01(\x01R\
    \x08amtOdLmt\x12#\n\x0eamt_od_lmt_lcy\x18\x07\x20\x01(\x01R\x0bamtOdLmtL\
    cy\x12\x19\n\x08cod_cust\x18\x08\x20\x01(\x03R\x07codCust\x12\"\n\rcod_a\
    cc_title\x18\t\x20\x01(\tR\x0bcodAccTitle\x12\x1e\n\x0bdt_open_acc\x18\n\
    \x20\x01(\x03R\tdtOpenAcc\x12'\n\x10cod_int_accr_bas\x18\x0b\x20\x01(\tR\
    \rcodIntAccrBas\x12\"\n\rfreq_int_accr\x18\x0c\x20\x01(\tR\x0bfreqIntAcc\
    r\x12\x20\n\x0cdt_acc_close\x18\r\x20\x01(\x03R\ndtAccClose\x12\"\n\rcod\
    _collat_id\x18\x0e\x20\x01(\tR\x0bcodCollatId\x12\x1f\n\x0bcollat_desc\
    \x18\x0f\x20\x01(\tR\ncollatDesc\x12\x18\n\x08as_of_dt\x18\x10\x20\x01(\
    \x03R\x06asOfDt\x12\x1b\n\tcost_cntr\x18\x11\x20\x01(\tR\x08costCntr\x12\
    \x1a\n\tgl_acc_no\x18\x12\x20\x01(\tR\x07glAccNo\x12\x15\n\x06rt_flg\x18\
    \x13\x20\x01(\tR\x05rtFlg\x12\x12\n\x04inst\x18\x14\x20\x01(\tR\x04inst\
    \x12\"\n\rcrnt_book_bal\x18\x15\x20\x01(\x01R\x0bcrntBookBal\x12\x1d\n\n\
    acrl_basis\x18\x16\x20\x01(\tR\tacrlBasis\x12\x15\n\x06int_rt\x18\x17\
    \x20\x01(\x01R\x05intRt\x12\x10\n\x03div\x18\x18\x20\x01(\tR\x03div\x12\
    \x19\n\x08alm_line\x18\x19\x20\x01(\tR\x07almLine\x12\x15\n\x06ia_llg\
    \x18\x1a\x20\x01(\tR\x05iaLlg\x12\x19\n\x08balm_llg\x18\x1b\x20\x01(\tR\
    \x07balmLlg\x12\x12\n\x04mis1\x18\x1c\x20\x01(\x03R\x04mis1\x12\x17\n\
    \x07npa_flg\x18\x1d\x20\x01(\tR\x06npaFlg\x12\x1c\n\tbenchmark\x18\x1e\
    \x20\x01(\tR\tbenchmark\x12\x19\n\x08rep_freq\x18\x1f\x20\x01(\tR\x07rep\
    Freq\x12\x1c\n\nnxt_rep_dt\x18\x20\x20\x01(\x03R\x08nxtRepDt\x12\x1c\n\n\
    lst_rep_dt\x18!\x20\x01(\x03R\x08lstRepDt\x12\x19\n\x08cust_typ\x18\"\
    \x20\x01(\tR\x07custTyp\x12\x18\n\x07country\x18#\x20\x01(\tR\x07country\
    \x12\x20\n\x0cbm_id_lookup\x18$\x20\x01(\tR\nbmIdLookup\x12\x1d\n\nalm_c\
    oncat\x18%\x20\x01(\tR\talmConcat\x12\x1b\n\tmis2_code\x18&\x20\x01(\tR\
    \x08mis2Code\x12\x20\n\x0cder_int_rate\x18'\x20\x01(\x01R\nderIntRate\
    \x12!\n\x0cbnchmrk_rate\x18(\x20\x01(\x01R\x0bbnchmrkRate\x12\x16\n\x06s\
    pread\x18)\x20\x01(\x01R\x06spread\x12,\n\x12fully_floating_flg\x18*\x20\
    \x01(\tR\x10fullyFloatingFlg\x12\x0e\n\x02b1\x18+\x20\x01(\x01R\x02b1\
    \x12\x0e\n\x02b2\x18,\x20\x01(\x01R\x02b2\x12\x0e\n\x02b3\x18-\x20\x01(\
    \x01R\x02b3\x12#\n\rflg_frequency\x18.\x20\x01(\x01R\x0cflgFrequency\x12\
    \"\n\rdat_start_frq\x18/\x20\x01(\x03R\x0bdatStartFrq\x12+\n\x12dat_frq_\
    last_reset\x180\x20\x01(\x03R\x0fdatFrqLastReset\x12+\n\x12dat_frq_next_\
    reset\x181\x20\x01(\x03R\x0fdatFrqNextReset\x12&\n\x0frat_var_penalty\
    \x182\x20\x01(\x01R\rratVarPenalty\x12\x19\n\x08sma_flag\x183\x20\x01(\t\
    R\x07smaFlag\x12'\n\tcashflows\x184\x20\x03(\x0b2\t.CashflowR\tcashflows\
    b\x06proto3\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}