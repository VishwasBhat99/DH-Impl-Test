// This file is generated by rust-protobuf 2.4.0. Do not edit
// @generated

// https://github.com/Manishearth/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]

use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

#[derive(PartialEq,Clone,Default)]
pub struct Cashflow {
    // message fields
    pub interest_amount: f64,
    pub principal_amount: f64,
    pub date: i64,
    pub base_rate: f64,
    pub base_rate_amount: f64,
    pub adj1_rate: f64,
    pub adj1_rate_amount: f64,
    pub adj2_rate: f64,
    pub adj2_rate_amount: f64,
    pub adj3_rate: f64,
    pub adj3_rate_amount: f64,
    pub adj4_rate: f64,
    pub adj4_rate_amount: f64,
    pub adj5_rate: f64,
    pub adj5_rate_amount: f64,
    pub adj6_rate: f64,
    pub adj6_rate_amount: f64,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl Cashflow {
    pub fn new() -> Cashflow {
        ::std::default::Default::default()
    }

    // double interest_amount = 1;

    pub fn clear_interest_amount(&mut self) {
        self.interest_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_interest_amount(&mut self, v: f64) {
        self.interest_amount = v;
    }

    pub fn get_interest_amount(&self) -> f64 {
        self.interest_amount
    }

    // double principal_amount = 2;

    pub fn clear_principal_amount(&mut self) {
        self.principal_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_principal_amount(&mut self, v: f64) {
        self.principal_amount = v;
    }

    pub fn get_principal_amount(&self) -> f64 {
        self.principal_amount
    }

    // int64 date = 3;

    pub fn clear_date(&mut self) {
        self.date = 0;
    }

    // Param is passed by value, moved
    pub fn set_date(&mut self, v: i64) {
        self.date = v;
    }

    pub fn get_date(&self) -> i64 {
        self.date
    }

    // double base_rate = 4;

    pub fn clear_base_rate(&mut self) {
        self.base_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_base_rate(&mut self, v: f64) {
        self.base_rate = v;
    }

    pub fn get_base_rate(&self) -> f64 {
        self.base_rate
    }

    // double base_rate_amount = 5;

    pub fn clear_base_rate_amount(&mut self) {
        self.base_rate_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_base_rate_amount(&mut self, v: f64) {
        self.base_rate_amount = v;
    }

    pub fn get_base_rate_amount(&self) -> f64 {
        self.base_rate_amount
    }

    // double adj1_rate = 6;

    pub fn clear_adj1_rate(&mut self) {
        self.adj1_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj1_rate(&mut self, v: f64) {
        self.adj1_rate = v;
    }

    pub fn get_adj1_rate(&self) -> f64 {
        self.adj1_rate
    }

    // double adj1_rate_amount = 7;

    pub fn clear_adj1_rate_amount(&mut self) {
        self.adj1_rate_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj1_rate_amount(&mut self, v: f64) {
        self.adj1_rate_amount = v;
    }

    pub fn get_adj1_rate_amount(&self) -> f64 {
        self.adj1_rate_amount
    }

    // double adj2_rate = 8;

    pub fn clear_adj2_rate(&mut self) {
        self.adj2_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj2_rate(&mut self, v: f64) {
        self.adj2_rate = v;
    }

    pub fn get_adj2_rate(&self) -> f64 {
        self.adj2_rate
    }

    // double adj2_rate_amount = 9;

    pub fn clear_adj2_rate_amount(&mut self) {
        self.adj2_rate_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj2_rate_amount(&mut self, v: f64) {
        self.adj2_rate_amount = v;
    }

    pub fn get_adj2_rate_amount(&self) -> f64 {
        self.adj2_rate_amount
    }

    // double adj3_rate = 10;

    pub fn clear_adj3_rate(&mut self) {
        self.adj3_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj3_rate(&mut self, v: f64) {
        self.adj3_rate = v;
    }

    pub fn get_adj3_rate(&self) -> f64 {
        self.adj3_rate
    }

    // double adj3_rate_amount = 11;

    pub fn clear_adj3_rate_amount(&mut self) {
        self.adj3_rate_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj3_rate_amount(&mut self, v: f64) {
        self.adj3_rate_amount = v;
    }

    pub fn get_adj3_rate_amount(&self) -> f64 {
        self.adj3_rate_amount
    }

    // double adj4_rate = 12;

    pub fn clear_adj4_rate(&mut self) {
        self.adj4_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj4_rate(&mut self, v: f64) {
        self.adj4_rate = v;
    }

    pub fn get_adj4_rate(&self) -> f64 {
        self.adj4_rate
    }

    // double adj4_rate_amount = 13;

    pub fn clear_adj4_rate_amount(&mut self) {
        self.adj4_rate_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj4_rate_amount(&mut self, v: f64) {
        self.adj4_rate_amount = v;
    }

    pub fn get_adj4_rate_amount(&self) -> f64 {
        self.adj4_rate_amount
    }

    // double adj5_rate = 14;

    pub fn clear_adj5_rate(&mut self) {
        self.adj5_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj5_rate(&mut self, v: f64) {
        self.adj5_rate = v;
    }

    pub fn get_adj5_rate(&self) -> f64 {
        self.adj5_rate
    }

    // double adj5_rate_amount = 15;

    pub fn clear_adj5_rate_amount(&mut self) {
        self.adj5_rate_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj5_rate_amount(&mut self, v: f64) {
        self.adj5_rate_amount = v;
    }

    pub fn get_adj5_rate_amount(&self) -> f64 {
        self.adj5_rate_amount
    }

    // double adj6_rate = 16;

    pub fn clear_adj6_rate(&mut self) {
        self.adj6_rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj6_rate(&mut self, v: f64) {
        self.adj6_rate = v;
    }

    pub fn get_adj6_rate(&self) -> f64 {
        self.adj6_rate
    }

    // double adj6_rate_amount = 17;

    pub fn clear_adj6_rate_amount(&mut self) {
        self.adj6_rate_amount = 0.;
    }

    // Param is passed by value, moved
    pub fn set_adj6_rate_amount(&mut self, v: f64) {
        self.adj6_rate_amount = v;
    }

    pub fn get_adj6_rate_amount(&self) -> f64 {
        self.adj6_rate_amount
    }
}

impl ::protobuf::Message for Cashflow {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.interest_amount = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.principal_amount = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.date = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.base_rate = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.base_rate_amount = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj1_rate = tmp;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj1_rate_amount = tmp;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj2_rate = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj2_rate_amount = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj3_rate = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj3_rate_amount = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj4_rate = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj4_rate_amount = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj5_rate = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj5_rate_amount = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj6_rate = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.adj6_rate_amount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.interest_amount != 0. {
            my_size += 9;
        }
        if self.principal_amount != 0. {
            my_size += 9;
        }
        if self.date != 0 {
            my_size += ::protobuf::rt::value_size(3, self.date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.base_rate != 0. {
            my_size += 9;
        }
        if self.base_rate_amount != 0. {
            my_size += 9;
        }
        if self.adj1_rate != 0. {
            my_size += 9;
        }
        if self.adj1_rate_amount != 0. {
            my_size += 9;
        }
        if self.adj2_rate != 0. {
            my_size += 9;
        }
        if self.adj2_rate_amount != 0. {
            my_size += 9;
        }
        if self.adj3_rate != 0. {
            my_size += 9;
        }
        if self.adj3_rate_amount != 0. {
            my_size += 9;
        }
        if self.adj4_rate != 0. {
            my_size += 9;
        }
        if self.adj4_rate_amount != 0. {
            my_size += 9;
        }
        if self.adj5_rate != 0. {
            my_size += 9;
        }
        if self.adj5_rate_amount != 0. {
            my_size += 9;
        }
        if self.adj6_rate != 0. {
            my_size += 10;
        }
        if self.adj6_rate_amount != 0. {
            my_size += 10;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if self.interest_amount != 0. {
            os.write_double(1, self.interest_amount)?;
        }
        if self.principal_amount != 0. {
            os.write_double(2, self.principal_amount)?;
        }
        if self.date != 0 {
            os.write_int64(3, self.date)?;
        }
        if self.base_rate != 0. {
            os.write_double(4, self.base_rate)?;
        }
        if self.base_rate_amount != 0. {
            os.write_double(5, self.base_rate_amount)?;
        }
        if self.adj1_rate != 0. {
            os.write_double(6, self.adj1_rate)?;
        }
        if self.adj1_rate_amount != 0. {
            os.write_double(7, self.adj1_rate_amount)?;
        }
        if self.adj2_rate != 0. {
            os.write_double(8, self.adj2_rate)?;
        }
        if self.adj2_rate_amount != 0. {
            os.write_double(9, self.adj2_rate_amount)?;
        }
        if self.adj3_rate != 0. {
            os.write_double(10, self.adj3_rate)?;
        }
        if self.adj3_rate_amount != 0. {
            os.write_double(11, self.adj3_rate_amount)?;
        }
        if self.adj4_rate != 0. {
            os.write_double(12, self.adj4_rate)?;
        }
        if self.adj4_rate_amount != 0. {
            os.write_double(13, self.adj4_rate_amount)?;
        }
        if self.adj5_rate != 0. {
            os.write_double(14, self.adj5_rate)?;
        }
        if self.adj5_rate_amount != 0. {
            os.write_double(15, self.adj5_rate_amount)?;
        }
        if self.adj6_rate != 0. {
            os.write_double(16, self.adj6_rate)?;
        }
        if self.adj6_rate_amount != 0. {
            os.write_double(17, self.adj6_rate_amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Cashflow {
        Cashflow::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "interest_amount",
                    |m: &Cashflow| { &m.interest_amount },
                    |m: &mut Cashflow| { &mut m.interest_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "principal_amount",
                    |m: &Cashflow| { &m.principal_amount },
                    |m: &mut Cashflow| { &mut m.principal_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "date",
                    |m: &Cashflow| { &m.date },
                    |m: &mut Cashflow| { &mut m.date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "base_rate",
                    |m: &Cashflow| { &m.base_rate },
                    |m: &mut Cashflow| { &mut m.base_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "base_rate_amount",
                    |m: &Cashflow| { &m.base_rate_amount },
                    |m: &mut Cashflow| { &mut m.base_rate_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj1_rate",
                    |m: &Cashflow| { &m.adj1_rate },
                    |m: &mut Cashflow| { &mut m.adj1_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj1_rate_amount",
                    |m: &Cashflow| { &m.adj1_rate_amount },
                    |m: &mut Cashflow| { &mut m.adj1_rate_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj2_rate",
                    |m: &Cashflow| { &m.adj2_rate },
                    |m: &mut Cashflow| { &mut m.adj2_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj2_rate_amount",
                    |m: &Cashflow| { &m.adj2_rate_amount },
                    |m: &mut Cashflow| { &mut m.adj2_rate_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj3_rate",
                    |m: &Cashflow| { &m.adj3_rate },
                    |m: &mut Cashflow| { &mut m.adj3_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj3_rate_amount",
                    |m: &Cashflow| { &m.adj3_rate_amount },
                    |m: &mut Cashflow| { &mut m.adj3_rate_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj4_rate",
                    |m: &Cashflow| { &m.adj4_rate },
                    |m: &mut Cashflow| { &mut m.adj4_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj4_rate_amount",
                    |m: &Cashflow| { &m.adj4_rate_amount },
                    |m: &mut Cashflow| { &mut m.adj4_rate_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj5_rate",
                    |m: &Cashflow| { &m.adj5_rate },
                    |m: &mut Cashflow| { &mut m.adj5_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj5_rate_amount",
                    |m: &Cashflow| { &m.adj5_rate_amount },
                    |m: &mut Cashflow| { &mut m.adj5_rate_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj6_rate",
                    |m: &Cashflow| { &m.adj6_rate },
                    |m: &mut Cashflow| { &mut m.adj6_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "adj6_rate_amount",
                    |m: &Cashflow| { &m.adj6_rate_amount },
                    |m: &mut Cashflow| { &mut m.adj6_rate_amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<Cashflow>(
                    "Cashflow",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Cashflow {
        static mut instance: ::protobuf::lazy::Lazy<Cashflow> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const Cashflow,
        };
        unsafe {
            instance.get(Cashflow::new)
        }
    }
}

impl ::protobuf::Clear for Cashflow {
    fn clear(&mut self) {
        self.clear_interest_amount();
        self.clear_principal_amount();
        self.clear_date();
        self.clear_base_rate();
        self.clear_base_rate_amount();
        self.clear_adj1_rate();
        self.clear_adj1_rate_amount();
        self.clear_adj2_rate();
        self.clear_adj2_rate_amount();
        self.clear_adj3_rate();
        self.clear_adj3_rate_amount();
        self.clear_adj4_rate();
        self.clear_adj4_rate_amount();
        self.clear_adj5_rate();
        self.clear_adj5_rate_amount();
        self.clear_adj6_rate();
        self.clear_adj6_rate_amount();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Cashflow {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Cashflow {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AccountWithCashflows {
    // message fields
    pub deal_no: ::std::string::String,
    pub short_name: ::std::string::String,
    pub nxt_rep_dt: i64,
    pub call_dt: i64,
    pub put_dt: i64,
    pub deal_dt: i64,
    pub portfolio: ::std::string::String,
    pub deal_rt: f64,
    pub org_face_val: i64,
    pub os_face_val: i64,
    pub org_cst_val: f64,
    pub acrd_int: f64,
    pub book_yield: f64,
    pub int_basis: i64,
    pub avg_os_vd: f64,
    pub avg_os_dd: f64,
    pub prin_amt: f64,
    pub org_bal: f64,
    pub coup_rt: f64,
    pub nxt_coup_dt: i64,
    pub gl: i64,
    pub cf_dt: i64,
    pub secu_desc: ::std::string::String,
    pub prod_desc: ::std::string::String,
    pub prod_cd: ::std::string::String,
    pub lst_coup_dt: i64,
    pub call_dt1: i64,
    pub coup_freq: ::std::string::String,
    pub val_dt: i64,
    pub acrl_freq: ::std::string::String,
    pub lst_rep_dt: i64,
    pub lst_put_dt: i64,
    pub inst: ::std::string::String,
    pub org_term: i64,
    pub acrl_basis: ::std::string::String,
    pub div: ::std::string::String,
    pub alm_line: ::std::string::String,
    pub ia_line: ::std::string::String,
    pub cmpnd_freq: i64,
    pub nxt_cmpnd_dt: i64,
    pub rt_chng_freq: i64,
    pub rt_flg: ::std::string::String,
    pub rep_idx: ::std::string::String,
    pub nxt_pay_dt: i64,
    pub prev_rep_dt: i64,
    pub int_pay_freq: i64,
    pub int_rt: f64,
    pub port_typ: ::std::string::String,
    pub sec_grp: ::std::string::String,
    pub sec_type: ::std::string::String,
    pub sec_issuer: ::std::string::String,
    pub sec_guaranteed: ::std::string::String,
    pub mrkt: ::std::string::String,
    pub idx_label: ::std::string::String,
    pub bd_categ: ::std::string::String,
    pub bd_type: ::std::string::String,
    pub listed: ::std::string::String,
    pub npa_class: ::std::string::String,
    pub entity: ::std::string::String,
    pub desk: ::std::string::String,
    pub acc_sec_igaap: ::std::string::String,
    pub os_cv_before_amort: f64,
    pub os_cv_after_amort: f64,
    pub mat_dt: i64,
    pub int_amt: f64,
    pub flow_type: ::std::string::String,
    pub isin: ::std::string::String,
    pub org_tenor: i64,
    pub rep_tenor: i64,
    pub ftp_mat_dt: i64,
    pub contract_no: ::std::string::String,
    pub instr_id: ::std::string::String,
    pub parent_code: ::std::string::String,
    pub issuer_name: ::std::string::String,
    pub rating: ::std::string::String,
    pub tax_status: ::std::string::String,
    pub slr_nslr: ::std::string::String,
    pub deal_ytm: f64,
    pub intr_app_freq: ::std::string::String,
    pub comp_freq: ::std::string::String,
    pub intr_prac: ::std::string::String,
    pub rate_spread: ::std::string::String,
    pub asset_class: ::std::string::String,
    pub intr_typ: ::std::string::String,
    pub sec_issuance_date: i64,
    pub coupon: ::std::string::String,
    pub last_intr_dt: i64,
    pub next_intr_dt: i64,
    pub amort_till_dt: f64,
    pub tot_int_amt: f64,
    pub tot_prin_amt: f64,
    pub Method: i32,
    pub BaseCurve: i32,
    pub ftp_runid: i64,
    pub from_date: i32,
    pub to_date: i32,
    pub total_balance: f64,
    pub total_interest_ftp: f64,
    pub total_ftp: f64,
    pub FTP_Rate: f64,
    pub cashflows: ::protobuf::RepeatedField<Cashflow>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl AccountWithCashflows {
    pub fn new() -> AccountWithCashflows {
        ::std::default::Default::default()
    }

    // string deal_no = 1;

    pub fn clear_deal_no(&mut self) {
        self.deal_no.clear();
    }

    // Param is passed by value, moved
    pub fn set_deal_no(&mut self, v: ::std::string::String) {
        self.deal_no = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deal_no(&mut self) -> &mut ::std::string::String {
        &mut self.deal_no
    }

    // Take field
    pub fn take_deal_no(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.deal_no, ::std::string::String::new())
    }

    pub fn get_deal_no(&self) -> &str {
        &self.deal_no
    }

    // string short_name = 2;

    pub fn clear_short_name(&mut self) {
        self.short_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_short_name(&mut self, v: ::std::string::String) {
        self.short_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_short_name(&mut self) -> &mut ::std::string::String {
        &mut self.short_name
    }

    // Take field
    pub fn take_short_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.short_name, ::std::string::String::new())
    }

    pub fn get_short_name(&self) -> &str {
        &self.short_name
    }

    // int64 nxt_rep_dt = 3;

    pub fn clear_nxt_rep_dt(&mut self) {
        self.nxt_rep_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_nxt_rep_dt(&mut self, v: i64) {
        self.nxt_rep_dt = v;
    }

    pub fn get_nxt_rep_dt(&self) -> i64 {
        self.nxt_rep_dt
    }

    // int64 call_dt = 4;

    pub fn clear_call_dt(&mut self) {
        self.call_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_call_dt(&mut self, v: i64) {
        self.call_dt = v;
    }

    pub fn get_call_dt(&self) -> i64 {
        self.call_dt
    }

    // int64 put_dt = 5;

    pub fn clear_put_dt(&mut self) {
        self.put_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_put_dt(&mut self, v: i64) {
        self.put_dt = v;
    }

    pub fn get_put_dt(&self) -> i64 {
        self.put_dt
    }

    // int64 deal_dt = 6;

    pub fn clear_deal_dt(&mut self) {
        self.deal_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_deal_dt(&mut self, v: i64) {
        self.deal_dt = v;
    }

    pub fn get_deal_dt(&self) -> i64 {
        self.deal_dt
    }

    // string portfolio = 7;

    pub fn clear_portfolio(&mut self) {
        self.portfolio.clear();
    }

    // Param is passed by value, moved
    pub fn set_portfolio(&mut self, v: ::std::string::String) {
        self.portfolio = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portfolio(&mut self) -> &mut ::std::string::String {
        &mut self.portfolio
    }

    // Take field
    pub fn take_portfolio(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.portfolio, ::std::string::String::new())
    }

    pub fn get_portfolio(&self) -> &str {
        &self.portfolio
    }

    // double deal_rt = 8;

    pub fn clear_deal_rt(&mut self) {
        self.deal_rt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_deal_rt(&mut self, v: f64) {
        self.deal_rt = v;
    }

    pub fn get_deal_rt(&self) -> f64 {
        self.deal_rt
    }

    // int64 org_face_val = 9;

    pub fn clear_org_face_val(&mut self) {
        self.org_face_val = 0;
    }

    // Param is passed by value, moved
    pub fn set_org_face_val(&mut self, v: i64) {
        self.org_face_val = v;
    }

    pub fn get_org_face_val(&self) -> i64 {
        self.org_face_val
    }

    // int64 os_face_val = 10;

    pub fn clear_os_face_val(&mut self) {
        self.os_face_val = 0;
    }

    // Param is passed by value, moved
    pub fn set_os_face_val(&mut self, v: i64) {
        self.os_face_val = v;
    }

    pub fn get_os_face_val(&self) -> i64 {
        self.os_face_val
    }

    // double org_cst_val = 11;

    pub fn clear_org_cst_val(&mut self) {
        self.org_cst_val = 0.;
    }

    // Param is passed by value, moved
    pub fn set_org_cst_val(&mut self, v: f64) {
        self.org_cst_val = v;
    }

    pub fn get_org_cst_val(&self) -> f64 {
        self.org_cst_val
    }

    // double acrd_int = 12;

    pub fn clear_acrd_int(&mut self) {
        self.acrd_int = 0.;
    }

    // Param is passed by value, moved
    pub fn set_acrd_int(&mut self, v: f64) {
        self.acrd_int = v;
    }

    pub fn get_acrd_int(&self) -> f64 {
        self.acrd_int
    }

    // double book_yield = 13;

    pub fn clear_book_yield(&mut self) {
        self.book_yield = 0.;
    }

    // Param is passed by value, moved
    pub fn set_book_yield(&mut self, v: f64) {
        self.book_yield = v;
    }

    pub fn get_book_yield(&self) -> f64 {
        self.book_yield
    }

    // int64 int_basis = 14;

    pub fn clear_int_basis(&mut self) {
        self.int_basis = 0;
    }

    // Param is passed by value, moved
    pub fn set_int_basis(&mut self, v: i64) {
        self.int_basis = v;
    }

    pub fn get_int_basis(&self) -> i64 {
        self.int_basis
    }

    // double avg_os_vd = 15;

    pub fn clear_avg_os_vd(&mut self) {
        self.avg_os_vd = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avg_os_vd(&mut self, v: f64) {
        self.avg_os_vd = v;
    }

    pub fn get_avg_os_vd(&self) -> f64 {
        self.avg_os_vd
    }

    // double avg_os_dd = 16;

    pub fn clear_avg_os_dd(&mut self) {
        self.avg_os_dd = 0.;
    }

    // Param is passed by value, moved
    pub fn set_avg_os_dd(&mut self, v: f64) {
        self.avg_os_dd = v;
    }

    pub fn get_avg_os_dd(&self) -> f64 {
        self.avg_os_dd
    }

    // double prin_amt = 17;

    pub fn clear_prin_amt(&mut self) {
        self.prin_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_prin_amt(&mut self, v: f64) {
        self.prin_amt = v;
    }

    pub fn get_prin_amt(&self) -> f64 {
        self.prin_amt
    }

    // double org_bal = 18;

    pub fn clear_org_bal(&mut self) {
        self.org_bal = 0.;
    }

    // Param is passed by value, moved
    pub fn set_org_bal(&mut self, v: f64) {
        self.org_bal = v;
    }

    pub fn get_org_bal(&self) -> f64 {
        self.org_bal
    }

    // double coup_rt = 19;

    pub fn clear_coup_rt(&mut self) {
        self.coup_rt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_coup_rt(&mut self, v: f64) {
        self.coup_rt = v;
    }

    pub fn get_coup_rt(&self) -> f64 {
        self.coup_rt
    }

    // int64 nxt_coup_dt = 20;

    pub fn clear_nxt_coup_dt(&mut self) {
        self.nxt_coup_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_nxt_coup_dt(&mut self, v: i64) {
        self.nxt_coup_dt = v;
    }

    pub fn get_nxt_coup_dt(&self) -> i64 {
        self.nxt_coup_dt
    }

    // int64 gl = 21;

    pub fn clear_gl(&mut self) {
        self.gl = 0;
    }

    // Param is passed by value, moved
    pub fn set_gl(&mut self, v: i64) {
        self.gl = v;
    }

    pub fn get_gl(&self) -> i64 {
        self.gl
    }

    // int64 cf_dt = 22;

    pub fn clear_cf_dt(&mut self) {
        self.cf_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_cf_dt(&mut self, v: i64) {
        self.cf_dt = v;
    }

    pub fn get_cf_dt(&self) -> i64 {
        self.cf_dt
    }

    // string secu_desc = 23;

    pub fn clear_secu_desc(&mut self) {
        self.secu_desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_secu_desc(&mut self, v: ::std::string::String) {
        self.secu_desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secu_desc(&mut self) -> &mut ::std::string::String {
        &mut self.secu_desc
    }

    // Take field
    pub fn take_secu_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.secu_desc, ::std::string::String::new())
    }

    pub fn get_secu_desc(&self) -> &str {
        &self.secu_desc
    }

    // string prod_desc = 24;

    pub fn clear_prod_desc(&mut self) {
        self.prod_desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_prod_desc(&mut self, v: ::std::string::String) {
        self.prod_desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prod_desc(&mut self) -> &mut ::std::string::String {
        &mut self.prod_desc
    }

    // Take field
    pub fn take_prod_desc(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prod_desc, ::std::string::String::new())
    }

    pub fn get_prod_desc(&self) -> &str {
        &self.prod_desc
    }

    // string prod_cd = 25;

    pub fn clear_prod_cd(&mut self) {
        self.prod_cd.clear();
    }

    // Param is passed by value, moved
    pub fn set_prod_cd(&mut self, v: ::std::string::String) {
        self.prod_cd = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prod_cd(&mut self) -> &mut ::std::string::String {
        &mut self.prod_cd
    }

    // Take field
    pub fn take_prod_cd(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prod_cd, ::std::string::String::new())
    }

    pub fn get_prod_cd(&self) -> &str {
        &self.prod_cd
    }

    // int64 lst_coup_dt = 26;

    pub fn clear_lst_coup_dt(&mut self) {
        self.lst_coup_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_lst_coup_dt(&mut self, v: i64) {
        self.lst_coup_dt = v;
    }

    pub fn get_lst_coup_dt(&self) -> i64 {
        self.lst_coup_dt
    }

    // int64 call_dt1 = 27;

    pub fn clear_call_dt1(&mut self) {
        self.call_dt1 = 0;
    }

    // Param is passed by value, moved
    pub fn set_call_dt1(&mut self, v: i64) {
        self.call_dt1 = v;
    }

    pub fn get_call_dt1(&self) -> i64 {
        self.call_dt1
    }

    // string coup_freq = 28;

    pub fn clear_coup_freq(&mut self) {
        self.coup_freq.clear();
    }

    // Param is passed by value, moved
    pub fn set_coup_freq(&mut self, v: ::std::string::String) {
        self.coup_freq = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coup_freq(&mut self) -> &mut ::std::string::String {
        &mut self.coup_freq
    }

    // Take field
    pub fn take_coup_freq(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.coup_freq, ::std::string::String::new())
    }

    pub fn get_coup_freq(&self) -> &str {
        &self.coup_freq
    }

    // int64 val_dt = 29;

    pub fn clear_val_dt(&mut self) {
        self.val_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_val_dt(&mut self, v: i64) {
        self.val_dt = v;
    }

    pub fn get_val_dt(&self) -> i64 {
        self.val_dt
    }

    // string acrl_freq = 30;

    pub fn clear_acrl_freq(&mut self) {
        self.acrl_freq.clear();
    }

    // Param is passed by value, moved
    pub fn set_acrl_freq(&mut self, v: ::std::string::String) {
        self.acrl_freq = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acrl_freq(&mut self) -> &mut ::std::string::String {
        &mut self.acrl_freq
    }

    // Take field
    pub fn take_acrl_freq(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.acrl_freq, ::std::string::String::new())
    }

    pub fn get_acrl_freq(&self) -> &str {
        &self.acrl_freq
    }

    // int64 lst_rep_dt = 31;

    pub fn clear_lst_rep_dt(&mut self) {
        self.lst_rep_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_lst_rep_dt(&mut self, v: i64) {
        self.lst_rep_dt = v;
    }

    pub fn get_lst_rep_dt(&self) -> i64 {
        self.lst_rep_dt
    }

    // int64 lst_put_dt = 32;

    pub fn clear_lst_put_dt(&mut self) {
        self.lst_put_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_lst_put_dt(&mut self, v: i64) {
        self.lst_put_dt = v;
    }

    pub fn get_lst_put_dt(&self) -> i64 {
        self.lst_put_dt
    }

    // string inst = 33;

    pub fn clear_inst(&mut self) {
        self.inst.clear();
    }

    // Param is passed by value, moved
    pub fn set_inst(&mut self, v: ::std::string::String) {
        self.inst = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_inst(&mut self) -> &mut ::std::string::String {
        &mut self.inst
    }

    // Take field
    pub fn take_inst(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.inst, ::std::string::String::new())
    }

    pub fn get_inst(&self) -> &str {
        &self.inst
    }

    // int64 org_term = 34;

    pub fn clear_org_term(&mut self) {
        self.org_term = 0;
    }

    // Param is passed by value, moved
    pub fn set_org_term(&mut self, v: i64) {
        self.org_term = v;
    }

    pub fn get_org_term(&self) -> i64 {
        self.org_term
    }

    // string acrl_basis = 35;

    pub fn clear_acrl_basis(&mut self) {
        self.acrl_basis.clear();
    }

    // Param is passed by value, moved
    pub fn set_acrl_basis(&mut self, v: ::std::string::String) {
        self.acrl_basis = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acrl_basis(&mut self) -> &mut ::std::string::String {
        &mut self.acrl_basis
    }

    // Take field
    pub fn take_acrl_basis(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.acrl_basis, ::std::string::String::new())
    }

    pub fn get_acrl_basis(&self) -> &str {
        &self.acrl_basis
    }

    // string div = 36;

    pub fn clear_div(&mut self) {
        self.div.clear();
    }

    // Param is passed by value, moved
    pub fn set_div(&mut self, v: ::std::string::String) {
        self.div = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_div(&mut self) -> &mut ::std::string::String {
        &mut self.div
    }

    // Take field
    pub fn take_div(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.div, ::std::string::String::new())
    }

    pub fn get_div(&self) -> &str {
        &self.div
    }

    // string alm_line = 37;

    pub fn clear_alm_line(&mut self) {
        self.alm_line.clear();
    }

    // Param is passed by value, moved
    pub fn set_alm_line(&mut self, v: ::std::string::String) {
        self.alm_line = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_alm_line(&mut self) -> &mut ::std::string::String {
        &mut self.alm_line
    }

    // Take field
    pub fn take_alm_line(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.alm_line, ::std::string::String::new())
    }

    pub fn get_alm_line(&self) -> &str {
        &self.alm_line
    }

    // string ia_line = 38;

    pub fn clear_ia_line(&mut self) {
        self.ia_line.clear();
    }

    // Param is passed by value, moved
    pub fn set_ia_line(&mut self, v: ::std::string::String) {
        self.ia_line = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ia_line(&mut self) -> &mut ::std::string::String {
        &mut self.ia_line
    }

    // Take field
    pub fn take_ia_line(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.ia_line, ::std::string::String::new())
    }

    pub fn get_ia_line(&self) -> &str {
        &self.ia_line
    }

    // int64 cmpnd_freq = 39;

    pub fn clear_cmpnd_freq(&mut self) {
        self.cmpnd_freq = 0;
    }

    // Param is passed by value, moved
    pub fn set_cmpnd_freq(&mut self, v: i64) {
        self.cmpnd_freq = v;
    }

    pub fn get_cmpnd_freq(&self) -> i64 {
        self.cmpnd_freq
    }

    // int64 nxt_cmpnd_dt = 40;

    pub fn clear_nxt_cmpnd_dt(&mut self) {
        self.nxt_cmpnd_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_nxt_cmpnd_dt(&mut self, v: i64) {
        self.nxt_cmpnd_dt = v;
    }

    pub fn get_nxt_cmpnd_dt(&self) -> i64 {
        self.nxt_cmpnd_dt
    }

    // int64 rt_chng_freq = 41;

    pub fn clear_rt_chng_freq(&mut self) {
        self.rt_chng_freq = 0;
    }

    // Param is passed by value, moved
    pub fn set_rt_chng_freq(&mut self, v: i64) {
        self.rt_chng_freq = v;
    }

    pub fn get_rt_chng_freq(&self) -> i64 {
        self.rt_chng_freq
    }

    // string rt_flg = 42;

    pub fn clear_rt_flg(&mut self) {
        self.rt_flg.clear();
    }

    // Param is passed by value, moved
    pub fn set_rt_flg(&mut self, v: ::std::string::String) {
        self.rt_flg = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rt_flg(&mut self) -> &mut ::std::string::String {
        &mut self.rt_flg
    }

    // Take field
    pub fn take_rt_flg(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rt_flg, ::std::string::String::new())
    }

    pub fn get_rt_flg(&self) -> &str {
        &self.rt_flg
    }

    // string rep_idx = 43;

    pub fn clear_rep_idx(&mut self) {
        self.rep_idx.clear();
    }

    // Param is passed by value, moved
    pub fn set_rep_idx(&mut self, v: ::std::string::String) {
        self.rep_idx = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rep_idx(&mut self) -> &mut ::std::string::String {
        &mut self.rep_idx
    }

    // Take field
    pub fn take_rep_idx(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rep_idx, ::std::string::String::new())
    }

    pub fn get_rep_idx(&self) -> &str {
        &self.rep_idx
    }

    // int64 nxt_pay_dt = 44;

    pub fn clear_nxt_pay_dt(&mut self) {
        self.nxt_pay_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_nxt_pay_dt(&mut self, v: i64) {
        self.nxt_pay_dt = v;
    }

    pub fn get_nxt_pay_dt(&self) -> i64 {
        self.nxt_pay_dt
    }

    // int64 prev_rep_dt = 45;

    pub fn clear_prev_rep_dt(&mut self) {
        self.prev_rep_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_prev_rep_dt(&mut self, v: i64) {
        self.prev_rep_dt = v;
    }

    pub fn get_prev_rep_dt(&self) -> i64 {
        self.prev_rep_dt
    }

    // int64 int_pay_freq = 46;

    pub fn clear_int_pay_freq(&mut self) {
        self.int_pay_freq = 0;
    }

    // Param is passed by value, moved
    pub fn set_int_pay_freq(&mut self, v: i64) {
        self.int_pay_freq = v;
    }

    pub fn get_int_pay_freq(&self) -> i64 {
        self.int_pay_freq
    }

    // double int_rt = 47;

    pub fn clear_int_rt(&mut self) {
        self.int_rt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_int_rt(&mut self, v: f64) {
        self.int_rt = v;
    }

    pub fn get_int_rt(&self) -> f64 {
        self.int_rt
    }

    // string port_typ = 48;

    pub fn clear_port_typ(&mut self) {
        self.port_typ.clear();
    }

    // Param is passed by value, moved
    pub fn set_port_typ(&mut self, v: ::std::string::String) {
        self.port_typ = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port_typ(&mut self) -> &mut ::std::string::String {
        &mut self.port_typ
    }

    // Take field
    pub fn take_port_typ(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.port_typ, ::std::string::String::new())
    }

    pub fn get_port_typ(&self) -> &str {
        &self.port_typ
    }

    // string sec_grp = 49;

    pub fn clear_sec_grp(&mut self) {
        self.sec_grp.clear();
    }

    // Param is passed by value, moved
    pub fn set_sec_grp(&mut self, v: ::std::string::String) {
        self.sec_grp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sec_grp(&mut self) -> &mut ::std::string::String {
        &mut self.sec_grp
    }

    // Take field
    pub fn take_sec_grp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sec_grp, ::std::string::String::new())
    }

    pub fn get_sec_grp(&self) -> &str {
        &self.sec_grp
    }

    // string sec_type = 50;

    pub fn clear_sec_type(&mut self) {
        self.sec_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_sec_type(&mut self, v: ::std::string::String) {
        self.sec_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sec_type(&mut self) -> &mut ::std::string::String {
        &mut self.sec_type
    }

    // Take field
    pub fn take_sec_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sec_type, ::std::string::String::new())
    }

    pub fn get_sec_type(&self) -> &str {
        &self.sec_type
    }

    // string sec_issuer = 51;

    pub fn clear_sec_issuer(&mut self) {
        self.sec_issuer.clear();
    }

    // Param is passed by value, moved
    pub fn set_sec_issuer(&mut self, v: ::std::string::String) {
        self.sec_issuer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sec_issuer(&mut self) -> &mut ::std::string::String {
        &mut self.sec_issuer
    }

    // Take field
    pub fn take_sec_issuer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sec_issuer, ::std::string::String::new())
    }

    pub fn get_sec_issuer(&self) -> &str {
        &self.sec_issuer
    }

    // string sec_guaranteed = 52;

    pub fn clear_sec_guaranteed(&mut self) {
        self.sec_guaranteed.clear();
    }

    // Param is passed by value, moved
    pub fn set_sec_guaranteed(&mut self, v: ::std::string::String) {
        self.sec_guaranteed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sec_guaranteed(&mut self) -> &mut ::std::string::String {
        &mut self.sec_guaranteed
    }

    // Take field
    pub fn take_sec_guaranteed(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sec_guaranteed, ::std::string::String::new())
    }

    pub fn get_sec_guaranteed(&self) -> &str {
        &self.sec_guaranteed
    }

    // string mrkt = 53;

    pub fn clear_mrkt(&mut self) {
        self.mrkt.clear();
    }

    // Param is passed by value, moved
    pub fn set_mrkt(&mut self, v: ::std::string::String) {
        self.mrkt = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mrkt(&mut self) -> &mut ::std::string::String {
        &mut self.mrkt
    }

    // Take field
    pub fn take_mrkt(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.mrkt, ::std::string::String::new())
    }

    pub fn get_mrkt(&self) -> &str {
        &self.mrkt
    }

    // string idx_label = 54;

    pub fn clear_idx_label(&mut self) {
        self.idx_label.clear();
    }

    // Param is passed by value, moved
    pub fn set_idx_label(&mut self, v: ::std::string::String) {
        self.idx_label = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_idx_label(&mut self) -> &mut ::std::string::String {
        &mut self.idx_label
    }

    // Take field
    pub fn take_idx_label(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.idx_label, ::std::string::String::new())
    }

    pub fn get_idx_label(&self) -> &str {
        &self.idx_label
    }

    // string bd_categ = 55;

    pub fn clear_bd_categ(&mut self) {
        self.bd_categ.clear();
    }

    // Param is passed by value, moved
    pub fn set_bd_categ(&mut self, v: ::std::string::String) {
        self.bd_categ = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bd_categ(&mut self) -> &mut ::std::string::String {
        &mut self.bd_categ
    }

    // Take field
    pub fn take_bd_categ(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bd_categ, ::std::string::String::new())
    }

    pub fn get_bd_categ(&self) -> &str {
        &self.bd_categ
    }

    // string bd_type = 56;

    pub fn clear_bd_type(&mut self) {
        self.bd_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_bd_type(&mut self, v: ::std::string::String) {
        self.bd_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bd_type(&mut self) -> &mut ::std::string::String {
        &mut self.bd_type
    }

    // Take field
    pub fn take_bd_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bd_type, ::std::string::String::new())
    }

    pub fn get_bd_type(&self) -> &str {
        &self.bd_type
    }

    // string listed = 57;

    pub fn clear_listed(&mut self) {
        self.listed.clear();
    }

    // Param is passed by value, moved
    pub fn set_listed(&mut self, v: ::std::string::String) {
        self.listed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_listed(&mut self) -> &mut ::std::string::String {
        &mut self.listed
    }

    // Take field
    pub fn take_listed(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.listed, ::std::string::String::new())
    }

    pub fn get_listed(&self) -> &str {
        &self.listed
    }

    // string npa_class = 58;

    pub fn clear_npa_class(&mut self) {
        self.npa_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_npa_class(&mut self, v: ::std::string::String) {
        self.npa_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_npa_class(&mut self) -> &mut ::std::string::String {
        &mut self.npa_class
    }

    // Take field
    pub fn take_npa_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.npa_class, ::std::string::String::new())
    }

    pub fn get_npa_class(&self) -> &str {
        &self.npa_class
    }

    // string entity = 59;

    pub fn clear_entity(&mut self) {
        self.entity.clear();
    }

    // Param is passed by value, moved
    pub fn set_entity(&mut self, v: ::std::string::String) {
        self.entity = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_entity(&mut self) -> &mut ::std::string::String {
        &mut self.entity
    }

    // Take field
    pub fn take_entity(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.entity, ::std::string::String::new())
    }

    pub fn get_entity(&self) -> &str {
        &self.entity
    }

    // string desk = 60;

    pub fn clear_desk(&mut self) {
        self.desk.clear();
    }

    // Param is passed by value, moved
    pub fn set_desk(&mut self, v: ::std::string::String) {
        self.desk = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desk(&mut self) -> &mut ::std::string::String {
        &mut self.desk
    }

    // Take field
    pub fn take_desk(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.desk, ::std::string::String::new())
    }

    pub fn get_desk(&self) -> &str {
        &self.desk
    }

    // string acc_sec_igaap = 61;

    pub fn clear_acc_sec_igaap(&mut self) {
        self.acc_sec_igaap.clear();
    }

    // Param is passed by value, moved
    pub fn set_acc_sec_igaap(&mut self, v: ::std::string::String) {
        self.acc_sec_igaap = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acc_sec_igaap(&mut self) -> &mut ::std::string::String {
        &mut self.acc_sec_igaap
    }

    // Take field
    pub fn take_acc_sec_igaap(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.acc_sec_igaap, ::std::string::String::new())
    }

    pub fn get_acc_sec_igaap(&self) -> &str {
        &self.acc_sec_igaap
    }

    // double os_cv_before_amort = 62;

    pub fn clear_os_cv_before_amort(&mut self) {
        self.os_cv_before_amort = 0.;
    }

    // Param is passed by value, moved
    pub fn set_os_cv_before_amort(&mut self, v: f64) {
        self.os_cv_before_amort = v;
    }

    pub fn get_os_cv_before_amort(&self) -> f64 {
        self.os_cv_before_amort
    }

    // double os_cv_after_amort = 63;

    pub fn clear_os_cv_after_amort(&mut self) {
        self.os_cv_after_amort = 0.;
    }

    // Param is passed by value, moved
    pub fn set_os_cv_after_amort(&mut self, v: f64) {
        self.os_cv_after_amort = v;
    }

    pub fn get_os_cv_after_amort(&self) -> f64 {
        self.os_cv_after_amort
    }

    // int64 mat_dt = 64;

    pub fn clear_mat_dt(&mut self) {
        self.mat_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_mat_dt(&mut self, v: i64) {
        self.mat_dt = v;
    }

    pub fn get_mat_dt(&self) -> i64 {
        self.mat_dt
    }

    // double int_amt = 65;

    pub fn clear_int_amt(&mut self) {
        self.int_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_int_amt(&mut self, v: f64) {
        self.int_amt = v;
    }

    pub fn get_int_amt(&self) -> f64 {
        self.int_amt
    }

    // string flow_type = 66;

    pub fn clear_flow_type(&mut self) {
        self.flow_type.clear();
    }

    // Param is passed by value, moved
    pub fn set_flow_type(&mut self, v: ::std::string::String) {
        self.flow_type = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flow_type(&mut self) -> &mut ::std::string::String {
        &mut self.flow_type
    }

    // Take field
    pub fn take_flow_type(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.flow_type, ::std::string::String::new())
    }

    pub fn get_flow_type(&self) -> &str {
        &self.flow_type
    }

    // string isin = 67;

    pub fn clear_isin(&mut self) {
        self.isin.clear();
    }

    // Param is passed by value, moved
    pub fn set_isin(&mut self, v: ::std::string::String) {
        self.isin = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_isin(&mut self) -> &mut ::std::string::String {
        &mut self.isin
    }

    // Take field
    pub fn take_isin(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.isin, ::std::string::String::new())
    }

    pub fn get_isin(&self) -> &str {
        &self.isin
    }

    // int64 org_tenor = 68;

    pub fn clear_org_tenor(&mut self) {
        self.org_tenor = 0;
    }

    // Param is passed by value, moved
    pub fn set_org_tenor(&mut self, v: i64) {
        self.org_tenor = v;
    }

    pub fn get_org_tenor(&self) -> i64 {
        self.org_tenor
    }

    // int64 rep_tenor = 69;

    pub fn clear_rep_tenor(&mut self) {
        self.rep_tenor = 0;
    }

    // Param is passed by value, moved
    pub fn set_rep_tenor(&mut self, v: i64) {
        self.rep_tenor = v;
    }

    pub fn get_rep_tenor(&self) -> i64 {
        self.rep_tenor
    }

    // int64 ftp_mat_dt = 70;

    pub fn clear_ftp_mat_dt(&mut self) {
        self.ftp_mat_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_ftp_mat_dt(&mut self, v: i64) {
        self.ftp_mat_dt = v;
    }

    pub fn get_ftp_mat_dt(&self) -> i64 {
        self.ftp_mat_dt
    }

    // string contract_no = 71;

    pub fn clear_contract_no(&mut self) {
        self.contract_no.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_no(&mut self, v: ::std::string::String) {
        self.contract_no = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_no(&mut self) -> &mut ::std::string::String {
        &mut self.contract_no
    }

    // Take field
    pub fn take_contract_no(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_no, ::std::string::String::new())
    }

    pub fn get_contract_no(&self) -> &str {
        &self.contract_no
    }

    // string instr_id = 72;

    pub fn clear_instr_id(&mut self) {
        self.instr_id.clear();
    }

    // Param is passed by value, moved
    pub fn set_instr_id(&mut self, v: ::std::string::String) {
        self.instr_id = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instr_id(&mut self) -> &mut ::std::string::String {
        &mut self.instr_id
    }

    // Take field
    pub fn take_instr_id(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.instr_id, ::std::string::String::new())
    }

    pub fn get_instr_id(&self) -> &str {
        &self.instr_id
    }

    // string parent_code = 73;

    pub fn clear_parent_code(&mut self) {
        self.parent_code.clear();
    }

    // Param is passed by value, moved
    pub fn set_parent_code(&mut self, v: ::std::string::String) {
        self.parent_code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent_code(&mut self) -> &mut ::std::string::String {
        &mut self.parent_code
    }

    // Take field
    pub fn take_parent_code(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.parent_code, ::std::string::String::new())
    }

    pub fn get_parent_code(&self) -> &str {
        &self.parent_code
    }

    // string issuer_name = 74;

    pub fn clear_issuer_name(&mut self) {
        self.issuer_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_issuer_name(&mut self, v: ::std::string::String) {
        self.issuer_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_issuer_name(&mut self) -> &mut ::std::string::String {
        &mut self.issuer_name
    }

    // Take field
    pub fn take_issuer_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.issuer_name, ::std::string::String::new())
    }

    pub fn get_issuer_name(&self) -> &str {
        &self.issuer_name
    }

    // string rating = 75;

    pub fn clear_rating(&mut self) {
        self.rating.clear();
    }

    // Param is passed by value, moved
    pub fn set_rating(&mut self, v: ::std::string::String) {
        self.rating = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rating(&mut self) -> &mut ::std::string::String {
        &mut self.rating
    }

    // Take field
    pub fn take_rating(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rating, ::std::string::String::new())
    }

    pub fn get_rating(&self) -> &str {
        &self.rating
    }

    // string tax_status = 76;

    pub fn clear_tax_status(&mut self) {
        self.tax_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_tax_status(&mut self, v: ::std::string::String) {
        self.tax_status = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tax_status(&mut self) -> &mut ::std::string::String {
        &mut self.tax_status
    }

    // Take field
    pub fn take_tax_status(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.tax_status, ::std::string::String::new())
    }

    pub fn get_tax_status(&self) -> &str {
        &self.tax_status
    }

    // string slr_nslr = 77;

    pub fn clear_slr_nslr(&mut self) {
        self.slr_nslr.clear();
    }

    // Param is passed by value, moved
    pub fn set_slr_nslr(&mut self, v: ::std::string::String) {
        self.slr_nslr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_slr_nslr(&mut self) -> &mut ::std::string::String {
        &mut self.slr_nslr
    }

    // Take field
    pub fn take_slr_nslr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.slr_nslr, ::std::string::String::new())
    }

    pub fn get_slr_nslr(&self) -> &str {
        &self.slr_nslr
    }

    // double deal_ytm = 78;

    pub fn clear_deal_ytm(&mut self) {
        self.deal_ytm = 0.;
    }

    // Param is passed by value, moved
    pub fn set_deal_ytm(&mut self, v: f64) {
        self.deal_ytm = v;
    }

    pub fn get_deal_ytm(&self) -> f64 {
        self.deal_ytm
    }

    // string intr_app_freq = 79;

    pub fn clear_intr_app_freq(&mut self) {
        self.intr_app_freq.clear();
    }

    // Param is passed by value, moved
    pub fn set_intr_app_freq(&mut self, v: ::std::string::String) {
        self.intr_app_freq = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_intr_app_freq(&mut self) -> &mut ::std::string::String {
        &mut self.intr_app_freq
    }

    // Take field
    pub fn take_intr_app_freq(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.intr_app_freq, ::std::string::String::new())
    }

    pub fn get_intr_app_freq(&self) -> &str {
        &self.intr_app_freq
    }

    // string comp_freq = 80;

    pub fn clear_comp_freq(&mut self) {
        self.comp_freq.clear();
    }

    // Param is passed by value, moved
    pub fn set_comp_freq(&mut self, v: ::std::string::String) {
        self.comp_freq = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_comp_freq(&mut self) -> &mut ::std::string::String {
        &mut self.comp_freq
    }

    // Take field
    pub fn take_comp_freq(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.comp_freq, ::std::string::String::new())
    }

    pub fn get_comp_freq(&self) -> &str {
        &self.comp_freq
    }

    // string intr_prac = 81;

    pub fn clear_intr_prac(&mut self) {
        self.intr_prac.clear();
    }

    // Param is passed by value, moved
    pub fn set_intr_prac(&mut self, v: ::std::string::String) {
        self.intr_prac = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_intr_prac(&mut self) -> &mut ::std::string::String {
        &mut self.intr_prac
    }

    // Take field
    pub fn take_intr_prac(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.intr_prac, ::std::string::String::new())
    }

    pub fn get_intr_prac(&self) -> &str {
        &self.intr_prac
    }

    // string rate_spread = 82;

    pub fn clear_rate_spread(&mut self) {
        self.rate_spread.clear();
    }

    // Param is passed by value, moved
    pub fn set_rate_spread(&mut self, v: ::std::string::String) {
        self.rate_spread = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rate_spread(&mut self) -> &mut ::std::string::String {
        &mut self.rate_spread
    }

    // Take field
    pub fn take_rate_spread(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rate_spread, ::std::string::String::new())
    }

    pub fn get_rate_spread(&self) -> &str {
        &self.rate_spread
    }

    // string asset_class = 83;

    pub fn clear_asset_class(&mut self) {
        self.asset_class.clear();
    }

    // Param is passed by value, moved
    pub fn set_asset_class(&mut self, v: ::std::string::String) {
        self.asset_class = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_asset_class(&mut self) -> &mut ::std::string::String {
        &mut self.asset_class
    }

    // Take field
    pub fn take_asset_class(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.asset_class, ::std::string::String::new())
    }

    pub fn get_asset_class(&self) -> &str {
        &self.asset_class
    }

    // string intr_typ = 84;

    pub fn clear_intr_typ(&mut self) {
        self.intr_typ.clear();
    }

    // Param is passed by value, moved
    pub fn set_intr_typ(&mut self, v: ::std::string::String) {
        self.intr_typ = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_intr_typ(&mut self) -> &mut ::std::string::String {
        &mut self.intr_typ
    }

    // Take field
    pub fn take_intr_typ(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.intr_typ, ::std::string::String::new())
    }

    pub fn get_intr_typ(&self) -> &str {
        &self.intr_typ
    }

    // int64 sec_issuance_date = 85;

    pub fn clear_sec_issuance_date(&mut self) {
        self.sec_issuance_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_sec_issuance_date(&mut self, v: i64) {
        self.sec_issuance_date = v;
    }

    pub fn get_sec_issuance_date(&self) -> i64 {
        self.sec_issuance_date
    }

    // string coupon = 86;

    pub fn clear_coupon(&mut self) {
        self.coupon.clear();
    }

    // Param is passed by value, moved
    pub fn set_coupon(&mut self, v: ::std::string::String) {
        self.coupon = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_coupon(&mut self) -> &mut ::std::string::String {
        &mut self.coupon
    }

    // Take field
    pub fn take_coupon(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.coupon, ::std::string::String::new())
    }

    pub fn get_coupon(&self) -> &str {
        &self.coupon
    }

    // int64 last_intr_dt = 87;

    pub fn clear_last_intr_dt(&mut self) {
        self.last_intr_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_last_intr_dt(&mut self, v: i64) {
        self.last_intr_dt = v;
    }

    pub fn get_last_intr_dt(&self) -> i64 {
        self.last_intr_dt
    }

    // int64 next_intr_dt = 88;

    pub fn clear_next_intr_dt(&mut self) {
        self.next_intr_dt = 0;
    }

    // Param is passed by value, moved
    pub fn set_next_intr_dt(&mut self, v: i64) {
        self.next_intr_dt = v;
    }

    pub fn get_next_intr_dt(&self) -> i64 {
        self.next_intr_dt
    }

    // double amort_till_dt = 89;

    pub fn clear_amort_till_dt(&mut self) {
        self.amort_till_dt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_amort_till_dt(&mut self, v: f64) {
        self.amort_till_dt = v;
    }

    pub fn get_amort_till_dt(&self) -> f64 {
        self.amort_till_dt
    }

    // double tot_int_amt = 90;

    pub fn clear_tot_int_amt(&mut self) {
        self.tot_int_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tot_int_amt(&mut self, v: f64) {
        self.tot_int_amt = v;
    }

    pub fn get_tot_int_amt(&self) -> f64 {
        self.tot_int_amt
    }

    // double tot_prin_amt = 91;

    pub fn clear_tot_prin_amt(&mut self) {
        self.tot_prin_amt = 0.;
    }

    // Param is passed by value, moved
    pub fn set_tot_prin_amt(&mut self, v: f64) {
        self.tot_prin_amt = v;
    }

    pub fn get_tot_prin_amt(&self) -> f64 {
        self.tot_prin_amt
    }

    // int32 Method = 92;

    pub fn clear_Method(&mut self) {
        self.Method = 0;
    }

    // Param is passed by value, moved
    pub fn set_Method(&mut self, v: i32) {
        self.Method = v;
    }

    pub fn get_Method(&self) -> i32 {
        self.Method
    }

    // int32 BaseCurve = 93;

    pub fn clear_BaseCurve(&mut self) {
        self.BaseCurve = 0;
    }

    // Param is passed by value, moved
    pub fn set_BaseCurve(&mut self, v: i32) {
        self.BaseCurve = v;
    }

    pub fn get_BaseCurve(&self) -> i32 {
        self.BaseCurve
    }

    // int64 ftp_runid = 94;

    pub fn clear_ftp_runid(&mut self) {
        self.ftp_runid = 0;
    }

    // Param is passed by value, moved
    pub fn set_ftp_runid(&mut self, v: i64) {
        self.ftp_runid = v;
    }

    pub fn get_ftp_runid(&self) -> i64 {
        self.ftp_runid
    }

    // int32 from_date = 95;

    pub fn clear_from_date(&mut self) {
        self.from_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_from_date(&mut self, v: i32) {
        self.from_date = v;
    }

    pub fn get_from_date(&self) -> i32 {
        self.from_date
    }

    // int32 to_date = 96;

    pub fn clear_to_date(&mut self) {
        self.to_date = 0;
    }

    // Param is passed by value, moved
    pub fn set_to_date(&mut self, v: i32) {
        self.to_date = v;
    }

    pub fn get_to_date(&self) -> i32 {
        self.to_date
    }

    // double total_balance = 97;

    pub fn clear_total_balance(&mut self) {
        self.total_balance = 0.;
    }

    // Param is passed by value, moved
    pub fn set_total_balance(&mut self, v: f64) {
        self.total_balance = v;
    }

    pub fn get_total_balance(&self) -> f64 {
        self.total_balance
    }

    // double total_interest_ftp = 98;

    pub fn clear_total_interest_ftp(&mut self) {
        self.total_interest_ftp = 0.;
    }

    // Param is passed by value, moved
    pub fn set_total_interest_ftp(&mut self, v: f64) {
        self.total_interest_ftp = v;
    }

    pub fn get_total_interest_ftp(&self) -> f64 {
        self.total_interest_ftp
    }

    // double total_ftp = 99;

    pub fn clear_total_ftp(&mut self) {
        self.total_ftp = 0.;
    }

    // Param is passed by value, moved
    pub fn set_total_ftp(&mut self, v: f64) {
        self.total_ftp = v;
    }

    pub fn get_total_ftp(&self) -> f64 {
        self.total_ftp
    }

    // double FTP_Rate = 100;

    pub fn clear_FTP_Rate(&mut self) {
        self.FTP_Rate = 0.;
    }

    // Param is passed by value, moved
    pub fn set_FTP_Rate(&mut self, v: f64) {
        self.FTP_Rate = v;
    }

    pub fn get_FTP_Rate(&self) -> f64 {
        self.FTP_Rate
    }

    // repeated .Cashflow cashflows = 101;

    pub fn clear_cashflows(&mut self) {
        self.cashflows.clear();
    }

    // Param is passed by value, moved
    pub fn set_cashflows(&mut self, v: ::protobuf::RepeatedField<Cashflow>) {
        self.cashflows = v;
    }

    // Mutable pointer to the field.
    pub fn mut_cashflows(&mut self) -> &mut ::protobuf::RepeatedField<Cashflow> {
        &mut self.cashflows
    }

    // Take field
    pub fn take_cashflows(&mut self) -> ::protobuf::RepeatedField<Cashflow> {
        ::std::mem::replace(&mut self.cashflows, ::protobuf::RepeatedField::new())
    }

    pub fn get_cashflows(&self) -> &[Cashflow] {
        &self.cashflows
    }
}

impl ::protobuf::Message for AccountWithCashflows {
    fn is_initialized(&self) -> bool {
        for v in &self.cashflows {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.deal_no)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.short_name)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nxt_rep_dt = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.call_dt = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.put_dt = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deal_dt = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.portfolio)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.deal_rt = tmp;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.org_face_val = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.os_face_val = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.org_cst_val = tmp;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.acrd_int = tmp;
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.book_yield = tmp;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.int_basis = tmp;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.avg_os_vd = tmp;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.avg_os_dd = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.prin_amt = tmp;
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.org_bal = tmp;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.coup_rt = tmp;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nxt_coup_dt = tmp;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gl = tmp;
                },
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cf_dt = tmp;
                },
                23 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.secu_desc)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prod_desc)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prod_cd)?;
                },
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lst_coup_dt = tmp;
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.call_dt1 = tmp;
                },
                28 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.coup_freq)?;
                },
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.val_dt = tmp;
                },
                30 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.acrl_freq)?;
                },
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lst_rep_dt = tmp;
                },
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.lst_put_dt = tmp;
                },
                33 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.inst)?;
                },
                34 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.org_term = tmp;
                },
                35 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.acrl_basis)?;
                },
                36 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.div)?;
                },
                37 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.alm_line)?;
                },
                38 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.ia_line)?;
                },
                39 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cmpnd_freq = tmp;
                },
                40 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nxt_cmpnd_dt = tmp;
                },
                41 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.rt_chng_freq = tmp;
                },
                42 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rt_flg)?;
                },
                43 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rep_idx)?;
                },
                44 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.nxt_pay_dt = tmp;
                },
                45 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.prev_rep_dt = tmp;
                },
                46 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.int_pay_freq = tmp;
                },
                47 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.int_rt = tmp;
                },
                48 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.port_typ)?;
                },
                49 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sec_grp)?;
                },
                50 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sec_type)?;
                },
                51 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sec_issuer)?;
                },
                52 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sec_guaranteed)?;
                },
                53 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.mrkt)?;
                },
                54 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.idx_label)?;
                },
                55 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bd_categ)?;
                },
                56 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bd_type)?;
                },
                57 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.listed)?;
                },
                58 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.npa_class)?;
                },
                59 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.entity)?;
                },
                60 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.desk)?;
                },
                61 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.acc_sec_igaap)?;
                },
                62 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.os_cv_before_amort = tmp;
                },
                63 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.os_cv_after_amort = tmp;
                },
                64 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.mat_dt = tmp;
                },
                65 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.int_amt = tmp;
                },
                66 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.flow_type)?;
                },
                67 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.isin)?;
                },
                68 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.org_tenor = tmp;
                },
                69 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.rep_tenor = tmp;
                },
                70 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ftp_mat_dt = tmp;
                },
                71 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contract_no)?;
                },
                72 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.instr_id)?;
                },
                73 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.parent_code)?;
                },
                74 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.issuer_name)?;
                },
                75 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rating)?;
                },
                76 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.tax_status)?;
                },
                77 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.slr_nslr)?;
                },
                78 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.deal_ytm = tmp;
                },
                79 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.intr_app_freq)?;
                },
                80 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.comp_freq)?;
                },
                81 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.intr_prac)?;
                },
                82 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rate_spread)?;
                },
                83 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.asset_class)?;
                },
                84 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.intr_typ)?;
                },
                85 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sec_issuance_date = tmp;
                },
                86 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.coupon)?;
                },
                87 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.last_intr_dt = tmp;
                },
                88 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.next_intr_dt = tmp;
                },
                89 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.amort_till_dt = tmp;
                },
                90 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.tot_int_amt = tmp;
                },
                91 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.tot_prin_amt = tmp;
                },
                92 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Method = tmp;
                },
                93 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.BaseCurve = tmp;
                },
                94 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ftp_runid = tmp;
                },
                95 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.from_date = tmp;
                },
                96 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.to_date = tmp;
                },
                97 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.total_balance = tmp;
                },
                98 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.total_interest_ftp = tmp;
                },
                99 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.total_ftp = tmp;
                },
                100 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.FTP_Rate = tmp;
                },
                101 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.cashflows)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.deal_no.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.deal_no);
        }
        if !self.short_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.short_name);
        }
        if self.nxt_rep_dt != 0 {
            my_size += ::protobuf::rt::value_size(3, self.nxt_rep_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.call_dt != 0 {
            my_size += ::protobuf::rt::value_size(4, self.call_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.put_dt != 0 {
            my_size += ::protobuf::rt::value_size(5, self.put_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.deal_dt != 0 {
            my_size += ::protobuf::rt::value_size(6, self.deal_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.portfolio.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.portfolio);
        }
        if self.deal_rt != 0. {
            my_size += 9;
        }
        if self.org_face_val != 0 {
            my_size += ::protobuf::rt::value_size(9, self.org_face_val, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.os_face_val != 0 {
            my_size += ::protobuf::rt::value_size(10, self.os_face_val, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.org_cst_val != 0. {
            my_size += 9;
        }
        if self.acrd_int != 0. {
            my_size += 9;
        }
        if self.book_yield != 0. {
            my_size += 9;
        }
        if self.int_basis != 0 {
            my_size += ::protobuf::rt::value_size(14, self.int_basis, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.avg_os_vd != 0. {
            my_size += 9;
        }
        if self.avg_os_dd != 0. {
            my_size += 10;
        }
        if self.prin_amt != 0. {
            my_size += 10;
        }
        if self.org_bal != 0. {
            my_size += 10;
        }
        if self.coup_rt != 0. {
            my_size += 10;
        }
        if self.nxt_coup_dt != 0 {
            my_size += ::protobuf::rt::value_size(20, self.nxt_coup_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.gl != 0 {
            my_size += ::protobuf::rt::value_size(21, self.gl, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.cf_dt != 0 {
            my_size += ::protobuf::rt::value_size(22, self.cf_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.secu_desc.is_empty() {
            my_size += ::protobuf::rt::string_size(23, &self.secu_desc);
        }
        if !self.prod_desc.is_empty() {
            my_size += ::protobuf::rt::string_size(24, &self.prod_desc);
        }
        if !self.prod_cd.is_empty() {
            my_size += ::protobuf::rt::string_size(25, &self.prod_cd);
        }
        if self.lst_coup_dt != 0 {
            my_size += ::protobuf::rt::value_size(26, self.lst_coup_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.call_dt1 != 0 {
            my_size += ::protobuf::rt::value_size(27, self.call_dt1, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.coup_freq.is_empty() {
            my_size += ::protobuf::rt::string_size(28, &self.coup_freq);
        }
        if self.val_dt != 0 {
            my_size += ::protobuf::rt::value_size(29, self.val_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.acrl_freq.is_empty() {
            my_size += ::protobuf::rt::string_size(30, &self.acrl_freq);
        }
        if self.lst_rep_dt != 0 {
            my_size += ::protobuf::rt::value_size(31, self.lst_rep_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.lst_put_dt != 0 {
            my_size += ::protobuf::rt::value_size(32, self.lst_put_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.inst.is_empty() {
            my_size += ::protobuf::rt::string_size(33, &self.inst);
        }
        if self.org_term != 0 {
            my_size += ::protobuf::rt::value_size(34, self.org_term, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.acrl_basis.is_empty() {
            my_size += ::protobuf::rt::string_size(35, &self.acrl_basis);
        }
        if !self.div.is_empty() {
            my_size += ::protobuf::rt::string_size(36, &self.div);
        }
        if !self.alm_line.is_empty() {
            my_size += ::protobuf::rt::string_size(37, &self.alm_line);
        }
        if !self.ia_line.is_empty() {
            my_size += ::protobuf::rt::string_size(38, &self.ia_line);
        }
        if self.cmpnd_freq != 0 {
            my_size += ::protobuf::rt::value_size(39, self.cmpnd_freq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nxt_cmpnd_dt != 0 {
            my_size += ::protobuf::rt::value_size(40, self.nxt_cmpnd_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rt_chng_freq != 0 {
            my_size += ::protobuf::rt::value_size(41, self.rt_chng_freq, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.rt_flg.is_empty() {
            my_size += ::protobuf::rt::string_size(42, &self.rt_flg);
        }
        if !self.rep_idx.is_empty() {
            my_size += ::protobuf::rt::string_size(43, &self.rep_idx);
        }
        if self.nxt_pay_dt != 0 {
            my_size += ::protobuf::rt::value_size(44, self.nxt_pay_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.prev_rep_dt != 0 {
            my_size += ::protobuf::rt::value_size(45, self.prev_rep_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.int_pay_freq != 0 {
            my_size += ::protobuf::rt::value_size(46, self.int_pay_freq, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.int_rt != 0. {
            my_size += 10;
        }
        if !self.port_typ.is_empty() {
            my_size += ::protobuf::rt::string_size(48, &self.port_typ);
        }
        if !self.sec_grp.is_empty() {
            my_size += ::protobuf::rt::string_size(49, &self.sec_grp);
        }
        if !self.sec_type.is_empty() {
            my_size += ::protobuf::rt::string_size(50, &self.sec_type);
        }
        if !self.sec_issuer.is_empty() {
            my_size += ::protobuf::rt::string_size(51, &self.sec_issuer);
        }
        if !self.sec_guaranteed.is_empty() {
            my_size += ::protobuf::rt::string_size(52, &self.sec_guaranteed);
        }
        if !self.mrkt.is_empty() {
            my_size += ::protobuf::rt::string_size(53, &self.mrkt);
        }
        if !self.idx_label.is_empty() {
            my_size += ::protobuf::rt::string_size(54, &self.idx_label);
        }
        if !self.bd_categ.is_empty() {
            my_size += ::protobuf::rt::string_size(55, &self.bd_categ);
        }
        if !self.bd_type.is_empty() {
            my_size += ::protobuf::rt::string_size(56, &self.bd_type);
        }
        if !self.listed.is_empty() {
            my_size += ::protobuf::rt::string_size(57, &self.listed);
        }
        if !self.npa_class.is_empty() {
            my_size += ::protobuf::rt::string_size(58, &self.npa_class);
        }
        if !self.entity.is_empty() {
            my_size += ::protobuf::rt::string_size(59, &self.entity);
        }
        if !self.desk.is_empty() {
            my_size += ::protobuf::rt::string_size(60, &self.desk);
        }
        if !self.acc_sec_igaap.is_empty() {
            my_size += ::protobuf::rt::string_size(61, &self.acc_sec_igaap);
        }
        if self.os_cv_before_amort != 0. {
            my_size += 10;
        }
        if self.os_cv_after_amort != 0. {
            my_size += 10;
        }
        if self.mat_dt != 0 {
            my_size += ::protobuf::rt::value_size(64, self.mat_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.int_amt != 0. {
            my_size += 10;
        }
        if !self.flow_type.is_empty() {
            my_size += ::protobuf::rt::string_size(66, &self.flow_type);
        }
        if !self.isin.is_empty() {
            my_size += ::protobuf::rt::string_size(67, &self.isin);
        }
        if self.org_tenor != 0 {
            my_size += ::protobuf::rt::value_size(68, self.org_tenor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.rep_tenor != 0 {
            my_size += ::protobuf::rt::value_size(69, self.rep_tenor, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ftp_mat_dt != 0 {
            my_size += ::protobuf::rt::value_size(70, self.ftp_mat_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.contract_no.is_empty() {
            my_size += ::protobuf::rt::string_size(71, &self.contract_no);
        }
        if !self.instr_id.is_empty() {
            my_size += ::protobuf::rt::string_size(72, &self.instr_id);
        }
        if !self.parent_code.is_empty() {
            my_size += ::protobuf::rt::string_size(73, &self.parent_code);
        }
        if !self.issuer_name.is_empty() {
            my_size += ::protobuf::rt::string_size(74, &self.issuer_name);
        }
        if !self.rating.is_empty() {
            my_size += ::protobuf::rt::string_size(75, &self.rating);
        }
        if !self.tax_status.is_empty() {
            my_size += ::protobuf::rt::string_size(76, &self.tax_status);
        }
        if !self.slr_nslr.is_empty() {
            my_size += ::protobuf::rt::string_size(77, &self.slr_nslr);
        }
        if self.deal_ytm != 0. {
            my_size += 10;
        }
        if !self.intr_app_freq.is_empty() {
            my_size += ::protobuf::rt::string_size(79, &self.intr_app_freq);
        }
        if !self.comp_freq.is_empty() {
            my_size += ::protobuf::rt::string_size(80, &self.comp_freq);
        }
        if !self.intr_prac.is_empty() {
            my_size += ::protobuf::rt::string_size(81, &self.intr_prac);
        }
        if !self.rate_spread.is_empty() {
            my_size += ::protobuf::rt::string_size(82, &self.rate_spread);
        }
        if !self.asset_class.is_empty() {
            my_size += ::protobuf::rt::string_size(83, &self.asset_class);
        }
        if !self.intr_typ.is_empty() {
            my_size += ::protobuf::rt::string_size(84, &self.intr_typ);
        }
        if self.sec_issuance_date != 0 {
            my_size += ::protobuf::rt::value_size(85, self.sec_issuance_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.coupon.is_empty() {
            my_size += ::protobuf::rt::string_size(86, &self.coupon);
        }
        if self.last_intr_dt != 0 {
            my_size += ::protobuf::rt::value_size(87, self.last_intr_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.next_intr_dt != 0 {
            my_size += ::protobuf::rt::value_size(88, self.next_intr_dt, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.amort_till_dt != 0. {
            my_size += 10;
        }
        if self.tot_int_amt != 0. {
            my_size += 10;
        }
        if self.tot_prin_amt != 0. {
            my_size += 10;
        }
        if self.Method != 0 {
            my_size += ::protobuf::rt::value_size(92, self.Method, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.BaseCurve != 0 {
            my_size += ::protobuf::rt::value_size(93, self.BaseCurve, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.ftp_runid != 0 {
            my_size += ::protobuf::rt::value_size(94, self.ftp_runid, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.from_date != 0 {
            my_size += ::protobuf::rt::value_size(95, self.from_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.to_date != 0 {
            my_size += ::protobuf::rt::value_size(96, self.to_date, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.total_balance != 0. {
            my_size += 10;
        }
        if self.total_interest_ftp != 0. {
            my_size += 10;
        }
        if self.total_ftp != 0. {
            my_size += 10;
        }
        if self.FTP_Rate != 0. {
            my_size += 10;
        }
        for value in &self.cashflows {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream) -> ::protobuf::ProtobufResult<()> {
        if !self.deal_no.is_empty() {
            os.write_string(1, &self.deal_no)?;
        }
        if !self.short_name.is_empty() {
            os.write_string(2, &self.short_name)?;
        }
        if self.nxt_rep_dt != 0 {
            os.write_int64(3, self.nxt_rep_dt)?;
        }
        if self.call_dt != 0 {
            os.write_int64(4, self.call_dt)?;
        }
        if self.put_dt != 0 {
            os.write_int64(5, self.put_dt)?;
        }
        if self.deal_dt != 0 {
            os.write_int64(6, self.deal_dt)?;
        }
        if !self.portfolio.is_empty() {
            os.write_string(7, &self.portfolio)?;
        }
        if self.deal_rt != 0. {
            os.write_double(8, self.deal_rt)?;
        }
        if self.org_face_val != 0 {
            os.write_int64(9, self.org_face_val)?;
        }
        if self.os_face_val != 0 {
            os.write_int64(10, self.os_face_val)?;
        }
        if self.org_cst_val != 0. {
            os.write_double(11, self.org_cst_val)?;
        }
        if self.acrd_int != 0. {
            os.write_double(12, self.acrd_int)?;
        }
        if self.book_yield != 0. {
            os.write_double(13, self.book_yield)?;
        }
        if self.int_basis != 0 {
            os.write_int64(14, self.int_basis)?;
        }
        if self.avg_os_vd != 0. {
            os.write_double(15, self.avg_os_vd)?;
        }
        if self.avg_os_dd != 0. {
            os.write_double(16, self.avg_os_dd)?;
        }
        if self.prin_amt != 0. {
            os.write_double(17, self.prin_amt)?;
        }
        if self.org_bal != 0. {
            os.write_double(18, self.org_bal)?;
        }
        if self.coup_rt != 0. {
            os.write_double(19, self.coup_rt)?;
        }
        if self.nxt_coup_dt != 0 {
            os.write_int64(20, self.nxt_coup_dt)?;
        }
        if self.gl != 0 {
            os.write_int64(21, self.gl)?;
        }
        if self.cf_dt != 0 {
            os.write_int64(22, self.cf_dt)?;
        }
        if !self.secu_desc.is_empty() {
            os.write_string(23, &self.secu_desc)?;
        }
        if !self.prod_desc.is_empty() {
            os.write_string(24, &self.prod_desc)?;
        }
        if !self.prod_cd.is_empty() {
            os.write_string(25, &self.prod_cd)?;
        }
        if self.lst_coup_dt != 0 {
            os.write_int64(26, self.lst_coup_dt)?;
        }
        if self.call_dt1 != 0 {
            os.write_int64(27, self.call_dt1)?;
        }
        if !self.coup_freq.is_empty() {
            os.write_string(28, &self.coup_freq)?;
        }
        if self.val_dt != 0 {
            os.write_int64(29, self.val_dt)?;
        }
        if !self.acrl_freq.is_empty() {
            os.write_string(30, &self.acrl_freq)?;
        }
        if self.lst_rep_dt != 0 {
            os.write_int64(31, self.lst_rep_dt)?;
        }
        if self.lst_put_dt != 0 {
            os.write_int64(32, self.lst_put_dt)?;
        }
        if !self.inst.is_empty() {
            os.write_string(33, &self.inst)?;
        }
        if self.org_term != 0 {
            os.write_int64(34, self.org_term)?;
        }
        if !self.acrl_basis.is_empty() {
            os.write_string(35, &self.acrl_basis)?;
        }
        if !self.div.is_empty() {
            os.write_string(36, &self.div)?;
        }
        if !self.alm_line.is_empty() {
            os.write_string(37, &self.alm_line)?;
        }
        if !self.ia_line.is_empty() {
            os.write_string(38, &self.ia_line)?;
        }
        if self.cmpnd_freq != 0 {
            os.write_int64(39, self.cmpnd_freq)?;
        }
        if self.nxt_cmpnd_dt != 0 {
            os.write_int64(40, self.nxt_cmpnd_dt)?;
        }
        if self.rt_chng_freq != 0 {
            os.write_int64(41, self.rt_chng_freq)?;
        }
        if !self.rt_flg.is_empty() {
            os.write_string(42, &self.rt_flg)?;
        }
        if !self.rep_idx.is_empty() {
            os.write_string(43, &self.rep_idx)?;
        }
        if self.nxt_pay_dt != 0 {
            os.write_int64(44, self.nxt_pay_dt)?;
        }
        if self.prev_rep_dt != 0 {
            os.write_int64(45, self.prev_rep_dt)?;
        }
        if self.int_pay_freq != 0 {
            os.write_int64(46, self.int_pay_freq)?;
        }
        if self.int_rt != 0. {
            os.write_double(47, self.int_rt)?;
        }
        if !self.port_typ.is_empty() {
            os.write_string(48, &self.port_typ)?;
        }
        if !self.sec_grp.is_empty() {
            os.write_string(49, &self.sec_grp)?;
        }
        if !self.sec_type.is_empty() {
            os.write_string(50, &self.sec_type)?;
        }
        if !self.sec_issuer.is_empty() {
            os.write_string(51, &self.sec_issuer)?;
        }
        if !self.sec_guaranteed.is_empty() {
            os.write_string(52, &self.sec_guaranteed)?;
        }
        if !self.mrkt.is_empty() {
            os.write_string(53, &self.mrkt)?;
        }
        if !self.idx_label.is_empty() {
            os.write_string(54, &self.idx_label)?;
        }
        if !self.bd_categ.is_empty() {
            os.write_string(55, &self.bd_categ)?;
        }
        if !self.bd_type.is_empty() {
            os.write_string(56, &self.bd_type)?;
        }
        if !self.listed.is_empty() {
            os.write_string(57, &self.listed)?;
        }
        if !self.npa_class.is_empty() {
            os.write_string(58, &self.npa_class)?;
        }
        if !self.entity.is_empty() {
            os.write_string(59, &self.entity)?;
        }
        if !self.desk.is_empty() {
            os.write_string(60, &self.desk)?;
        }
        if !self.acc_sec_igaap.is_empty() {
            os.write_string(61, &self.acc_sec_igaap)?;
        }
        if self.os_cv_before_amort != 0. {
            os.write_double(62, self.os_cv_before_amort)?;
        }
        if self.os_cv_after_amort != 0. {
            os.write_double(63, self.os_cv_after_amort)?;
        }
        if self.mat_dt != 0 {
            os.write_int64(64, self.mat_dt)?;
        }
        if self.int_amt != 0. {
            os.write_double(65, self.int_amt)?;
        }
        if !self.flow_type.is_empty() {
            os.write_string(66, &self.flow_type)?;
        }
        if !self.isin.is_empty() {
            os.write_string(67, &self.isin)?;
        }
        if self.org_tenor != 0 {
            os.write_int64(68, self.org_tenor)?;
        }
        if self.rep_tenor != 0 {
            os.write_int64(69, self.rep_tenor)?;
        }
        if self.ftp_mat_dt != 0 {
            os.write_int64(70, self.ftp_mat_dt)?;
        }
        if !self.contract_no.is_empty() {
            os.write_string(71, &self.contract_no)?;
        }
        if !self.instr_id.is_empty() {
            os.write_string(72, &self.instr_id)?;
        }
        if !self.parent_code.is_empty() {
            os.write_string(73, &self.parent_code)?;
        }
        if !self.issuer_name.is_empty() {
            os.write_string(74, &self.issuer_name)?;
        }
        if !self.rating.is_empty() {
            os.write_string(75, &self.rating)?;
        }
        if !self.tax_status.is_empty() {
            os.write_string(76, &self.tax_status)?;
        }
        if !self.slr_nslr.is_empty() {
            os.write_string(77, &self.slr_nslr)?;
        }
        if self.deal_ytm != 0. {
            os.write_double(78, self.deal_ytm)?;
        }
        if !self.intr_app_freq.is_empty() {
            os.write_string(79, &self.intr_app_freq)?;
        }
        if !self.comp_freq.is_empty() {
            os.write_string(80, &self.comp_freq)?;
        }
        if !self.intr_prac.is_empty() {
            os.write_string(81, &self.intr_prac)?;
        }
        if !self.rate_spread.is_empty() {
            os.write_string(82, &self.rate_spread)?;
        }
        if !self.asset_class.is_empty() {
            os.write_string(83, &self.asset_class)?;
        }
        if !self.intr_typ.is_empty() {
            os.write_string(84, &self.intr_typ)?;
        }
        if self.sec_issuance_date != 0 {
            os.write_int64(85, self.sec_issuance_date)?;
        }
        if !self.coupon.is_empty() {
            os.write_string(86, &self.coupon)?;
        }
        if self.last_intr_dt != 0 {
            os.write_int64(87, self.last_intr_dt)?;
        }
        if self.next_intr_dt != 0 {
            os.write_int64(88, self.next_intr_dt)?;
        }
        if self.amort_till_dt != 0. {
            os.write_double(89, self.amort_till_dt)?;
        }
        if self.tot_int_amt != 0. {
            os.write_double(90, self.tot_int_amt)?;
        }
        if self.tot_prin_amt != 0. {
            os.write_double(91, self.tot_prin_amt)?;
        }
        if self.Method != 0 {
            os.write_int32(92, self.Method)?;
        }
        if self.BaseCurve != 0 {
            os.write_int32(93, self.BaseCurve)?;
        }
        if self.ftp_runid != 0 {
            os.write_int64(94, self.ftp_runid)?;
        }
        if self.from_date != 0 {
            os.write_int32(95, self.from_date)?;
        }
        if self.to_date != 0 {
            os.write_int32(96, self.to_date)?;
        }
        if self.total_balance != 0. {
            os.write_double(97, self.total_balance)?;
        }
        if self.total_interest_ftp != 0. {
            os.write_double(98, self.total_interest_ftp)?;
        }
        if self.total_ftp != 0. {
            os.write_double(99, self.total_ftp)?;
        }
        if self.FTP_Rate != 0. {
            os.write_double(100, self.FTP_Rate)?;
        }
        for v in &self.cashflows {
            os.write_tag(101, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &::std::any::Any {
        self as &::std::any::Any
    }
    fn as_any_mut(&mut self) -> &mut ::std::any::Any {
        self as &mut ::std::any::Any
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<::std::any::Any> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AccountWithCashflows {
        AccountWithCashflows::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const ::protobuf::reflect::MessageDescriptor,
        };
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "deal_no",
                    |m: &AccountWithCashflows| { &m.deal_no },
                    |m: &mut AccountWithCashflows| { &mut m.deal_no },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "short_name",
                    |m: &AccountWithCashflows| { &m.short_name },
                    |m: &mut AccountWithCashflows| { &mut m.short_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "nxt_rep_dt",
                    |m: &AccountWithCashflows| { &m.nxt_rep_dt },
                    |m: &mut AccountWithCashflows| { &mut m.nxt_rep_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "call_dt",
                    |m: &AccountWithCashflows| { &m.call_dt },
                    |m: &mut AccountWithCashflows| { &mut m.call_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "put_dt",
                    |m: &AccountWithCashflows| { &m.put_dt },
                    |m: &mut AccountWithCashflows| { &mut m.put_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "deal_dt",
                    |m: &AccountWithCashflows| { &m.deal_dt },
                    |m: &mut AccountWithCashflows| { &mut m.deal_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "portfolio",
                    |m: &AccountWithCashflows| { &m.portfolio },
                    |m: &mut AccountWithCashflows| { &mut m.portfolio },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "deal_rt",
                    |m: &AccountWithCashflows| { &m.deal_rt },
                    |m: &mut AccountWithCashflows| { &mut m.deal_rt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "org_face_val",
                    |m: &AccountWithCashflows| { &m.org_face_val },
                    |m: &mut AccountWithCashflows| { &mut m.org_face_val },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "os_face_val",
                    |m: &AccountWithCashflows| { &m.os_face_val },
                    |m: &mut AccountWithCashflows| { &mut m.os_face_val },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "org_cst_val",
                    |m: &AccountWithCashflows| { &m.org_cst_val },
                    |m: &mut AccountWithCashflows| { &mut m.org_cst_val },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "acrd_int",
                    |m: &AccountWithCashflows| { &m.acrd_int },
                    |m: &mut AccountWithCashflows| { &mut m.acrd_int },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "book_yield",
                    |m: &AccountWithCashflows| { &m.book_yield },
                    |m: &mut AccountWithCashflows| { &mut m.book_yield },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "int_basis",
                    |m: &AccountWithCashflows| { &m.int_basis },
                    |m: &mut AccountWithCashflows| { &mut m.int_basis },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "avg_os_vd",
                    |m: &AccountWithCashflows| { &m.avg_os_vd },
                    |m: &mut AccountWithCashflows| { &mut m.avg_os_vd },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "avg_os_dd",
                    |m: &AccountWithCashflows| { &m.avg_os_dd },
                    |m: &mut AccountWithCashflows| { &mut m.avg_os_dd },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "prin_amt",
                    |m: &AccountWithCashflows| { &m.prin_amt },
                    |m: &mut AccountWithCashflows| { &mut m.prin_amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "org_bal",
                    |m: &AccountWithCashflows| { &m.org_bal },
                    |m: &mut AccountWithCashflows| { &mut m.org_bal },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "coup_rt",
                    |m: &AccountWithCashflows| { &m.coup_rt },
                    |m: &mut AccountWithCashflows| { &mut m.coup_rt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "nxt_coup_dt",
                    |m: &AccountWithCashflows| { &m.nxt_coup_dt },
                    |m: &mut AccountWithCashflows| { &mut m.nxt_coup_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "gl",
                    |m: &AccountWithCashflows| { &m.gl },
                    |m: &mut AccountWithCashflows| { &mut m.gl },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cf_dt",
                    |m: &AccountWithCashflows| { &m.cf_dt },
                    |m: &mut AccountWithCashflows| { &mut m.cf_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "secu_desc",
                    |m: &AccountWithCashflows| { &m.secu_desc },
                    |m: &mut AccountWithCashflows| { &mut m.secu_desc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prod_desc",
                    |m: &AccountWithCashflows| { &m.prod_desc },
                    |m: &mut AccountWithCashflows| { &mut m.prod_desc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prod_cd",
                    |m: &AccountWithCashflows| { &m.prod_cd },
                    |m: &mut AccountWithCashflows| { &mut m.prod_cd },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "lst_coup_dt",
                    |m: &AccountWithCashflows| { &m.lst_coup_dt },
                    |m: &mut AccountWithCashflows| { &mut m.lst_coup_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "call_dt1",
                    |m: &AccountWithCashflows| { &m.call_dt1 },
                    |m: &mut AccountWithCashflows| { &mut m.call_dt1 },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "coup_freq",
                    |m: &AccountWithCashflows| { &m.coup_freq },
                    |m: &mut AccountWithCashflows| { &mut m.coup_freq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "val_dt",
                    |m: &AccountWithCashflows| { &m.val_dt },
                    |m: &mut AccountWithCashflows| { &mut m.val_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "acrl_freq",
                    |m: &AccountWithCashflows| { &m.acrl_freq },
                    |m: &mut AccountWithCashflows| { &mut m.acrl_freq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "lst_rep_dt",
                    |m: &AccountWithCashflows| { &m.lst_rep_dt },
                    |m: &mut AccountWithCashflows| { &mut m.lst_rep_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "lst_put_dt",
                    |m: &AccountWithCashflows| { &m.lst_put_dt },
                    |m: &mut AccountWithCashflows| { &mut m.lst_put_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "inst",
                    |m: &AccountWithCashflows| { &m.inst },
                    |m: &mut AccountWithCashflows| { &mut m.inst },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "org_term",
                    |m: &AccountWithCashflows| { &m.org_term },
                    |m: &mut AccountWithCashflows| { &mut m.org_term },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "acrl_basis",
                    |m: &AccountWithCashflows| { &m.acrl_basis },
                    |m: &mut AccountWithCashflows| { &mut m.acrl_basis },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "div",
                    |m: &AccountWithCashflows| { &m.div },
                    |m: &mut AccountWithCashflows| { &mut m.div },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "alm_line",
                    |m: &AccountWithCashflows| { &m.alm_line },
                    |m: &mut AccountWithCashflows| { &mut m.alm_line },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "ia_line",
                    |m: &AccountWithCashflows| { &m.ia_line },
                    |m: &mut AccountWithCashflows| { &mut m.ia_line },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cmpnd_freq",
                    |m: &AccountWithCashflows| { &m.cmpnd_freq },
                    |m: &mut AccountWithCashflows| { &mut m.cmpnd_freq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "nxt_cmpnd_dt",
                    |m: &AccountWithCashflows| { &m.nxt_cmpnd_dt },
                    |m: &mut AccountWithCashflows| { &mut m.nxt_cmpnd_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "rt_chng_freq",
                    |m: &AccountWithCashflows| { &m.rt_chng_freq },
                    |m: &mut AccountWithCashflows| { &mut m.rt_chng_freq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "rt_flg",
                    |m: &AccountWithCashflows| { &m.rt_flg },
                    |m: &mut AccountWithCashflows| { &mut m.rt_flg },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "rep_idx",
                    |m: &AccountWithCashflows| { &m.rep_idx },
                    |m: &mut AccountWithCashflows| { &mut m.rep_idx },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "nxt_pay_dt",
                    |m: &AccountWithCashflows| { &m.nxt_pay_dt },
                    |m: &mut AccountWithCashflows| { &mut m.nxt_pay_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "prev_rep_dt",
                    |m: &AccountWithCashflows| { &m.prev_rep_dt },
                    |m: &mut AccountWithCashflows| { &mut m.prev_rep_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "int_pay_freq",
                    |m: &AccountWithCashflows| { &m.int_pay_freq },
                    |m: &mut AccountWithCashflows| { &mut m.int_pay_freq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "int_rt",
                    |m: &AccountWithCashflows| { &m.int_rt },
                    |m: &mut AccountWithCashflows| { &mut m.int_rt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "port_typ",
                    |m: &AccountWithCashflows| { &m.port_typ },
                    |m: &mut AccountWithCashflows| { &mut m.port_typ },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sec_grp",
                    |m: &AccountWithCashflows| { &m.sec_grp },
                    |m: &mut AccountWithCashflows| { &mut m.sec_grp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sec_type",
                    |m: &AccountWithCashflows| { &m.sec_type },
                    |m: &mut AccountWithCashflows| { &mut m.sec_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sec_issuer",
                    |m: &AccountWithCashflows| { &m.sec_issuer },
                    |m: &mut AccountWithCashflows| { &mut m.sec_issuer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sec_guaranteed",
                    |m: &AccountWithCashflows| { &m.sec_guaranteed },
                    |m: &mut AccountWithCashflows| { &mut m.sec_guaranteed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "mrkt",
                    |m: &AccountWithCashflows| { &m.mrkt },
                    |m: &mut AccountWithCashflows| { &mut m.mrkt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "idx_label",
                    |m: &AccountWithCashflows| { &m.idx_label },
                    |m: &mut AccountWithCashflows| { &mut m.idx_label },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bd_categ",
                    |m: &AccountWithCashflows| { &m.bd_categ },
                    |m: &mut AccountWithCashflows| { &mut m.bd_categ },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bd_type",
                    |m: &AccountWithCashflows| { &m.bd_type },
                    |m: &mut AccountWithCashflows| { &mut m.bd_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "listed",
                    |m: &AccountWithCashflows| { &m.listed },
                    |m: &mut AccountWithCashflows| { &mut m.listed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "npa_class",
                    |m: &AccountWithCashflows| { &m.npa_class },
                    |m: &mut AccountWithCashflows| { &mut m.npa_class },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "entity",
                    |m: &AccountWithCashflows| { &m.entity },
                    |m: &mut AccountWithCashflows| { &mut m.entity },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "desk",
                    |m: &AccountWithCashflows| { &m.desk },
                    |m: &mut AccountWithCashflows| { &mut m.desk },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "acc_sec_igaap",
                    |m: &AccountWithCashflows| { &m.acc_sec_igaap },
                    |m: &mut AccountWithCashflows| { &mut m.acc_sec_igaap },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "os_cv_before_amort",
                    |m: &AccountWithCashflows| { &m.os_cv_before_amort },
                    |m: &mut AccountWithCashflows| { &mut m.os_cv_before_amort },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "os_cv_after_amort",
                    |m: &AccountWithCashflows| { &m.os_cv_after_amort },
                    |m: &mut AccountWithCashflows| { &mut m.os_cv_after_amort },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "mat_dt",
                    |m: &AccountWithCashflows| { &m.mat_dt },
                    |m: &mut AccountWithCashflows| { &mut m.mat_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "int_amt",
                    |m: &AccountWithCashflows| { &m.int_amt },
                    |m: &mut AccountWithCashflows| { &mut m.int_amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "flow_type",
                    |m: &AccountWithCashflows| { &m.flow_type },
                    |m: &mut AccountWithCashflows| { &mut m.flow_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "isin",
                    |m: &AccountWithCashflows| { &m.isin },
                    |m: &mut AccountWithCashflows| { &mut m.isin },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "org_tenor",
                    |m: &AccountWithCashflows| { &m.org_tenor },
                    |m: &mut AccountWithCashflows| { &mut m.org_tenor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "rep_tenor",
                    |m: &AccountWithCashflows| { &m.rep_tenor },
                    |m: &mut AccountWithCashflows| { &mut m.rep_tenor },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ftp_mat_dt",
                    |m: &AccountWithCashflows| { &m.ftp_mat_dt },
                    |m: &mut AccountWithCashflows| { &mut m.ftp_mat_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "contract_no",
                    |m: &AccountWithCashflows| { &m.contract_no },
                    |m: &mut AccountWithCashflows| { &mut m.contract_no },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "instr_id",
                    |m: &AccountWithCashflows| { &m.instr_id },
                    |m: &mut AccountWithCashflows| { &mut m.instr_id },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "parent_code",
                    |m: &AccountWithCashflows| { &m.parent_code },
                    |m: &mut AccountWithCashflows| { &mut m.parent_code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "issuer_name",
                    |m: &AccountWithCashflows| { &m.issuer_name },
                    |m: &mut AccountWithCashflows| { &mut m.issuer_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "rating",
                    |m: &AccountWithCashflows| { &m.rating },
                    |m: &mut AccountWithCashflows| { &mut m.rating },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "tax_status",
                    |m: &AccountWithCashflows| { &m.tax_status },
                    |m: &mut AccountWithCashflows| { &mut m.tax_status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "slr_nslr",
                    |m: &AccountWithCashflows| { &m.slr_nslr },
                    |m: &mut AccountWithCashflows| { &mut m.slr_nslr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "deal_ytm",
                    |m: &AccountWithCashflows| { &m.deal_ytm },
                    |m: &mut AccountWithCashflows| { &mut m.deal_ytm },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "intr_app_freq",
                    |m: &AccountWithCashflows| { &m.intr_app_freq },
                    |m: &mut AccountWithCashflows| { &mut m.intr_app_freq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "comp_freq",
                    |m: &AccountWithCashflows| { &m.comp_freq },
                    |m: &mut AccountWithCashflows| { &mut m.comp_freq },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "intr_prac",
                    |m: &AccountWithCashflows| { &m.intr_prac },
                    |m: &mut AccountWithCashflows| { &mut m.intr_prac },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "rate_spread",
                    |m: &AccountWithCashflows| { &m.rate_spread },
                    |m: &mut AccountWithCashflows| { &mut m.rate_spread },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "asset_class",
                    |m: &AccountWithCashflows| { &m.asset_class },
                    |m: &mut AccountWithCashflows| { &mut m.asset_class },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "intr_typ",
                    |m: &AccountWithCashflows| { &m.intr_typ },
                    |m: &mut AccountWithCashflows| { &mut m.intr_typ },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "sec_issuance_date",
                    |m: &AccountWithCashflows| { &m.sec_issuance_date },
                    |m: &mut AccountWithCashflows| { &mut m.sec_issuance_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "coupon",
                    |m: &AccountWithCashflows| { &m.coupon },
                    |m: &mut AccountWithCashflows| { &mut m.coupon },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "last_intr_dt",
                    |m: &AccountWithCashflows| { &m.last_intr_dt },
                    |m: &mut AccountWithCashflows| { &mut m.last_intr_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "next_intr_dt",
                    |m: &AccountWithCashflows| { &m.next_intr_dt },
                    |m: &mut AccountWithCashflows| { &mut m.next_intr_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "amort_till_dt",
                    |m: &AccountWithCashflows| { &m.amort_till_dt },
                    |m: &mut AccountWithCashflows| { &mut m.amort_till_dt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "tot_int_amt",
                    |m: &AccountWithCashflows| { &m.tot_int_amt },
                    |m: &mut AccountWithCashflows| { &mut m.tot_int_amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "tot_prin_amt",
                    |m: &AccountWithCashflows| { &m.tot_prin_amt },
                    |m: &mut AccountWithCashflows| { &mut m.tot_prin_amt },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "Method",
                    |m: &AccountWithCashflows| { &m.Method },
                    |m: &mut AccountWithCashflows| { &mut m.Method },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "BaseCurve",
                    |m: &AccountWithCashflows| { &m.BaseCurve },
                    |m: &mut AccountWithCashflows| { &mut m.BaseCurve },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "ftp_runid",
                    |m: &AccountWithCashflows| { &m.ftp_runid },
                    |m: &mut AccountWithCashflows| { &mut m.ftp_runid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "from_date",
                    |m: &AccountWithCashflows| { &m.from_date },
                    |m: &mut AccountWithCashflows| { &mut m.from_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "to_date",
                    |m: &AccountWithCashflows| { &m.to_date },
                    |m: &mut AccountWithCashflows| { &mut m.to_date },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "total_balance",
                    |m: &AccountWithCashflows| { &m.total_balance },
                    |m: &mut AccountWithCashflows| { &mut m.total_balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "total_interest_ftp",
                    |m: &AccountWithCashflows| { &m.total_interest_ftp },
                    |m: &mut AccountWithCashflows| { &mut m.total_interest_ftp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "total_ftp",
                    |m: &AccountWithCashflows| { &m.total_ftp },
                    |m: &mut AccountWithCashflows| { &mut m.total_ftp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "FTP_Rate",
                    |m: &AccountWithCashflows| { &m.FTP_Rate },
                    |m: &mut AccountWithCashflows| { &mut m.FTP_Rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Cashflow>>(
                    "cashflows",
                    |m: &AccountWithCashflows| { &m.cashflows },
                    |m: &mut AccountWithCashflows| { &mut m.cashflows },
                ));
                ::protobuf::reflect::MessageDescriptor::new::<AccountWithCashflows>(
                    "AccountWithCashflows",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AccountWithCashflows {
        static mut instance: ::protobuf::lazy::Lazy<AccountWithCashflows> = ::protobuf::lazy::Lazy {
            lock: ::protobuf::lazy::ONCE_INIT,
            ptr: 0 as *const AccountWithCashflows,
        };
        unsafe {
            instance.get(AccountWithCashflows::new)
        }
    }
}

impl ::protobuf::Clear for AccountWithCashflows {
    fn clear(&mut self) {
        self.clear_deal_no();
        self.clear_short_name();
        self.clear_nxt_rep_dt();
        self.clear_call_dt();
        self.clear_put_dt();
        self.clear_deal_dt();
        self.clear_portfolio();
        self.clear_deal_rt();
        self.clear_org_face_val();
        self.clear_os_face_val();
        self.clear_org_cst_val();
        self.clear_acrd_int();
        self.clear_book_yield();
        self.clear_int_basis();
        self.clear_avg_os_vd();
        self.clear_avg_os_dd();
        self.clear_prin_amt();
        self.clear_org_bal();
        self.clear_coup_rt();
        self.clear_nxt_coup_dt();
        self.clear_gl();
        self.clear_cf_dt();
        self.clear_secu_desc();
        self.clear_prod_desc();
        self.clear_prod_cd();
        self.clear_lst_coup_dt();
        self.clear_call_dt1();
        self.clear_coup_freq();
        self.clear_val_dt();
        self.clear_acrl_freq();
        self.clear_lst_rep_dt();
        self.clear_lst_put_dt();
        self.clear_inst();
        self.clear_org_term();
        self.clear_acrl_basis();
        self.clear_div();
        self.clear_alm_line();
        self.clear_ia_line();
        self.clear_cmpnd_freq();
        self.clear_nxt_cmpnd_dt();
        self.clear_rt_chng_freq();
        self.clear_rt_flg();
        self.clear_rep_idx();
        self.clear_nxt_pay_dt();
        self.clear_prev_rep_dt();
        self.clear_int_pay_freq();
        self.clear_int_rt();
        self.clear_port_typ();
        self.clear_sec_grp();
        self.clear_sec_type();
        self.clear_sec_issuer();
        self.clear_sec_guaranteed();
        self.clear_mrkt();
        self.clear_idx_label();
        self.clear_bd_categ();
        self.clear_bd_type();
        self.clear_listed();
        self.clear_npa_class();
        self.clear_entity();
        self.clear_desk();
        self.clear_acc_sec_igaap();
        self.clear_os_cv_before_amort();
        self.clear_os_cv_after_amort();
        self.clear_mat_dt();
        self.clear_int_amt();
        self.clear_flow_type();
        self.clear_isin();
        self.clear_org_tenor();
        self.clear_rep_tenor();
        self.clear_ftp_mat_dt();
        self.clear_contract_no();
        self.clear_instr_id();
        self.clear_parent_code();
        self.clear_issuer_name();
        self.clear_rating();
        self.clear_tax_status();
        self.clear_slr_nslr();
        self.clear_deal_ytm();
        self.clear_intr_app_freq();
        self.clear_comp_freq();
        self.clear_intr_prac();
        self.clear_rate_spread();
        self.clear_asset_class();
        self.clear_intr_typ();
        self.clear_sec_issuance_date();
        self.clear_coupon();
        self.clear_last_intr_dt();
        self.clear_next_intr_dt();
        self.clear_amort_till_dt();
        self.clear_tot_int_amt();
        self.clear_tot_prin_amt();
        self.clear_Method();
        self.clear_BaseCurve();
        self.clear_ftp_runid();
        self.clear_from_date();
        self.clear_to_date();
        self.clear_total_balance();
        self.clear_total_interest_ftp();
        self.clear_total_ftp();
        self.clear_FTP_Rate();
        self.clear_cashflows();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AccountWithCashflows {
    fn fmt(&self, f: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AccountWithCashflows {
    fn as_ref(&self) -> ::protobuf::reflect::ProtobufValueRef {
        ::protobuf::reflect::ProtobufValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x20proto/ftp_stamper_cf_input.proto\"\xe3\x04\n\x08Cashflow\x12'\n\
    \x0finterest_amount\x18\x01\x20\x01(\x01R\x0einterestAmount\x12)\n\x10pr\
    incipal_amount\x18\x02\x20\x01(\x01R\x0fprincipalAmount\x12\x12\n\x04dat\
    e\x18\x03\x20\x01(\x03R\x04date\x12\x1b\n\tbase_rate\x18\x04\x20\x01(\
    \x01R\x08baseRate\x12(\n\x10base_rate_amount\x18\x05\x20\x01(\x01R\x0eba\
    seRateAmount\x12\x1b\n\tadj1_rate\x18\x06\x20\x01(\x01R\x08adj1Rate\x12(\
    \n\x10adj1_rate_amount\x18\x07\x20\x01(\x01R\x0eadj1RateAmount\x12\x1b\n\
    \tadj2_rate\x18\x08\x20\x01(\x01R\x08adj2Rate\x12(\n\x10adj2_rate_amount\
    \x18\t\x20\x01(\x01R\x0eadj2RateAmount\x12\x1b\n\tadj3_rate\x18\n\x20\
    \x01(\x01R\x08adj3Rate\x12(\n\x10adj3_rate_amount\x18\x0b\x20\x01(\x01R\
    \x0eadj3RateAmount\x12\x1b\n\tadj4_rate\x18\x0c\x20\x01(\x01R\x08adj4Rat\
    e\x12(\n\x10adj4_rate_amount\x18\r\x20\x01(\x01R\x0eadj4RateAmount\x12\
    \x1b\n\tadj5_rate\x18\x0e\x20\x01(\x01R\x08adj5Rate\x12(\n\x10adj5_rate_\
    amount\x18\x0f\x20\x01(\x01R\x0eadj5RateAmount\x12\x1b\n\tadj6_rate\x18\
    \x10\x20\x01(\x01R\x08adj6Rate\x12(\n\x10adj6_rate_amount\x18\x11\x20\
    \x01(\x01R\x0eadj6RateAmount\"\x89\x17\n\x14AccountWithCashflows\x12\x17\
    \n\x07deal_no\x18\x01\x20\x01(\tR\x06dealNo\x12\x1d\n\nshort_name\x18\
    \x02\x20\x01(\tR\tshortName\x12\x1c\n\nnxt_rep_dt\x18\x03\x20\x01(\x03R\
    \x08nxtRepDt\x12\x17\n\x07call_dt\x18\x04\x20\x01(\x03R\x06callDt\x12\
    \x15\n\x06put_dt\x18\x05\x20\x01(\x03R\x05putDt\x12\x17\n\x07deal_dt\x18\
    \x06\x20\x01(\x03R\x06dealDt\x12\x1c\n\tportfolio\x18\x07\x20\x01(\tR\tp\
    ortfolio\x12\x17\n\x07deal_rt\x18\x08\x20\x01(\x01R\x06dealRt\x12\x20\n\
    \x0corg_face_val\x18\t\x20\x01(\x03R\norgFaceVal\x12\x1e\n\x0bos_face_va\
    l\x18\n\x20\x01(\x03R\tosFaceVal\x12\x1e\n\x0borg_cst_val\x18\x0b\x20\
    \x01(\x01R\torgCstVal\x12\x19\n\x08acrd_int\x18\x0c\x20\x01(\x01R\x07acr\
    dInt\x12\x1d\n\nbook_yield\x18\r\x20\x01(\x01R\tbookYield\x12\x1b\n\tint\
    _basis\x18\x0e\x20\x01(\x03R\x08intBasis\x12\x1a\n\tavg_os_vd\x18\x0f\
    \x20\x01(\x01R\x07avgOsVd\x12\x1a\n\tavg_os_dd\x18\x10\x20\x01(\x01R\x07\
    avgOsDd\x12\x19\n\x08prin_amt\x18\x11\x20\x01(\x01R\x07prinAmt\x12\x17\n\
    \x07org_bal\x18\x12\x20\x01(\x01R\x06orgBal\x12\x17\n\x07coup_rt\x18\x13\
    \x20\x01(\x01R\x06coupRt\x12\x1e\n\x0bnxt_coup_dt\x18\x14\x20\x01(\x03R\
    \tnxtCoupDt\x12\x0e\n\x02gl\x18\x15\x20\x01(\x03R\x02gl\x12\x13\n\x05cf_\
    dt\x18\x16\x20\x01(\x03R\x04cfDt\x12\x1b\n\tsecu_desc\x18\x17\x20\x01(\t\
    R\x08secuDesc\x12\x1b\n\tprod_desc\x18\x18\x20\x01(\tR\x08prodDesc\x12\
    \x17\n\x07prod_cd\x18\x19\x20\x01(\tR\x06prodCd\x12\x1e\n\x0blst_coup_dt\
    \x18\x1a\x20\x01(\x03R\tlstCoupDt\x12\x19\n\x08call_dt1\x18\x1b\x20\x01(\
    \x03R\x07callDt1\x12\x1b\n\tcoup_freq\x18\x1c\x20\x01(\tR\x08coupFreq\
    \x12\x15\n\x06val_dt\x18\x1d\x20\x01(\x03R\x05valDt\x12\x1b\n\tacrl_freq\
    \x18\x1e\x20\x01(\tR\x08acrlFreq\x12\x1c\n\nlst_rep_dt\x18\x1f\x20\x01(\
    \x03R\x08lstRepDt\x12\x1c\n\nlst_put_dt\x18\x20\x20\x01(\x03R\x08lstPutD\
    t\x12\x12\n\x04inst\x18!\x20\x01(\tR\x04inst\x12\x19\n\x08org_term\x18\"\
    \x20\x01(\x03R\x07orgTerm\x12\x1d\n\nacrl_basis\x18#\x20\x01(\tR\tacrlBa\
    sis\x12\x10\n\x03div\x18$\x20\x01(\tR\x03div\x12\x19\n\x08alm_line\x18%\
    \x20\x01(\tR\x07almLine\x12\x17\n\x07ia_line\x18&\x20\x01(\tR\x06iaLine\
    \x12\x1d\n\ncmpnd_freq\x18'\x20\x01(\x03R\tcmpndFreq\x12\x20\n\x0cnxt_cm\
    pnd_dt\x18(\x20\x01(\x03R\nnxtCmpndDt\x12\x20\n\x0crt_chng_freq\x18)\x20\
    \x01(\x03R\nrtChngFreq\x12\x15\n\x06rt_flg\x18*\x20\x01(\tR\x05rtFlg\x12\
    \x17\n\x07rep_idx\x18+\x20\x01(\tR\x06repIdx\x12\x1c\n\nnxt_pay_dt\x18,\
    \x20\x01(\x03R\x08nxtPayDt\x12\x1e\n\x0bprev_rep_dt\x18-\x20\x01(\x03R\t\
    prevRepDt\x12\x20\n\x0cint_pay_freq\x18.\x20\x01(\x03R\nintPayFreq\x12\
    \x15\n\x06int_rt\x18/\x20\x01(\x01R\x05intRt\x12\x19\n\x08port_typ\x180\
    \x20\x01(\tR\x07portTyp\x12\x17\n\x07sec_grp\x181\x20\x01(\tR\x06secGrp\
    \x12\x19\n\x08sec_type\x182\x20\x01(\tR\x07secType\x12\x1d\n\nsec_issuer\
    \x183\x20\x01(\tR\tsecIssuer\x12%\n\x0esec_guaranteed\x184\x20\x01(\tR\r\
    secGuaranteed\x12\x12\n\x04mrkt\x185\x20\x01(\tR\x04mrkt\x12\x1b\n\tidx_\
    label\x186\x20\x01(\tR\x08idxLabel\x12\x19\n\x08bd_categ\x187\x20\x01(\t\
    R\x07bdCateg\x12\x17\n\x07bd_type\x188\x20\x01(\tR\x06bdType\x12\x16\n\
    \x06listed\x189\x20\x01(\tR\x06listed\x12\x1b\n\tnpa_class\x18:\x20\x01(\
    \tR\x08npaClass\x12\x16\n\x06entity\x18;\x20\x01(\tR\x06entity\x12\x12\n\
    \x04desk\x18<\x20\x01(\tR\x04desk\x12\"\n\racc_sec_igaap\x18=\x20\x01(\t\
    R\x0baccSecIgaap\x12+\n\x12os_cv_before_amort\x18>\x20\x01(\x01R\x0fosCv\
    BeforeAmort\x12)\n\x11os_cv_after_amort\x18?\x20\x01(\x01R\x0eosCvAfterA\
    mort\x12\x15\n\x06mat_dt\x18@\x20\x01(\x03R\x05matDt\x12\x17\n\x07int_am\
    t\x18A\x20\x01(\x01R\x06intAmt\x12\x1b\n\tflow_type\x18B\x20\x01(\tR\x08\
    flowType\x12\x12\n\x04isin\x18C\x20\x01(\tR\x04isin\x12\x1b\n\torg_tenor\
    \x18D\x20\x01(\x03R\x08orgTenor\x12\x1b\n\trep_tenor\x18E\x20\x01(\x03R\
    \x08repTenor\x12\x1c\n\nftp_mat_dt\x18F\x20\x01(\x03R\x08ftpMatDt\x12\
    \x1f\n\x0bcontract_no\x18G\x20\x01(\tR\ncontractNo\x12\x19\n\x08instr_id\
    \x18H\x20\x01(\tR\x07instrId\x12\x1f\n\x0bparent_code\x18I\x20\x01(\tR\n\
    parentCode\x12\x1f\n\x0bissuer_name\x18J\x20\x01(\tR\nissuerName\x12\x16\
    \n\x06rating\x18K\x20\x01(\tR\x06rating\x12\x1d\n\ntax_status\x18L\x20\
    \x01(\tR\ttaxStatus\x12\x19\n\x08slr_nslr\x18M\x20\x01(\tR\x07slrNslr\
    \x12\x19\n\x08deal_ytm\x18N\x20\x01(\x01R\x07dealYtm\x12\"\n\rintr_app_f\
    req\x18O\x20\x01(\tR\x0bintrAppFreq\x12\x1b\n\tcomp_freq\x18P\x20\x01(\t\
    R\x08compFreq\x12\x1b\n\tintr_prac\x18Q\x20\x01(\tR\x08intrPrac\x12\x1f\
    \n\x0brate_spread\x18R\x20\x01(\tR\nrateSpread\x12\x1f\n\x0basset_class\
    \x18S\x20\x01(\tR\nassetClass\x12\x19\n\x08intr_typ\x18T\x20\x01(\tR\x07\
    intrTyp\x12*\n\x11sec_issuance_date\x18U\x20\x01(\x03R\x0fsecIssuanceDat\
    e\x12\x16\n\x06coupon\x18V\x20\x01(\tR\x06coupon\x12\x20\n\x0clast_intr_\
    dt\x18W\x20\x01(\x03R\nlastIntrDt\x12\x20\n\x0cnext_intr_dt\x18X\x20\x01\
    (\x03R\nnextIntrDt\x12\"\n\ramort_till_dt\x18Y\x20\x01(\x01R\x0bamortTil\
    lDt\x12\x1e\n\x0btot_int_amt\x18Z\x20\x01(\x01R\ttotIntAmt\x12\x20\n\x0c\
    tot_prin_amt\x18[\x20\x01(\x01R\ntotPrinAmt\x12\x16\n\x06Method\x18\\\
    \x20\x01(\x05R\x06Method\x12\x1c\n\tBaseCurve\x18]\x20\x01(\x05R\tBaseCu\
    rve\x12\x1b\n\tftp_runid\x18^\x20\x01(\x03R\x08ftpRunid\x12\x1b\n\tfrom_\
    date\x18_\x20\x01(\x05R\x08fromDate\x12\x17\n\x07to_date\x18`\x20\x01(\
    \x05R\x06toDate\x12#\n\rtotal_balance\x18a\x20\x01(\x01R\x0ctotalBalance\
    \x12,\n\x12total_interest_ftp\x18b\x20\x01(\x01R\x10totalInterestFtp\x12\
    \x1b\n\ttotal_ftp\x18c\x20\x01(\x01R\x08totalFtp\x12\x19\n\x08FTP_Rate\
    \x18d\x20\x01(\x01R\x07FTPRate\x12'\n\tcashflows\x18e\x20\x03(\x0b2\t.Ca\
    shflowR\tcashflowsb\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy {
    lock: ::protobuf::lazy::ONCE_INIT,
    ptr: 0 as *const ::protobuf::descriptor::FileDescriptorProto,
};

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
